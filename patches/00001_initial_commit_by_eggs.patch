diff --git a/Makefile.miyoomini b/Makefile.miyoomini
new file mode 100644
index 0000000000..a5c8cbd1a8
--- /dev/null
+++ b/Makefile.miyoomini
@@ -0,0 +1,217 @@
+#########################
+## Toolchain variables ##
+#########################
+
+# Default toolchain directory
+TOOLCHAIN_DIR=/opt/miyoomini-toolchain
+
+# All toolchain-related variables may be
+# overridden via the command line
+
+CC		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-gcc
+CXX		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-g++
+STRIP		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-strip
+
+SDL_CONFIG	?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/bin/sdl-config
+FREETYPE_CONFIG	?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/bin/freetype-config
+
+INC_DIR		?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/include
+LIB_DIR		?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/lib
+
+LTO		= -flto
+STRIP_BIN	= 1
+
+#########################
+#########################
+
+ifeq ($(PACKAGE_NAME),)
+PACKAGE_NAME = retroarch
+endif
+
+DEBUG ?= 0
+
+MIYOOMINI = 1
+DINGUX = 1
+HAVE_SCREENSHOTS = 1
+HAVE_REWIND = 1
+HAVE_7ZIP = 1
+HAVE_AL = 0
+HAVE_ALSA = 0
+HAVE_DSP_FILTER = 1
+HAVE_VIDEO_FILTER = 1
+HAVE_STATIC_VIDEO_FILTERS = 1
+HAVE_STATIC_AUDIO_FILTERS = 1
+HAVE_FILTERS_BUILTIN	= 1
+HAVE_BUILTINMBEDTLS = 0
+HAVE_BUILTINZLIB = 1
+HAVE_C99 = 1
+HAVE_CC = 1
+#HAVE_CC_RESAMPLER = 1
+HAVE_CHD = 1
+HAVE_COMMAND = 1
+HAVE_CXX = 1
+HAVE_DR_MP3 = 1
+HAVE_DYNAMIC = 1
+HAVE_DYLIB = 1
+HAVE_EGL = 0
+HAVE_FREETYPE = 0
+HAVE_GDI = 1
+HAVE_GETOPT_LONG = 1
+HAVE_GLSL = 0
+HAVE_HID = 0
+HAVE_IBXM = 1
+HAVE_IMAGEVIEWER = 0
+HAVE_LANGEXTRA = 1
+HAVE_LIBRETRODB = 1
+HAVE_MENU = 1
+HAVE_MENU_COMMON = 1
+HAVE_GFX_WIDGETS = 1
+HAVE_MMAP = 1
+HAVE_OPENDINGUX_FBDEV = 0
+HAVE_OPENGL = 0
+HAVE_OPENGL1 = 0
+HAVE_OPENGLES = 0
+HAVE_OPENGLES3 = 0
+HAVE_OPENGL_CORE = 0
+HAVE_OPENSSL = 1
+HAVE_OVERLAY = 1
+HAVE_RBMP = 1
+HAVE_RJPEG = 1
+HAVE_RPILED = 0
+HAVE_RPNG = 1
+HAVE_RUNAHEAD = 1
+HAVE_SDL_DINGUX = 1
+HAVE_SHADERPIPELINE = 0
+HAVE_STB_FONT = 0
+HAVE_STB_IMAGE = 0
+HAVE_STB_VORBIS = 0
+HAVE_STDIN_CMD = 0
+HAVE_STRCASESTR = 1
+HAVE_THREADS = 1
+HAVE_UDEV = 0
+HAVE_RGUI = 1
+HAVE_MATERIALUI = 0
+HAVE_XMB = 0
+HAVE_OZONE = 0
+HAVE_ZLIB = 1
+HAVE_CONFIGFILE = 1
+HAVE_PATCH = 1
+HAVE_CHEATS = 1
+HAVE_LIBSHAKE = 0
+HAVE_CORE_INFO_CACHE = 1
+#HAVE_TINYALSA = 1
+HAVE_NEAREST_RESAMPLER = 1
+HAVE_NEON = 1
+HAVE_OSS = 1
+HAVE_AUDIOIO = 1
+HAVE_TRANSLATE = 0
+HAVE_VIDEO_LAYOUT = 1
+HAVE_NETWORKING = 1
+HAVE_GETADDRINFO = 1
+HAVE_IFINFO = 1
+
+ifeq ($(MIYOO354),1)
+# Netplay and Cheevos for MMP
+HAVE_NETPLAYDISCOVERY = 1
+HAVE_CHEEVOS = 1
+endif
+
+OS = Linux
+TARGET = $(PACKAGE_NAME)
+
+OBJ :=
+OBJ += miyoo.o
+LINK := $(CXX)
+DEF_FLAGS := -marm -mtune=cortex-a7 -march=armv7ve+simd -mfpu=neon-vfpv4 -mfloat-abi=hard -ffast-math -fomit-frame-pointer
+DEF_FLAGS += -ffunction-sections -fdata-sections
+DEF_FLAGS += -I. -Ideps -Ideps/stb -DMIYOOMINI -DDINGUX -MMD
+DEF_FLAGS += -Wall -Wno-unused-function -Wno-unused-variable $(LTO)
+DEF_FLAGS += -std=gnu99 -D_GNU_SOURCE
+LIBS := -ldl -lz -lrt -pthread -lmi_sys -lmi_gfx -lmi_ao -lmi_common
+CFLAGS :=
+CXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS
+ASFLAGS :=
+LDFLAGS := -Wl,--gc-sections -s
+INCLUDE_DIRS = -I$(INC_DIR)
+LIBRARY_DIRS = -L$(LIB_DIR)
+DEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY
+DEFINES += -DHAVE_C99=1 -DHAVE_CXX=1
+DEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1 -DHAVE_OSS -DHAVE_AUDIOIO
+DEFINES += -DHAVE_FILTERS_BUILTIN -DHAVE_ARM_NEON_ASM_OPTIMIZATIONS
+
+# ifeq ($(ADD_NETWORKING),1)
+# DEFINES += -DHAVE_ONLINE_UPDATER=1 -DHAVE_UPDATE_ASSETS=1
+# endif
+
+SDL_DINGUX_CFLAGS := $(shell $(SDL_CONFIG) --cflags)
+SDL_DINGUX_LIBS := $(shell $(SDL_CONFIG) --libs)
+FREETYPE_CFLAGS := $(shell $(FREETYPE_CONFIG) --cflags)
+FREETYPE_LIBS := $(shell $(FREETYPE_CONFIG) --libs)
+MMAP_LIBS = -lc
+
+OBJDIR_BASE := obj-unix
+
+ifeq ($(DEBUG), 1)
+   OBJDIR := $(OBJDIR_BASE)/debug
+   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG
+else
+   OBJDIR := $(OBJDIR_BASE)/release
+   DEF_FLAGS += -Ofast -DNDEBUG
+endif
+
+include Makefile.common
+
+DEF_FLAGS += $(INCLUDE_DIRS)
+LDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)
+CFLAGS += $(DEF_FLAGS)
+CXXFLAGS += $(DEF_FLAGS)
+
+HEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)
+
+Q := @
+
+RARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))
+
+all: $(TARGET)
+
+-include $(RARCH_OBJ:.o=.d)
+
+SYMBOL_MAP := -Wl,-Map=output.map
+
+$(TARGET): $(RARCH_OBJ)
+	@$(if $(Q), $(shell echo echo LD $@),)
+	$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)
+
+ifeq ($(STRIP_BIN),1)
+	$(STRIP) --strip-unneeded $(TARGET)
+endif
+
+$(OBJDIR)/%.o: %.c
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo CC $<),)
+	$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<
+
+$(OBJDIR)/%.o: %.cpp
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo CXX $<),)
+	$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<
+
+$(OBJDIR)/%.o: %.m
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo OBJC $<),)
+	$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<
+
+$(OBJDIR)/%.o: %.S $(HEADERS)
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo AS $<),)
+	$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<
+
+clean:
+	rm -rf $(OBJDIR_BASE)
+	rm -f $(TARGET)
+	rm -f *.d
+
+.PHONY: all clean
+
+print-%:
+	@echo '$*=$($*)'
diff --git a/audio/drivers/audioio.c b/audio/drivers/audioio.c
index 8176a0d7b4..0e21b56c74 100644
--- a/audio/drivers/audioio.c
+++ b/audio/drivers/audioio.c
@@ -13,6 +13,10 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "audioio_miyoomini.c"
+#else
+
 #include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -210,3 +214,4 @@ audio_driver_t audio_audioio = {
    audioio_write_avail,
    audioio_buffer_size,
 };
+#endif
diff --git a/audio/drivers/audioio_miyoomini.c b/audio/drivers/audioio_miyoomini.c
new file mode 100644
index 0000000000..d73b5898b6
--- /dev/null
+++ b/audio/drivers/audioio_miyoomini.c
@@ -0,0 +1,250 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+      MIAO audio driver for miyoomini
+      The name "audioio" is used to minimize the number of files to be rewritten as much as possible,
+      but /dev/audio is not used.
+*/
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define YIELD_WAIT /* Flag to wait with sched_yield() when the wait time is less than 10ms */
+
+#include <mi_ao.h>
+#ifdef	YIELD_WAIT
+#include <sched.h>
+#ifndef	SCHED_IDLE
+#define SCHED_IDLE 5
+#endif
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include "../../config.h"
+#endif
+
+#include "../audio_driver.h"
+#include "../../verbosity.h"
+
+/* MI_AO_SendFrame Max bytes */
+#define MIAO_MAX_BUFSIZE 51200
+
+typedef struct miao_audio
+{
+   MI_AUDIO_Frame_t AoSendFrame;
+   size_t bufsize;
+   uint32_t freq;
+   bool nonblock;
+   bool is_paused;
+   void* nullbuf;
+} miao_audio_t;
+
+static void *miao_init(const char *device,
+      unsigned rate, unsigned latency,
+      unsigned block_frames,
+      unsigned *new_rate)
+{
+   MI_AUDIO_Attr_t attr;
+   uint32_t samples;
+
+   miao_audio_t *miaoaudio = (miao_audio_t*)calloc(1, sizeof(miao_audio_t));
+   if (!miaoaudio) return NULL;
+
+   const int freqtable[] = { 8000,11025,12000,16000,22050,24000,32000,44100,48000 };
+   for (uint32_t i=0; i<(sizeof(freqtable)/sizeof(int)); i++) {
+      if (rate <= freqtable[i]) { miaoaudio->freq = freqtable[i]; break; }
+   } if (rate > 48000) miaoaudio->freq = 48000;
+
+   if (miaoaudio->freq != rate) {
+      *new_rate = miaoaudio->freq;
+      RARCH_WARN("[MIAO]: Requested sample rate not supported, adjusting output rate to %d Hz.\n", *new_rate);
+   }
+
+   miaoaudio->bufsize = (latency * miaoaudio->freq / 1000) << 2;
+   miaoaudio->bufsize = (miaoaudio->bufsize + 15) & ~15;
+   if ( miaoaudio->bufsize == 0 ) miaoaudio->bufsize = 16;
+   else if ( miaoaudio->bufsize > MIAO_MAX_BUFSIZE ) miaoaudio->bufsize = MIAO_MAX_BUFSIZE;
+
+   RARCH_LOG("[MIAO]: Requested %u ms latency, got %.2f ms\n",
+         latency, (float)( (miaoaudio->bufsize >> 2) * 1000 / miaoaudio->freq ) );
+
+   samples = miaoaudio->bufsize >> 2;
+   if ( samples > 2048 ) samples = 2048;
+
+   memset(&attr, 0, sizeof(attr));
+   attr.eSamplerate = (MI_AUDIO_SampleRate_e)miaoaudio->freq;
+   attr.eSoundmode = E_MI_AUDIO_SOUND_MODE_STEREO;
+   attr.u32ChnCnt = 2;
+   attr.u32PtNumPerFrm = samples;
+   /* Maybe unnecessary but just in case */
+   miaoaudio->AoSendFrame.eSoundmode = E_MI_AUDIO_SOUND_MODE_STEREO;
+
+   if (MI_AO_SetPubAttr(0,&attr)) goto error;
+   if (MI_AO_Enable(0)) goto error;
+   if (MI_AO_EnableChn(0,0)) goto error;
+   if (MI_AO_SetMute(0,FALSE)) goto error;
+/* if (MI_AO_SetVolume(0,0)) goto error; */
+
+   /* Send pre-fill null data */
+   miaoaudio->nullbuf = calloc(1, miaoaudio->bufsize);
+   if (!miaoaudio->nullbuf) goto error;
+   miaoaudio->AoSendFrame.apVirAddr[0] = miaoaudio->nullbuf;
+   miaoaudio->AoSendFrame.u32Len = miaoaudio->bufsize;
+   MI_AO_ClearChnBuf(0,0);
+   MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+
+   return miaoaudio;
+
+error:
+   free(miaoaudio);
+   RARCH_ERR("[MIAO]: Failed to initialize...\n");
+   return NULL;
+}
+
+static ssize_t miao_write(void *data, const void *buf, size_t size)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   if ((!size)||(miaoaudio->is_paused)) return 0;
+
+   miaoaudio->AoSendFrame.apVirAddr[0] = (void*)buf;
+   ssize_t write_bytes;
+   uint32_t usleepclock;
+
+   MI_AO_ChnState_t status;
+   MI_AO_QueryChnStat(0, 0, &status);
+   int avail = miaoaudio->bufsize - status.u32ChnBusyNum;
+
+   if ( (avail < size) && (!miaoaudio->nonblock) ) {
+      write_bytes = size;
+      miaoaudio->AoSendFrame.u32Len = write_bytes;
+      MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+
+      /* wait process for miyoomini with 10ms sleep precision */
+      MI_AO_QueryChnStat(0, 0, &status);
+      if (status.u32ChnBusyNum > miaoaudio->bufsize) {
+         usleepclock = (uint64_t)(status.u32ChnBusyNum - miaoaudio->bufsize) * 1000000 / (miaoaudio->freq << 2);
+#ifndef YIELD_WAIT
+         if ( usleepclock ) usleep(usleepclock);
+#else
+         if ( usleepclock > 0x2800 ) usleep(usleepclock - 0x2800); /* 0.24ms margin */
+
+         const struct sched_param scprm = {0};
+         int policy = sched_getscheduler(0);
+         sched_setscheduler(0, SCHED_IDLE, &scprm);
+         do { sched_yield(); MI_AO_QueryChnStat(0, 0, &status);
+         } while(status.u32ChnBusyNum > miaoaudio->bufsize);
+         sched_setscheduler(0, policy, &scprm);
+#endif
+      }
+   } else {
+      write_bytes = avail > size ? size : avail;
+      if (write_bytes > 0) {
+         miaoaudio->AoSendFrame.u32Len = write_bytes;
+         MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+      } else return 0;
+   }
+   return write_bytes;
+}
+
+static bool miao_stop(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   if (!miaoaudio->is_paused) {
+      miaoaudio->is_paused = true;
+   }
+   return true;
+}
+
+static bool miao_start(void *data, bool is_shutdown)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   if (miaoaudio->is_paused) {
+      /* Send pre-fill null data */
+      miaoaudio->AoSendFrame.apVirAddr[0] = miaoaudio->nullbuf;
+      miaoaudio->AoSendFrame.u32Len = miaoaudio->bufsize;
+      MI_AO_ClearChnBuf(0,0);
+      MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+      miaoaudio->is_paused = false;
+   }
+   return true;
+}
+
+static bool miao_alive(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   return !miaoaudio->is_paused;
+}
+
+static void miao_set_nonblock_state(void *data, bool state)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   miaoaudio->nonblock = state;
+}
+
+static void miao_free(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   MI_AO_ClearChnBuf(0,0);
+   MI_AO_DisableChn(0,0);
+   MI_AO_Disable(0);
+   free(miaoaudio->nullbuf);
+   free(data);
+}
+
+static bool miao_use_float(void *data)
+{
+   (void)data;
+   return false;
+}
+
+static size_t miao_write_avail(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   MI_AO_ChnState_t status;
+
+   MI_AO_QueryChnStat(0, 0, &status);
+   int avail = MIAO_MAX_BUFSIZE - status.u32ChnBusyNum;
+/* not sure which is better value... */
+/* int avail = miaoaudio->bufsize - status.u32ChnBusyNum; */
+   return (avail > 0) ? avail : 0;
+}
+
+static size_t miao_buffer_size(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   return MIAO_MAX_BUFSIZE;
+/* return miaoaudio->bufsize; */
+}
+
+audio_driver_t audio_audioio = {
+   miao_init,
+   miao_write,
+   miao_stop,
+   miao_start,
+   miao_alive,
+   miao_set_nonblock_state,
+   miao_free,
+   miao_use_float,
+   "audioio",
+   NULL,
+   NULL,
+   miao_write_avail,
+   miao_buffer_size,
+};
diff --git a/audio/drivers/oss.c b/audio/drivers/oss.c
index 52b525ac34..da2f2e1a78 100644
--- a/audio/drivers/oss.c
+++ b/audio/drivers/oss.c
@@ -13,6 +13,10 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "oss_miyoomini.c"
+#else
+
 #include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -228,3 +232,4 @@ audio_driver_t audio_oss = {
    oss_write_avail,
    oss_buffer_size,
 };
+#endif
diff --git a/audio/drivers/oss_miyoomini.c b/audio/drivers/oss_miyoomini.c
new file mode 100644
index 0000000000..93e58666b8
--- /dev/null
+++ b/audio/drivers/oss_miyoomini.c
@@ -0,0 +1,242 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+      Modified OSS driver exclusively for miyoomini
+      Supports both AudioFix: ON / OFF
+*/
+
+/* To use audioserver, must use open instead of open64 */
+#ifdef _FILE_OFFSET_BITS
+#undef _FILE_OFFSET_BITS
+#define _FILE_OFFSET_BITS 32
+#endif
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/soundcard.h>
+#include <mi_ao.h>
+
+#ifdef HAVE_CONFIG_H
+#include "../../config.h"
+#endif
+
+#include "../audio_driver.h"
+#include "../../verbosity.h"
+
+#define DEFAULT_OSS_DEV "/dev/dsp"
+
+typedef struct oss_audio
+{
+   int fd;
+   bool is_paused;
+   bool nonblock;
+   bool audioserver;
+} oss_audio_t;
+
+static void *oss_init(const char *device,
+      unsigned rate, unsigned latency,
+      unsigned block_frames,
+      unsigned *new_out_rate)
+{
+   int frags, frag, channels, format, new_rate;
+   oss_audio_t *ossaudio  = (oss_audio_t*)calloc(1, sizeof(oss_audio_t));
+   const char *oss_device = device ? device : DEFAULT_OSS_DEV;
+
+   if (!ossaudio)
+      return NULL;
+
+   /* Open /dev/dsp with audioserver check */
+   /* Use the fact that padsp replaces open, but not __open */
+   extern int __open(const char *file, int oflag);
+   if ((ossaudio->fd = __open(oss_device, O_WRONLY)) < 0) {
+      if ((ossaudio->fd = open(oss_device, O_WRONLY)) < 0) {
+         free(ossaudio);
+         perror("open");
+         return NULL;
+      }
+      ossaudio->audioserver = true;
+      new_rate = rate;
+      RARCH_LOG("[OSS]: Using audioserver.\n");
+   } else {
+      /* stock oss supports 48k, 32k, 16k, 8k only */
+      if ( rate > 32000 ) new_rate = 48000;
+      else if ( rate > 16000 ) new_rate = 32000;
+      else if ( rate > 8000 ) new_rate = 16000;
+      else new_rate = 8000;
+   }
+
+   frags = (latency * new_rate * 4) / (1000 * (1 << 10));
+   frag  = (frags << 16) | 10;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_SETFRAGMENT, &frag) < 0)
+      RARCH_WARN("Cannot set fragment sizes. Latency might not be as expected ...\n");
+
+   channels = 2;
+   format   = AFMT_S16_LE;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_CHANNELS, &channels) < 0)
+      goto error;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_SETFMT, &format) < 0)
+      goto error;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_SPEED, &new_rate) < 0)
+      goto error;
+
+   if (new_rate != (int)rate)
+   {
+      RARCH_WARN("Requested sample rate not supported. Adjusting output rate to %d Hz.\n", new_rate);
+      *new_out_rate = new_rate;
+   }
+
+   if (!ossaudio->audioserver) {
+      /* mi_ao init is required for stock oss */
+      MI_AUDIO_Attr_t attr;
+      memset(&attr, 0, sizeof(attr));
+      attr.eSamplerate = new_rate;
+      attr.eSoundmode = E_MI_AUDIO_SOUND_MODE_STEREO;
+      attr.u32ChnCnt = 2;
+      attr.u32PtNumPerFrm = 256;
+      MI_AO_SetPubAttr(0, &attr);
+   }
+
+   return ossaudio;
+
+error:
+   close(ossaudio->fd);
+   if (ossaudio)
+      free(ossaudio);
+   perror("ioctl");
+   return NULL;
+}
+
+static ssize_t oss_write(void *data, const void *buf, size_t size)
+{
+   ssize_t ret;
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   /* For stock oss, no playback during fast forward to avoid blocking */
+   if ( (size == 0) || ((!ossaudio->audioserver)&&(ossaudio->nonblock)) )
+      return 0;
+
+   if ((ret = write(ossaudio->fd, buf, size)) < 0)
+   {
+      if (errno == EAGAIN && (fcntl(ossaudio->fd, F_GETFL) & O_NONBLOCK))
+         return 0;
+
+      return -1;
+   }
+
+   return ret;
+}
+
+static bool oss_stop(void *data)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   ossaudio->is_paused = true;
+   return true;
+}
+
+static bool oss_start(void *data, bool is_shutdown)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+   if (!ossaudio) return false;
+
+   ossaudio->is_paused = false;
+   return true;
+}
+
+static bool oss_alive(void *data)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+   return !ossaudio->is_paused;
+}
+
+static void oss_set_nonblock_state(void *data, bool state)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   if (state) fcntl(ossaudio->fd, F_SETFL, fcntl(ossaudio->fd, F_GETFL) | O_NONBLOCK);
+   else       fcntl(ossaudio->fd, F_SETFL, fcntl(ossaudio->fd, F_GETFL) & (~O_NONBLOCK));
+
+   ossaudio->nonblock = state;
+}
+
+static void oss_free(void *data)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   close(ossaudio->fd);
+   free(data);
+}
+
+static size_t oss_write_avail(void *data)
+{
+   audio_buf_info info;
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      RARCH_ERR("[OSS]: SNDCTL_DSP_GETOSPACE failed ...\n");
+      return 0;
+   }
+
+   return info.bytes;
+}
+
+static size_t oss_buffer_size(void *data)
+{
+   audio_buf_info info;
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      RARCH_ERR("[OSS]: SNDCTL_DSP_GETOSPACE failed ...\n");
+      return 1; /* Return something non-zero to avoid SIGFPE. */
+   }
+
+   return info.fragsize * info.fragstotal;
+}
+
+static bool oss_use_float(void *data)
+{
+   (void)data;
+   return false;
+}
+
+audio_driver_t audio_oss = {
+   oss_init,
+   oss_write,
+   oss_stop,
+   oss_start,
+   oss_alive,
+   oss_set_nonblock_state,
+   oss_free,
+   oss_use_float,
+   "oss",
+   NULL,
+   NULL,
+   oss_write_avail,
+   oss_buffer_size,
+};
diff --git a/audio/drivers/sdl_audio.c b/audio/drivers/sdl_audio.c
index 56554083f5..1ac734992a 100644
--- a/audio/drivers/sdl_audio.c
+++ b/audio/drivers/sdl_audio.c
@@ -13,6 +13,9 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "sdl_audio_miyoomini.c"
+#else
 
 #include <stdint.h>
 #include <stddef.h>
@@ -276,3 +279,4 @@ audio_driver_t audio_sdl = {
    sdl_audio_write_avail,
    NULL
 };
+#endif
diff --git a/audio/drivers/sdl_audio_miyoomini.c b/audio/drivers/sdl_audio_miyoomini.c
new file mode 100644
index 0000000000..24082d996a
--- /dev/null
+++ b/audio/drivers/sdl_audio_miyoomini.c
@@ -0,0 +1,272 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+      SDL audio driver for miyoomini customSDL
+      Can be used with standard SDL as well
+*/
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <boolean.h>
+#include <rthreads/rthreads.h>
+#include <queues/fifo_queue.h>
+#include <retro_inline.h>
+#include <retro_math.h>
+
+#include "SDL.h"
+#include "SDL_audio.h"
+
+#include "../audio_driver.h"
+#include "../../verbosity.h"
+
+#define SDL_AUDIO_SAMPLES 256
+
+typedef struct sdl_audio
+{
+#ifdef HAVE_THREADS
+   slock_t *lock;
+   scond_t *cond;
+#endif
+   fifo_buffer_t *buffer;
+   bool nonblock;
+   bool is_paused;
+   size_t bufsize;
+} sdl_audio_t;
+
+static void sdl_audio_cb(void *data, Uint8 *stream, int len)
+{
+   sdl_audio_t  *sdl = (sdl_audio_t*)data;
+   size_t      avail = FIFO_READ_AVAIL(sdl->buffer);
+   size_t write_size = len > (int)avail ? avail : len;
+
+   fifo_read(sdl->buffer, stream, write_size);
+#ifdef HAVE_THREADS
+   scond_signal(sdl->cond);
+#endif
+#ifdef HAVE_SDL2
+   /* If underrun, fill rest with silence. */
+   if (len > (int)avail) memset(stream + write_size, 0, len - write_size);
+#endif
+}
+
+static void *sdl_audio_init(const char *device,
+      unsigned rate, unsigned latency,
+      unsigned block_frames,
+      unsigned *new_rate)
+{
+   int frames;
+   SDL_AudioSpec out;
+   SDL_AudioSpec spec           = {0};
+   void *tmp                    = NULL;
+   sdl_audio_t *sdl             = NULL;
+   uint32_t sdl_subsystem_flags = SDL_WasInit(0);
+
+   (void)device;
+
+   /* Initialise audio subsystem, if required */
+   if (sdl_subsystem_flags == 0)
+   {
+      if (SDL_Init(SDL_INIT_AUDIO) < 0)
+         return NULL;
+   }
+   else if ((sdl_subsystem_flags & SDL_INIT_AUDIO) == 0)
+   {
+      if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0)
+         return NULL;
+   }
+
+   sdl = (sdl_audio_t*)calloc(1, sizeof(*sdl));
+   if (!sdl)
+      return NULL;
+
+   spec.freq     = rate;
+   spec.format   = AUDIO_S16SYS;
+   spec.channels = 2;
+   spec.samples  = SDL_AUDIO_SAMPLES;
+   spec.callback = sdl_audio_cb;
+   spec.userdata = sdl;
+
+   if (SDL_OpenAudio(&spec, &out) < 0)
+   {
+      RARCH_ERR("[SDL audio]: Failed to open SDL audio: %s\n", SDL_GetError());
+      goto error;
+   }
+
+#ifdef HAVE_THREADS
+   sdl->lock = slock_new();
+   sdl->cond = scond_new();
+#endif
+
+   *new_rate = out.freq;
+   frames    = (latency * (out.freq - 1)) / (1000 * out.samples) + 1;
+   if (frames < 2) frames = 2; /* at least 2 frames */
+
+   RARCH_LOG("[SDL audio]: Requested %u ms latency, got %d ms\n",
+         latency, (int)(out.samples * frames * 1000 / (*new_rate)));
+
+   /* Create a buffer twice as big as needed */
+   sdl->bufsize = out.samples * out.channels * sizeof(int16_t) * frames * 2;
+   sdl->buffer  = fifo_new(sdl->bufsize);
+
+   /* Allocate the null-buffer and prefill */
+   tmp = calloc(1, (sdl->bufsize / 2));
+   if (tmp) { fifo_write(sdl->buffer, tmp, (sdl->bufsize / 2)); free(tmp); }
+
+   SDL_PauseAudio(0);
+
+   return sdl;
+
+error:
+   free(sdl);
+   return NULL;
+}
+
+static ssize_t sdl_audio_write(void *data, const void *buf, size_t size)
+{
+   ssize_t ret      = 0;
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+
+   if (sdl->nonblock)
+   {
+      size_t avail, write_amt;
+
+      SDL_LockAudio();
+      avail = FIFO_WRITE_AVAIL(sdl->buffer);
+      write_amt = avail > size ? size : avail;
+      fifo_write(sdl->buffer, buf, write_amt);
+      SDL_UnlockAudio();
+      ret = write_amt;
+   }
+   else
+   {
+      size_t written = 0;
+
+      while (written < size)
+      {
+         size_t avail;
+
+         SDL_LockAudio();
+         avail = FIFO_WRITE_AVAIL(sdl->buffer);
+
+         if (avail < (sdl->bufsize/2))
+         {
+            SDL_UnlockAudio();
+#ifdef HAVE_THREADS
+            slock_lock(sdl->lock);
+            scond_wait(sdl->cond, sdl->lock);
+            slock_unlock(sdl->lock);
+#endif
+         }
+         else
+         {
+            size_t write_amt = size - written > avail ? avail : size - written;
+            fifo_write(sdl->buffer, (const char*)buf + written, write_amt);
+            SDL_UnlockAudio();
+            written += write_amt;
+         }
+      }
+      ret = written;
+   }
+
+   return ret;
+}
+
+static bool sdl_audio_stop(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   SDL_PauseAudio(1);
+   sdl->is_paused = true;
+   return true;
+}
+
+static bool sdl_audio_alive(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   return !sdl->is_paused;
+}
+
+static bool sdl_audio_start(void *data, bool is_shutdown)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   SDL_PauseAudio(0);
+   sdl->is_paused = false;
+   return true;
+}
+
+static void sdl_audio_set_nonblock_state(void *data, bool state)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   sdl->nonblock = state;
+}
+
+static void sdl_audio_free(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+
+   SDL_CloseAudio();
+
+   fifo_free(sdl->buffer);
+#ifdef HAVE_THREADS
+   slock_free(sdl->lock);
+   scond_free(sdl->cond);
+#endif
+   free(sdl);
+}
+
+static bool sdl_audio_use_float(void *data)
+{
+   (void)data;
+   return false;
+}
+
+static size_t sdl_audio_write_avail(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   SDL_LockAudio();
+   size_t avail = FIFO_WRITE_AVAIL(sdl->buffer);
+   SDL_UnlockAudio();
+   return avail;
+}
+
+static size_t sdl_audio_buffer_size(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   return sdl->bufsize;
+}
+
+audio_driver_t audio_sdl = {
+   sdl_audio_init,
+   sdl_audio_write,
+   sdl_audio_stop,
+   sdl_audio_start,
+   sdl_audio_alive,
+   sdl_audio_set_nonblock_state,
+   sdl_audio_free,
+   sdl_audio_use_float,
+#ifdef HAVE_SDL2
+   "sdl2",
+#else
+   "sdl",
+#endif
+   NULL,
+   NULL,
+   sdl_audio_write_avail,
+   sdl_audio_buffer_size,
+};
diff --git a/dingux/dingux_utils.c b/dingux/dingux_utils.c
index b50b9c566a..fb4d8fc45e 100644
--- a/dingux/dingux_utils.c
+++ b/dingux/dingux_utils.c
@@ -22,6 +22,13 @@
 #if defined(RS90)
 #include <lists/dir_list.h>
 #endif
+#if defined(MIYOOMINI)
+#include <fcntl.h>
+#include <linux/i2c-dev.h>
+#include <linux/i2c.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#endif
 
 #include <stdlib.h>
 
@@ -373,6 +380,70 @@ int dingux_get_battery_level(void)
       return -1;
 
    return (int)(((voltage_now - voltage_min) * 100) / (voltage_max - voltage_min));
+#elif defined(MIYOOMINI)
+   // for miyoomini plus
+#define AXPDEV "/dev/i2c-1"
+#define AXPID (0x34)
+   static uint32_t mmplus = 2;
+
+   if (mmplus) {
+      int axp_fd = open(AXPDEV, O_RDWR);
+      if (axp_fd >= 0) {
+         struct i2c_msg msg[2];
+         struct i2c_rdwr_ioctl_data packets;
+         unsigned char address = 0xB9;
+         unsigned char val;
+         if (mmplus == 2) {
+         ioctl(axp_fd, I2C_TIMEOUT, 5);
+         ioctl(axp_fd, I2C_RETRIES, 1);
+         mmplus = 1;
+         }
+         msg[0].addr = AXPID;
+         msg[0].flags = 0;
+         msg[0].len = 1;
+         msg[0].buf = &address;
+         msg[1].addr = AXPID;
+         msg[1].flags = I2C_M_RD;
+         msg[1].len = 1;
+         msg[1].buf = &val;
+         packets.nmsgs = 2;
+         packets.msgs = &msg[0];
+         int ret = ioctl(axp_fd, I2C_RDWR, &packets);
+         close(axp_fd);
+         if (ret < 0)
+         mmplus = 0;
+         else
+         return (val & 0x7f);
+      }
+   }
+   // for miyoomini
+   int percBat = 0;
+   typedef struct {
+      int channel_value;
+      int adc_value;
+   } SAR_ADC_CONFIG_READ;
+#define SARADC_IOC_MAGIC 'a'
+#define IOCTL_SAR_INIT _IO(SARADC_IOC_MAGIC, 0)
+#define IOCTL_SAR_SET_CHANNEL_READ_VALUE _IO(SARADC_IOC_MAGIC, 1)
+   static SAR_ADC_CONFIG_READ adcCfg = {0, 0};
+   static int sar_fd = 0;
+   if (!sar_fd) {
+      sar_fd = open("/dev/sar", O_WRONLY);
+      ioctl(sar_fd, IOCTL_SAR_INIT, NULL);
+   }
+   ioctl(sar_fd, IOCTL_SAR_SET_CHANNEL_READ_VALUE, &adcCfg);
+   if (adcCfg.adc_value >= 528) {
+      percBat = adcCfg.adc_value - 478;
+   } else if ((adcCfg.adc_value >= 512) && (adcCfg.adc_value < 528)) {
+      percBat = (int)(adcCfg.adc_value * 2.125 - 1068);
+   } else if ((adcCfg.adc_value >= 480) && (adcCfg.adc_value < 512)) {
+      percBat = (int)(adcCfg.adc_value * 0.51613 - 243.742);
+   }
+   if (percBat > 100) {
+      percBat = 100;
+   }
+
+   return percBat;
 #elif defined(MIYOO)
    /* miyoo-battery only provides "voltage_now". Results are based on
     * value distribution while running a game at max load. */
diff --git a/gfx/drivers/miyoomini/gfx.c b/gfx/drivers/miyoomini/gfx.c
new file mode 100644
index 0000000000..a082a65407
--- /dev/null
+++ b/gfx/drivers/miyoomini/gfx.c
@@ -0,0 +1,1044 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <SDL/SDL.h>
+#include <mi_sys.h>
+#include <mi_gfx.h>
+
+#define	pixelsPa	unused1
+#define ALIGN4K(val)	((val+4095)&(~4095))
+//	FREEMMA		: force free all allocated MMAs when init & quit
+#define FREEMMA
+//	CLEARFBATQUIT	: clear framebuffer when quit
+#define CLEARFBATQUIT
+//	GFX_BLOCKING	: limit to 60fps but never skips frames
+//			:  in case of clearing all buffers by GFX_Flip()x3, needs to use BLOCKING (or GFX_FlipForce())
+//	GFX_FLIPWAIT	: wait until Blit is done when flip
+//			:  when NOWAIT, do not clear/write source surface immediately after Flip
+//			:  if absolutely necessary, use GFX_WaitAllDone() before write (or GFX_FlipWait())
+enum { GFX_BLOCKING = 1, GFX_FLIPWAIT = 2 };
+//#define	DEFAULTFLIPFLAGS	(GFX_BLOCKING | GFX_FLIPWAIT)		// low performance with blocking
+//#define	DEFAULTFLIPFLAGS	(GFX_FLIPWAIT)				// middle performance nonblock, recommended for most cases
+#define	DEFAULTFLIPFLAGS	0					// high performance but with the above precautions
+
+int			fd_fb = 0;
+void			*fb_addr;
+uint32_t 		res_x, res_y;
+struct			fb_fix_screeninfo finfo;
+struct			fb_var_screeninfo vinfo;
+MI_GFX_Surface_t	stSrc;
+MI_GFX_Rect_t		stSrcRect;
+MI_GFX_Surface_t	stDst;
+MI_GFX_Rect_t		stDstRect;
+MI_GFX_Opt_t		stOpt;
+volatile uint32_t	now_flipping;
+MI_PHY			shadowPa;
+uint32_t		shadowsize;
+pthread_t		flip_pt;
+pthread_mutex_t		flip_mx;
+pthread_cond_t		flip_req;
+pthread_cond_t		flip_start;
+MI_U16			flipFence;
+uint32_t		flipFlags;
+SDL_Surface		*sHWsurface;
+SDL_Surface		*videosurface;
+MI_GFX_Surface_t	sHW;
+MI_GFX_Rect_t		sHWRect;
+MI_GFX_Opt_t		sHWOpt;
+void			(*flip_callback)(void*) = NULL;
+void			*userdata_callback = NULL;
+#ifdef	HAVE_OVERLAY
+SDL_Surface		*ovrsurface;
+MI_GFX_Surface_t	OvrSrc;
+MI_GFX_Rect_t		OvrSrcRect;
+MI_GFX_Surface_t	OvrDst;
+MI_GFX_Rect_t		OvrDstRect;
+MI_GFX_Opt_t		OvrOpt;
+#endif
+#ifndef	FREEMMA
+#define			MMADBMAX	100
+uint32_t		mma_db[MMADBMAX];
+#endif
+
+//
+//	Actual Flip thread
+//
+static void* GFX_FlipThread(void* param) {
+	uint32_t	target_offset;
+	MI_U16		Fence;
+	pthread_mutex_lock(&flip_mx);
+	while(1) {
+		while (!now_flipping) pthread_cond_wait(&flip_req, &flip_mx);
+		Fence = flipFence;
+		do {	target_offset = vinfo.yoffset + res_y;
+			if ( target_offset == res_y * 3 ) target_offset = 0;
+			vinfo.yoffset = target_offset;
+			pthread_cond_signal(&flip_start);
+			pthread_mutex_unlock(&flip_mx);
+#ifdef	HAVE_OVERLAY
+			if (ovrsurface) {
+				MI_GFX_WaitAllDone(FALSE, flipFence);
+				OvrDst.phyAddr = finfo.smem_start + (res_x*target_offset*4);
+				MI_GFX_BitBlit(&OvrSrc, &OvrSrcRect, &OvrDst, &OvrDstRect, &OvrOpt, &Fence);
+				MI_GFX_WaitAllDone(FALSE, Fence); Fence = 0;
+				if (flip_callback) flip_callback(userdata_callback);
+			} else
+#endif
+			if (flip_callback) {
+				// Wait done always when callback is active
+				MI_GFX_WaitAllDone(FALSE, flipFence); Fence = 0;
+				flip_callback(userdata_callback);
+			} else if (Fence) { MI_GFX_WaitAllDone(FALSE, Fence); Fence = 0; }
+			ioctl(fd_fb, FBIOPAN_DISPLAY, &vinfo);
+			pthread_mutex_lock(&flip_mx);
+		} while(--now_flipping);
+	}
+	return 0;
+}
+
+//
+//	Actual Flip thread ( for single HW surface )
+//		blit from sHWsurface to FB every frame
+//
+static void* GFX_FlipThreadSingleHW(void* param) {
+	MI_GFX_Surface_t Src = sHW;
+	MI_GFX_Rect_t SrcRect = sHWRect;
+	MI_GFX_Surface_t Dst = stDst;
+	MI_GFX_Rect_t DstRect = stDstRect;
+	MI_U16 Fence;
+	uint32_t sHWsize4K = ALIGN4K(sHWsurface->pitch * sHWsurface->h);
+	uint32_t target_offset;
+
+	while(1) {
+		MI_SYS_FlushInvCache(sHWsurface->pixels, sHWsize4K);
+		target_offset = vinfo.yoffset ^ res_y;
+		Dst.phyAddr = finfo.smem_start + (res_x*target_offset*4);
+		MI_GFX_BitBlit(&Src, &SrcRect, &Dst, &DstRect, &stOpt, &Fence);
+#ifdef	HAVE_OVERLAY
+		if (ovrsurface) {
+			MI_GFX_WaitAllDone(FALSE, Fence);
+			OvrDst.phyAddr = finfo.smem_start + (res_x*target_offset*4);
+			MI_GFX_BitBlit(&OvrSrc, &OvrSrcRect, &OvrDst, &OvrDstRect, &OvrOpt, &Fence);
+		}
+#endif
+		usleep(0x2000);	// wait about 10ms
+		vinfo.yoffset = target_offset;
+		if (flip_callback) flip_callback(userdata_callback);
+		ioctl(fd_fb, FBIOPAN_DISPLAY, &vinfo);
+	}
+	return 0;
+}
+
+//
+//	Get GFX_ColorFmt from SDL_Surface
+//
+static inline MI_GFX_ColorFmt_e	GFX_ColorFmt(SDL_Surface *surface) {
+	if (surface) {
+		if (surface->format->BytesPerPixel == 2) {
+			if (surface->format->Amask == 0x0000) return E_MI_GFX_FMT_RGB565;
+			if (surface->format->Amask == 0x8000) return E_MI_GFX_FMT_ARGB1555;
+			if (surface->format->Amask == 0xF000) return E_MI_GFX_FMT_ARGB4444;
+			if (surface->format->Amask == 0x0001) return E_MI_GFX_FMT_RGBA5551;
+			if (surface->format->Amask == 0x000F) return E_MI_GFX_FMT_RGBA4444;
+			return E_MI_GFX_FMT_RGB565;
+		}
+		if (surface->format->Bmask == 0x000000FF) return E_MI_GFX_FMT_ARGB8888;
+		if (surface->format->Rmask == 0x000000FF) return E_MI_GFX_FMT_ABGR8888;
+	}
+	return E_MI_GFX_FMT_ARGB8888;
+}
+
+//
+//	Get SYS_PixelFormat from SDL_Surface
+//
+static inline MI_SYS_PixelFormat_e	SYS_PixelFormat(SDL_Surface *surface) {
+	if (surface) {
+		if (surface->format->BytesPerPixel == 2) {
+			if (surface->format->Amask == 0x0000) return E_MI_SYS_PIXEL_FRAME_RGB565;
+			if (surface->format->Amask == 0x8000) return E_MI_SYS_PIXEL_FRAME_ARGB1555;
+			if (surface->format->Amask == 0xF000) return E_MI_SYS_PIXEL_FRAME_ARGB4444;
+			return E_MI_SYS_PIXEL_FRAME_RGB565;
+		}
+		if (surface->format->Bmask == 0x000000FF) return E_MI_SYS_PIXEL_FRAME_ARGB8888;
+		if (surface->format->Rmask == 0x000000FF) return E_MI_SYS_PIXEL_FRAME_ABGR8888;
+		if (surface->format->Amask == 0x000000FF) return E_MI_SYS_PIXEL_FRAME_BGRA8888;
+	}
+	return E_MI_SYS_PIXEL_FRAME_ARGB8888;
+}
+
+//
+//	Flush write cache of needed segments
+//		x and w are not considered since 4K units
+//
+static inline void FlushCacheNeeded(void* pixels, uint32_t pitch, uint32_t y, uint32_t h) {
+	uintptr_t pixptr = (uintptr_t)pixels;
+	uintptr_t startaddress = (pixptr + pitch*y)&(~4095);
+	uint32_t size = ALIGN4K(pixptr + pitch*(y+h)) - startaddress;
+	if (size) MI_SYS_FlushInvCache((void*)startaddress, size);
+}
+
+//
+//	GFX Flip / in place of SDL_Flip
+//		HW Blit : surface -> FB(backbuffer) with Rotate180/bppConvert/Scaling
+//			and Request Flip
+//		*Note* blit from entire surface(or clip_rect if specified) to entire framebuffer(or sHWsurface)
+//
+void	GFX_FlipExec(SDL_Surface *surface, uint32_t flags) {
+	uint32_t	target_offset, surfacesize;
+
+	if ((fd_fb)&&(surface)&&(surface->pixelsPa)) {
+		surfacesize = surface->pitch * surface->h;
+		stSrc.eColorFmt = GFX_ColorFmt(surface);
+		stSrc.u32Width = surface->w;
+		stSrc.u32Height = surface->h;
+		stSrc.u32Stride = surface->pitch;
+		if (surface->clip_rect.w|surface->clip_rect.h) {
+			// when clip_rect is specified
+			stSrcRect.s32Xpos = surface->clip_rect.x;
+			stSrcRect.s32Ypos = surface->clip_rect.y;
+			stSrcRect.u32Width = surface->clip_rect.w;
+			stSrcRect.u32Height = surface->clip_rect.h;
+		} else {// entire screen
+			stSrcRect.s32Xpos = 0;
+			stSrcRect.s32Ypos = 0;
+			stSrcRect.u32Width = stSrc.u32Width;
+			stSrcRect.u32Height = stSrc.u32Height;
+		}
+
+		if (sHWsurface) {
+			if (surface != sHWsurface) {
+				// blit to sHWsurface when direct draw mode
+				MI_U16 Fence;
+				stSrc.phyAddr = surface->pixelsPa;
+				FlushCacheNeeded(surface->pixels, surface->pitch, stSrcRect.s32Ypos, stSrcRect.u32Height);
+				MI_GFX_BitBlit(&stSrc, &stSrcRect, &sHW, &sHWRect, &sHWOpt, &Fence);
+			}
+			return;
+		}
+
+		if (flags & GFX_FLIPWAIT) {
+			// wait for recent flip is done
+			if (flipFence) MI_GFX_WaitAllDone(FALSE, flipFence);
+			// prepare intermediate buffer if needed
+			if (shadowsize < surfacesize) {
+				if (shadowPa) MI_SYS_MMA_Free(shadowPa);
+				if (MI_SYS_MMA_Alloc(NULL, ALIGN4K(surfacesize), &shadowPa)) {
+					shadowPa = shadowsize = 0; goto NOWAIT;
+				}
+				shadowsize = surfacesize;
+			}
+			// copy surface to intermediate buffer
+			uint32_t ofs = surface->pitch * stSrcRect.s32Ypos;
+			uint32_t size = surface->pitch * stSrcRect.u32Height;
+			MI_SYS_FlushInvCache((uint8_t*)surface->pixels + ofs, ALIGN4K(size));
+			MI_SYS_MemcpyPa(shadowPa + ofs, surface->pixelsPa + ofs, size);
+			// blit from intermediate buffer
+			stSrc.phyAddr = shadowPa;
+		} else {
+		NOWAIT:	FlushCacheNeeded(surface->pixels, surface->pitch, stSrcRect.s32Ypos, stSrcRect.u32Height);
+			stSrc.phyAddr = surface->pixelsPa;
+		}
+
+		pthread_mutex_lock(&flip_mx);
+		if (flags & GFX_BLOCKING) {
+			while (now_flipping == 2) pthread_cond_wait(&flip_start, &flip_mx);
+		}
+		target_offset = vinfo.yoffset + res_y;
+		if ( target_offset == res_y * 3 ) target_offset = 0;
+		stDst.phyAddr = finfo.smem_start + (res_x*target_offset*4);
+		MI_GFX_BitBlit(&stSrc, &stSrcRect, &stDst, &stDstRect, &stOpt, &flipFence);
+
+		// Request Flip
+		if (!now_flipping) {
+			now_flipping = 1;
+			pthread_cond_signal(&flip_req);
+			pthread_cond_wait(&flip_start, &flip_mx);
+		} else {
+			now_flipping = 2;
+		}
+		pthread_mutex_unlock(&flip_mx);
+	}
+}
+void	GFX_Flip(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags); }
+void	GFX_FlipNoWait(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags & ~GFX_FLIPWAIT); }
+void	GFX_FlipWait(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags | GFX_FLIPWAIT); }
+void	GFX_FlipForce(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags | GFX_BLOCKING); }
+
+//
+//	Get/Set Flipflags
+//		GFX_BLOCKING/GFX_FLIPWAIT flags used for GFX_Flip/UpdateRect
+//
+uint32_t	GFX_GetFlipFlags(void) { return flipFlags; }
+void		GFX_SetFlipFlags(uint32_t flags) { flipFlags = flags; }
+
+//
+//	Get/Set Flip callback, for use direct draw to framebuffer
+//		(Battery icon, RetroArch OSD text, etc)
+//		*Note* framebuffer is rotated 180 degrees
+//
+void*	GFX_GetFlipCallback(void) { return (void*)flip_callback; }
+void	GFX_SetFlipCallback(void (*callback)(void*), void *userdata) {
+	userdata_callback = userdata; flip_callback = callback;
+}
+
+#ifdef	FREEMMA
+//
+//	Free all allocated MMAs (except "daemon")
+//
+void	freemma(void) {
+	FILE		*fp;
+	const char	*heapinfoname = "/proc/mi_modules/mi_sys_mma/mma_heap_name0";
+	char		str[256];
+	uint32_t	offset, length, usedflag;
+	uint32_t	baseaddr = finfo.smem_start - 0x021000;	// default baseaddr (tmp)
+
+	// open heap information file
+	fp = fopen(heapinfoname, "r");
+	if (fp) {
+		// skip reading until chunk information
+		do { if (fscanf(fp, "%255s", str) == EOF) { fclose(fp); return; } } while (strcmp(str,"sys-logConfig"));
+		// get MMA each chunk information and release
+		while(fscanf(fp, "%x %x %x %255s", &offset, &length, &usedflag, str) != EOF) {
+			if (!usedflag) continue; // NA
+			if (!strcmp(str,"fb_device")) { // FB .. fix baseaddr
+				baseaddr = finfo.smem_start - offset; continue;
+			}
+			if (!strcmp(str,"ao-Dev0-tmp")) continue; // ao .. Audio buffer, skip
+			// For daemon program authors, MMA allocated as "daemon" will not be released
+			if (strncmp(str,"daemon",6)) { // others except "daemon" .. release
+				if (!MI_SYS_MMA_Free(baseaddr + offset)) {
+					fprintf(stderr, "MMA_Released %s offset : %08X length : %08X\n", str, offset, length);
+				}
+			}
+		}
+		fclose(fp);
+	}
+}
+#endif
+
+//
+//	Create GFX Surface / in place of SDL_CreateRGBSurface
+//		supports 16/32bpp only / flags has no meaning, fixed to SWSURFACE
+//		Additional return value : surface->unused1 = Physical address of surface
+//
+SDL_Surface*	GFX_CreateRGBSurface(uint32_t flags, int width, int height, int depth, uint32_t Rmask, uint32_t Gmask, uint32_t Bmask, uint32_t Amask) {
+	SDL_Surface*	surface;
+	MI_PHY		phyAddr;
+	void*		virAddr;
+	if (!width) width = res_x;
+	if (!height) height = res_y;
+	if (depth != 16) depth = 32;
+	int		pitch = width * (uint32_t)(depth/8);
+	uint32_t	size = pitch * height;
+
+	if (MI_SYS_MMA_Alloc(NULL, ALIGN4K(size), &phyAddr)) {
+		// No MMA left .. create normal SDL surface
+		return SDL_CreateRGBSurface(flags,width,height,depth,Rmask,Gmask,Bmask,Amask);
+	}
+#ifndef	FREEMMA
+	uint32_t i;
+	for (i=0; i<MMADBMAX; i++) {
+		if (!mma_db[i]) {
+			mma_db[i] = phyAddr; break;
+		}
+	} if (i==MMADBMAX) { MI_SYS_MMA_Free(phyAddr); return NULL; }
+#endif
+	MI_SYS_Mmap(phyAddr, ALIGN4K(size), &virAddr, TRUE);	// write cache ON needs Flush when r/w Pa directly
+
+	surface = SDL_CreateRGBSurfaceFrom(virAddr,width,height,depth,pitch,Rmask,Gmask,Bmask,Amask);
+	if (surface) {
+		surface->pixelsPa = phyAddr;
+		memset(surface->pixels, 0, size);
+	}
+	return surface;
+}
+
+//
+//	Free GFX Surface / in place of SDL_FreeSurface
+//
+void	GFX_FreeSurface(SDL_Surface *surface) {
+	if (surface) {
+		MI_PHY		phyAddr = surface->pixelsPa;
+		void*		virAddr = surface->pixels;
+		uint32_t	size = surface->pitch * surface->h;
+
+		// stop flip thread when sHWsurface is freed
+		if (surface == sHWsurface) {
+			pthread_cancel(flip_pt);
+			pthread_join(flip_pt, NULL);
+			sHWsurface = NULL;
+		}
+
+		SDL_FreeSurface(surface);
+		if (phyAddr) {
+			MI_SYS_Munmap(virAddr, ALIGN4K(size));
+			MI_SYS_MMA_Free(phyAddr);
+#ifndef	FREEMMA
+			for (uint32_t i=0; i<MMADBMAX; i++) {
+				if (mma_db[i] == phyAddr) {
+					mma_db[i] = 0; break;
+				}
+			}
+#endif
+		}
+	}
+}
+
+//
+//	Clear entire FrameBuffer
+//
+void	GFX_ClearFrameBuffer(void) { memset(fb_addr, 0, finfo.smem_len); }
+
+//
+//	GFX Init / Prepare for HW Blit to FB, call after SDL_Init
+//
+void	GFX_Init(void) {
+	if (!fd_fb) {
+		MI_SYS_Init();
+		MI_GFX_Open();
+		fd_fb = open("/dev/fb0", O_RDWR);
+
+
+		// screen init
+		SDL_SetVideoMode(res_x, res_y, 32, SDL_SWSURFACE);
+		ioctl(fd_fb, FBIOGET_VSCREENINFO, &vinfo);
+		vinfo.yres_virtual = res_y * 3; vinfo.yoffset = 0;
+		/* vinfo.xres = vinfo.xres_virtual = 640; vinfo.yres = 480;
+		vinfo.xoffset = vinfo.yoffset = vinfo.red.msb_right = vinfo.green.msb_right = 
+		vinfo.blue.msb_right = vinfo.transp.msb_right = vinfo.blue.offset = 0;
+		vinfo.red.length = vinfo.green.length = vinfo.blue.length = vinfo.transp.length = vinfo.green.offset = 8;
+		vinfo.red.offset = 16; vinfo.transp.offset = 24; vinfo.bits_per_pixel = 32; */
+		ioctl(fd_fb, FBIOPUT_VSCREENINFO, &vinfo);
+
+		res_x = vinfo.xres;
+		res_y = vinfo.yres;
+		// get physical address of FB
+		ioctl(fd_fb, FBIOGET_FSCREENINFO, &finfo);
+
+		// map fb memory
+		fb_addr = mmap(0, finfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, 0);
+
+		// clear entire FB
+		GFX_ClearFrameBuffer();
+#ifdef	FREEMMA
+		freemma();
+#else
+		memset(mma_db, 0, sizeof(mma_db));
+#endif
+		// prepare for Flip
+		stDst.phyAddr = finfo.smem_start;
+		stDst.eColorFmt = E_MI_GFX_FMT_ARGB8888;
+		stDst.u32Width = res_x;
+		stDst.u32Height = res_y;
+		stDst.u32Stride = res_x*4;
+		stDstRect.s32Xpos = 0;
+		stDstRect.s32Ypos = 0;
+		stDstRect.u32Width = res_x;
+		stDstRect.u32Height = res_y;
+#ifdef	HAVE_OVERLAY
+		// prepare for OverlaySurface
+		OvrSrcRect.s32Xpos = 0;
+		OvrSrcRect.s32Ypos = 0;
+		OvrDst = stDst;
+		OvrDstRect = stDstRect;
+#endif
+		memset(&stOpt, 0, sizeof(stOpt));
+		stOpt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
+		stOpt.eRotate = E_MI_GFX_ROTATE_180;
+
+		flip_mx = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
+		flip_req = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+		flip_start = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+		now_flipping = shadowPa = shadowsize = flipFence = 0;
+		sHWsurface = videosurface = NULL;
+		flipFlags = DEFAULTFLIPFLAGS;
+		pthread_create(&flip_pt, NULL, GFX_FlipThread, NULL);
+	}
+}
+
+//
+//	GFX Quit / call before SDL_Quit
+//
+void	GFX_Quit(void) {
+	if (fd_fb) {
+		pthread_cancel(flip_pt);
+		pthread_join(flip_pt, NULL);
+
+		MI_GFX_WaitAllDone(TRUE, 0);
+		if (sHWsurface) { SDL_Surface* sHWpush = sHWsurface; sHWsurface = NULL; GFX_FreeSurface(sHWpush); }
+		if (videosurface) { GFX_FreeSurface(videosurface); videosurface = NULL; }
+		if (shadowPa) { MI_SYS_MMA_Free(shadowPa); shadowPa = 0; }
+#ifdef	FREEMMA
+		freemma();
+#else
+		for (uint32_t i=0; i<MMADBMAX; i++) {
+			if (mma_db[i]) {
+				if (!MI_SYS_MMA_Free(mma_db[i])) {
+					fprintf(stderr, "MMA_Released offset : %08X\n", mma_db[i]);
+					mma_db[i] = 0;
+				}
+			}
+		}
+#endif
+#ifdef CLEARFBATQUIT
+		// clear entire FB
+		GFX_ClearFrameBuffer();
+#else
+		// copy current frame to initial frame
+		ioctl(fd_fb, FBIOGET_VSCREENINFO, &vinfo);
+		if (vinfo.yoffset) MI_SYS_MemcpyPa(finfo.smem_start, finfo.smem_start + (res_x*vinfo.yoffset*4), res_x*res_y*4);
+#endif
+		// reset yoffset
+		vinfo.yoffset = 0;
+		ioctl(fd_fb, FBIOPUT_VSCREENINFO, &vinfo);
+
+		// unmap fb memory
+		munmap(fb_addr, finfo.smem_len);
+
+		close(fd_fb);
+		fd_fb = 0;
+
+		MI_GFX_Close();
+		MI_SYS_Exit();
+	}
+}
+
+//
+//	SetVideomode / in place of SDL_SetVideoMode
+//		if flags == SDL_HWSURFACE & non SDL_DOUBLEBUF, change to direct draw mode
+//		 otherwise, same as GFX_CreateRGBSurface
+//
+SDL_Surface*	GFX_SetVideoMode(int width, int height, int bpp, uint32_t flags) {
+	if (!fd_fb) GFX_Init();
+	if (!width) width = res_x;
+	if (!height) height = res_y;
+	if (bpp != 16) bpp = 32;
+
+	// reinit Flip thread
+	pthread_cancel(flip_pt);
+	pthread_join(flip_pt, NULL);
+	MI_GFX_WaitAllDone(TRUE, 0);
+	if (sHWsurface) { SDL_Surface* sHWpush = sHWsurface; sHWsurface = NULL; GFX_FreeSurface(sHWpush); }
+	if (videosurface) { GFX_FreeSurface(videosurface); videosurface = NULL; }
+	if (shadowPa) { MI_SYS_MMA_Free(shadowPa); shadowPa = shadowsize = 0; }
+	flip_mx = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
+	flip_req = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+	flip_start = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+	now_flipping = flipFence = vinfo.yoffset = 0;
+	GFX_ClearFrameBuffer();
+	ioctl(fd_fb, FBIOPAN_DISPLAY, &vinfo);
+
+	if ((flags&SDL_HWSURFACE)&&(!(flags&SDL_DOUBLEBUF))) {
+		// single HW surface, direct draw mode
+		sHWsurface = GFX_CreateRGBSurface(flags, width, height, bpp, 0,0,0,0);
+		if (sHWsurface) {
+			sHW.phyAddr = sHWsurface->pixelsPa;
+			sHW.u32Width = sHWsurface->w;
+			sHW.u32Height = sHWsurface->h;
+			sHW.u32Stride = sHWsurface->pitch;
+			sHW.eColorFmt = GFX_ColorFmt(sHWsurface);
+			sHWRect.s32Xpos = 0;
+			sHWRect.s32Ypos = 0;
+			sHWRect.u32Width = sHW.u32Width;
+			sHWRect.u32Height = sHW.u32Height;
+			memset(&sHWOpt, 0, sizeof(sHWOpt));
+			sHWOpt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
+			pthread_create(&flip_pt, NULL, GFX_FlipThreadSingleHW, NULL);
+		} else pthread_create(&flip_pt, NULL, GFX_FlipThread, NULL);
+		return sHWsurface;
+	} else {
+		// others
+		pthread_create(&flip_pt, NULL, GFX_FlipThread, NULL);
+		videosurface = GFX_CreateRGBSurface(flags, width, height, bpp, 0,0,0,0);
+		return videosurface;
+	}
+}
+
+//
+//	Clear GFX/SDL Surface (entire)
+//
+void	GFX_ClearSurface(SDL_Surface *surface) {
+	if (surface) {
+		uint32_t size = surface->pitch * surface->h;
+		memset(surface->pixels, 0, size);
+	}
+}
+
+//
+//	Copy GFX/SDL Surface (entire)
+//		src/dst surfaces must be the same size
+//
+void	GFX_CopySurface(SDL_Surface *src, SDL_Surface *dst) {
+	if ((src)&&(dst)) {
+		uint32_t size = src->pitch * src->h;
+		if (size == (uint32_t)(dst->pitch * dst->h)) {
+			if ((src->pixelsPa)&&(dst->pixelsPa)) {
+				MI_SYS_FlushInvCache(src->pixels, ALIGN4K(size));
+				MI_SYS_FlushInvCache(dst->pixels, ALIGN4K(size));
+				MI_SYS_MemcpyPa(dst->pixelsPa, src->pixelsPa, size);
+			} else {
+				memcpy(dst->pixels, src->pixels, size);
+			}
+		}
+	}
+}
+
+//
+//	Rotate 640x480x32bpp surface NEON / for duplicate FB
+//
+void	RotateSurfaceNEON(void* src) {
+	asm volatile (
+	"	add r1,%0,#(640*240*4)	;"
+	"	mov r2,r1		;"
+	"	mov r3,r1		;"
+	"1:	vldmia r1,{q0-q7}	;"
+	"	vrev64.32 d31,d0	;"
+	"	vrev64.32 d30,d1	;"
+	"	vrev64.32 d29,d2	;"
+	"	vrev64.32 d28,d3	;"
+	"	vrev64.32 d27,d4	;"
+	"	vrev64.32 d26,d5	;"
+	"	vrev64.32 d25,d6	;"
+	"	vrev64.32 d24,d7	;"
+	"	vrev64.32 d23,d8	;"
+	"	vrev64.32 d22,d9	;"
+	"	vrev64.32 d21,d10	;"
+	"	vrev64.32 d20,d11	;"
+	"	vrev64.32 d19,d12	;"
+	"	vrev64.32 d18,d13	;"
+	"	vrev64.32 d17,d14	;"
+	"	vrev64.32 d16,d15	;"
+	"	vldmdb r3!,{q0-q7}	;"
+	"	vstmdb r2!,{q8-q15}	;"
+	"	vrev64.32 d31,d0	;"
+	"	vrev64.32 d30,d1	;"
+	"	vrev64.32 d29,d2	;"
+	"	vrev64.32 d28,d3	;"
+	"	vrev64.32 d27,d4	;"
+	"	vrev64.32 d26,d5	;"
+	"	vrev64.32 d25,d6	;"
+	"	vrev64.32 d24,d7	;"
+	"	vrev64.32 d23,d8	;"
+	"	vrev64.32 d22,d9	;"
+	"	vrev64.32 d21,d10	;"
+	"	vrev64.32 d20,d11	;"
+	"	vrev64.32 d19,d12	;"
+	"	vrev64.32 d18,d13	;"
+	"	vrev64.32 d17,d14	;"
+	"	vrev64.32 d16,d15	;"
+	"	vstmia r1!,{q8-q15}	;"
+	"	cmp %0,r2		;"
+	"	bne 1b			"
+	:: "r"(src)
+	: "r1","r2","r3","q0","q1","q2","q3","q4","q5","q6","q7",
+	    "q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void RotateSurface(SDL_Surface *surface)
+{
+    if (!surface || surface->format->BytesPerPixel != 4)
+        return;
+
+    int width = surface->w;
+    int height = surface->h;
+    uint32_t *pixels = (uint32_t *)surface->pixels;
+
+    for (int y = 0; y < height / 2; y++) {
+        for (int x = 0; x < width; x++) {
+            uint32_t topPixel = pixels[y * width + x];
+            uint32_t bottomPixel = pixels[(height - y - 1) * width + (width - x - 1)];
+            pixels[y * width + x] = bottomPixel;
+            pixels[(height - y - 1) * width + (width - x - 1)] = topPixel;
+        }
+    }
+}
+
+//
+//	Duplicate GFX Surface from SDL_Surface or FB
+//		if src is NULL, duplicate from FB currently displayed
+//
+SDL_Surface*	GFX_DuplicateSurface(SDL_Surface *src) {
+	SDL_Surface	*dst;
+	if (src) {
+		dst = GFX_CreateRGBSurface(0, src->w, src->h, src->format->BitsPerPixel,
+			src->format->Rmask, src->format->Gmask, src->format->Bmask, src->format->Amask);
+		if (dst) GFX_CopySurface(src, dst);
+	} else {
+		dst = GFX_CreateRGBSurface(0, res_x, res_y, 32, 0,0,0,0);
+		if (dst) {
+			MI_GFX_WaitAllDone(TRUE, 0);
+			MI_SYS_MemcpyPa(dst->pixelsPa, finfo.smem_start + res_x*vinfo.yoffset*4, res_x*res_y*4);
+			if(res_x == 640 && res_y == 480)
+				RotateSurfaceNEON(dst);
+			else
+				RotateSurface(dst);
+		}
+	}
+	return dst;
+}
+
+//
+//	GFX UpdateRect / in place of SDL_UpdateRect
+//		Flip after setting the update area
+//		*Note* blit from entire screen(or clip_rect if specified) to framebuffer(or sHWsurface) rect
+//
+void	GFX_UpdateRectExec(SDL_Surface *screen, int x, int y, int w, int h, uint32_t flags) {
+	if ((fd_fb)&&(screen)&&(screen->pixelsPa)) {
+		if (x|y|w|h) {
+			if (!sHWsurface) {
+				MI_GFX_Rect_t DstRectPush = stDstRect;
+				// for rotate180
+				stDstRect.s32Xpos = res_x-(x+w);
+				stDstRect.s32Ypos = res_y-(y+h);
+				// for RetroArch rotate function
+				stDstRect.u32Width = (stOpt.eRotate&1) ? h : w;
+				stDstRect.u32Height = (stOpt.eRotate&1) ? w : h;
+				GFX_FlipExec(screen, flags);
+				stDstRect = DstRectPush;
+			} else if (screen != sHWsurface) {
+				// direct draw mode, dest = sHWsurface
+				MI_GFX_Rect_t DstRectPush = sHWRect;
+				sHWRect.s32Xpos = x;
+				sHWRect.s32Ypos = y;
+				sHWRect.u32Width = w;
+				sHWRect.u32Height = h;
+				GFX_FlipExec(screen, flags);
+				sHWRect = DstRectPush;
+			}
+		} else {
+			GFX_FlipExec(screen, flags);
+		}
+	}
+}
+void	GFX_UpdateRect(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags); }
+void	GFX_UpdateRectNoWait(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags & ~GFX_FLIPWAIT); }
+void	GFX_UpdateRectWait(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags | GFX_FLIPWAIT); }
+void	GFX_UpdateRectForce(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags | GFX_BLOCKING); }
+
+//
+//	Check Rect Overflow for FillRect/BlitSurfaceSYS
+//
+SDL_Rect* CheckRect(SDL_Surface* dst, SDL_Rect* dstrect) {
+	if ((!dst)||(!dstrect)) return NULL;
+
+	int w = dstrect->w; int h = dstrect->h;
+	if (dst->clip_rect.w|dst->clip_rect.h) {
+		if (dst->clip_rect.x > dstrect->x) {
+			w -= (dst->clip_rect.x - dstrect->x); dstrect->x = dst->clip_rect.x;
+		}
+		if ((dst->clip_rect.x + dst->clip_rect.w) < (dstrect->x + w)) {
+			w = dst->clip_rect.w - (dstrect->x - dst->clip_rect.x);
+		}
+		if (dst->clip_rect.y > dstrect->y) {
+			h -= (dst->clip_rect.y - dstrect->y); dstrect->y = dst->clip_rect.y;
+		}
+		if ((dst->clip_rect.y + dst->clip_rect.h) < (dstrect->y + h)) {
+			h = dst->clip_rect.h - (dstrect->y - dst->clip_rect.y);
+		}
+	}
+	if (dstrect->x < 0) { w += dstrect->x; dstrect->x = 0; }
+	if (dstrect->y < 0) { h += dstrect->y; dstrect->y = 0; }
+	if ((dstrect->x + w) > dst->w) { w = dst->w - dstrect->x; }
+	if ((dstrect->y + h) > dst->h) { h = dst->h - dstrect->y; }
+	if ((w <= 0)||(h <= 0)||(dstrect->x >= dst->w)||(dstrect->y >= dst->h)) return NULL;
+	dstrect->w = w; dstrect->h = h;
+	return dstrect;
+}
+
+//
+//	GFX FillRect (MI_SYS ver) / in place of SDL_FillRect
+//		*Note* color : in case of RGB565 : 2 pixel color values used alternately
+//
+void	GFX_FillRectSYS(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color) {
+	if ((dst)&&(dst->pixelsPa)) {
+		SDL_Rect dstrect_tmp;
+		if (!dstrect) {
+			dstrect_tmp.x = 0;
+			dstrect_tmp.y = 0;
+			dstrect_tmp.w = dst->w;
+			dstrect_tmp.h = dst->h;
+		} else 	memcpy(&dstrect_tmp, dstrect, sizeof(dstrect_tmp));
+		if (!(CheckRect(dst, &dstrect_tmp))) return;
+
+		MI_SYS_FrameData_t Buf;
+		MI_SYS_WindowRect_t Rect;
+
+		Buf.phyAddr[0] = dst->pixelsPa;
+		Buf.u16Width = dst->w;
+		Buf.u16Height = dst->h;
+		Buf.u32Stride[0] = dst->pitch;
+		Buf.ePixelFormat = SYS_PixelFormat(dst);
+		Rect.u16X = dstrect_tmp.x;
+		Rect.u16Y = dstrect_tmp.y;
+		Rect.u16Width = dstrect_tmp.w;
+		Rect.u16Height = dstrect_tmp.h;
+
+		FlushCacheNeeded(dst->pixels, dst->pitch, Rect.u16Y, Rect.u16Height);
+		MI_SYS_BufFillPa(&Buf, color, &Rect);
+	} else 	SDL_FillRect(dst, dstrect, color);
+}
+
+//
+//	GFX FillRect (MI_GFX ver) / in place of SDL_FillRect
+//		*Note* color : in case of RGB565 : ARGB8888 color value
+//		nowait : 0 = wait until done / 1 = no wait
+//
+void	GFX_FillRectExec(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color, uint32_t nowait) {
+	if ((dst)&&(dst->pixelsPa)) {
+		SDL_Rect dstrect_tmp;
+		if (!dstrect) {
+			dstrect_tmp.x = 0;
+			dstrect_tmp.y = 0;
+			dstrect_tmp.w = dst->w;
+			dstrect_tmp.h = dst->h;
+		} else 	memcpy(&dstrect_tmp, dstrect, sizeof(dstrect_tmp));
+		if (!(CheckRect(dst, &dstrect_tmp))) return;
+
+		MI_GFX_Surface_t Dst;
+		MI_GFX_Rect_t DstRect;
+		MI_U16 Fence;
+
+		Dst.phyAddr = dst->pixelsPa;
+		Dst.eColorFmt = GFX_ColorFmt(dst);
+		Dst.u32Width = dst->w;
+		Dst.u32Height = dst->h;
+		Dst.u32Stride = dst->pitch;
+		DstRect.s32Xpos = dstrect_tmp.x;
+		DstRect.s32Ypos = dstrect_tmp.y;
+		DstRect.u32Width = dstrect_tmp.w;
+		DstRect.u32Height = dstrect_tmp.h;
+
+		FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.s32Ypos, DstRect.u32Height);
+		MI_GFX_QuickFill(&Dst, &DstRect, color, &Fence);
+		if (!nowait) MI_GFX_WaitAllDone(FALSE, Fence);
+	} else SDL_FillRect(dst, dstrect, color);
+}
+void	GFX_FillRect(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color) {
+	GFX_FillRectExec(dst, dstrect, color, 0);
+}
+void	GFX_FillRectNoWait(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color) {
+	GFX_FillRectExec(dst, dstrect, color, 1);
+}
+
+//
+//	GFX_WaitAllDone / wait all done for No Wait functions
+//
+void	GFX_WaitAllDone(void) {
+	MI_GFX_WaitAllDone(TRUE, 0);
+}
+
+//
+//	GFX BlitSurface (MI_SYS ver) / in place of SDL_BlitSurface
+//		*Note* Just a copy (no convert scale/bpp)
+//
+void GFX_BlitSurfaceSYS(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
+	if ((src)&&(dst)&&(src->pixelsPa)&&(dst->pixelsPa)) {
+		MI_SYS_FrameData_t SrcBuf;
+		MI_SYS_FrameData_t DstBuf;
+		MI_SYS_WindowRect_t SrcRect;
+		MI_SYS_WindowRect_t DstRect;
+
+		SDL_Rect srcrect_tmp, dstrect_tmp;
+		if (!srcrect) {
+			srcrect_tmp.x = 0; srcrect_tmp.y = 0;
+			srcrect_tmp.w = src->w; srcrect_tmp.h = src->h;
+		} else 	memcpy(&srcrect_tmp, srcrect, sizeof(srcrect_tmp));
+		if (!dstrect) {
+			dstrect_tmp.x = 0; dstrect_tmp.y = 0;
+			dstrect_tmp.w = dst->w; dstrect_tmp.h = dst->h;
+		} else {
+			if (dstrect->w|dstrect->h) memcpy(&dstrect_tmp, dstrect, sizeof(dstrect_tmp));
+			else {	dstrect_tmp.x = dstrect->x; dstrect_tmp.y = dstrect->y;
+				dstrect_tmp.w = src->w - dstrect->x; dstrect_tmp.h = src->h - dstrect->y;
+			}
+		}
+		// adjust rects from dst surface size and clip_rect
+		if (!(CheckRect(dst, &srcrect_tmp))) return;
+		if (!(CheckRect(dst, &dstrect_tmp))) return;
+
+		memset(&SrcBuf, 0, sizeof(SrcBuf));
+		SrcBuf.phyAddr[0] = src->pixelsPa;
+		SrcBuf.u16Width = src->w;
+		SrcBuf.u16Height = src->h;
+		SrcBuf.u32Stride[0] = src->pitch;
+		SrcBuf.ePixelFormat = SYS_PixelFormat(src);
+		SrcRect.u16X = srcrect_tmp.x;
+		SrcRect.u16Y = srcrect_tmp.y;
+		SrcRect.u16Width = srcrect_tmp.w;
+		SrcRect.u16Height = srcrect_tmp.h;
+
+		memset(&DstBuf, 0, sizeof(DstBuf));
+		DstBuf.phyAddr[0] = dst->pixelsPa;
+		DstBuf.u16Width = dst->w;
+		// **HACK** rect.h is not working properly for some reason, so adjust dst height
+		DstBuf.u16Height = dstrect_tmp.y + dstrect_tmp.h; // dst->h;
+		DstBuf.u32Stride[0] = dst->pitch;
+		DstBuf.ePixelFormat = SYS_PixelFormat(dst);
+		DstRect.u16X = dstrect_tmp.x;
+		DstRect.u16Y = dstrect_tmp.y;
+		DstRect.u16Width = dstrect_tmp.w;
+		DstRect.u16Height = dstrect_tmp.h;
+
+		FlushCacheNeeded(src->pixels, src->pitch, SrcRect.u16Y, SrcRect.u16Height);
+		FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.u16Y, DstRect.u16Height);
+		MI_SYS_BufBlitPa(&DstBuf, &DstRect, &SrcBuf, &SrcRect);
+	} else SDL_BlitSurface(src, srcrect, dst, dstrect);
+}
+
+//
+//	GFX BlitSurface (MI_GFX ver) / in place of SDL_BlitSurface
+//		with scale/bpp convert and rotate/mirror
+//		rotate : 1 = 90 / 2 = 180 / 3 = 270
+//		mirror : 1 = Horizontal / 2 = Vertical / 3 = Both
+//		nowait : 0 = wait until done / 1 = no wait
+//
+static inline void GFX_BlitSurfaceExec(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect,
+			 uint32_t rotate, uint32_t mirror, uint32_t nowait) {
+	if ((src)&&(dst)&&(src->pixelsPa)&&(dst->pixelsPa)) {
+		MI_GFX_Surface_t Src;
+		MI_GFX_Surface_t Dst;
+		MI_GFX_Rect_t SrcRect;
+		MI_GFX_Rect_t DstRect;
+		MI_GFX_Opt_t Opt;
+		MI_U16 Fence;
+
+		Src.phyAddr = src->pixelsPa;
+		Src.u32Width = src->w;
+		Src.u32Height = src->h;
+		Src.u32Stride = src->pitch;
+		Src.eColorFmt = GFX_ColorFmt(src);
+		if (srcrect) {
+			SrcRect.s32Xpos = srcrect->x;
+			SrcRect.s32Ypos = srcrect->y;
+			SrcRect.u32Width = srcrect->w;
+			SrcRect.u32Height = srcrect->h;
+		} else {
+			SrcRect.s32Xpos = 0;
+			SrcRect.s32Ypos = 0;
+			SrcRect.u32Width = Src.u32Width;
+			SrcRect.u32Height = Src.u32Height;
+		}
+
+		Dst.phyAddr = dst->pixelsPa;
+		Dst.u32Width = dst->w;
+		Dst.u32Height = dst->h;
+		Dst.u32Stride = dst->pitch;
+		Dst.eColorFmt = GFX_ColorFmt(dst);
+		if (dstrect) {
+			DstRect.s32Xpos = dstrect->x;
+			DstRect.s32Ypos = dstrect->y;
+			if (dstrect->w|dstrect->h) {
+				DstRect.u32Width = dstrect->w;
+				DstRect.u32Height = dstrect->h;
+			} else {
+				DstRect.u32Width = SrcRect.u32Width;
+				DstRect.u32Height = SrcRect.u32Height;
+			}
+		} else {
+			DstRect.s32Xpos = 0;
+			DstRect.s32Ypos = 0;
+			DstRect.u32Width = Dst.u32Width;
+			DstRect.u32Height = Dst.u32Height;
+		}
+
+		memset(&Opt, 0, sizeof(Opt));
+		if (src->flags & SDL_SRCALPHA) {
+			Opt.eDstDfbBldOp = E_MI_GFX_DFB_BLD_INVSRCALPHA;
+			Opt.eDFBBlendFlag = E_MI_GFX_DFB_BLEND_SRC_PREMULTIPLY;
+			if (src->format->alpha == SDL_ALPHA_TRANSPARENT) return;
+			if (src->format->alpha != SDL_ALPHA_OPAQUE) {
+				Opt.u32GlobalSrcConstColor = (src->format->alpha << (src->format->Ashift - src->format->Aloss)) & src->format->Amask;
+				Opt.eDFBBlendFlag = (MI_Gfx_DfbBlendFlags_e)
+						   (E_MI_GFX_DFB_BLEND_SRC_PREMULTIPLY | E_MI_GFX_DFB_BLEND_COLORALPHA | E_MI_GFX_DFB_BLEND_ALPHACHANNEL);
+			}
+		}
+		if (src->flags & SDL_SRCCOLORKEY) {
+			Opt.stSrcColorKeyInfo.bEnColorKey = TRUE;
+			Opt.stSrcColorKeyInfo.eCKeyFmt = Src.eColorFmt;
+			Opt.stSrcColorKeyInfo.eCKeyOp = E_MI_GFX_RGB_OP_EQUAL;
+			Opt.stSrcColorKeyInfo.stCKeyVal.u32ColorStart =
+			Opt.stSrcColorKeyInfo.stCKeyVal.u32ColorEnd = src->format->colorkey;
+		}
+		Opt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
+		Opt.eRotate = (MI_GFX_Rotate_e)rotate;
+		Opt.eMirror = (MI_GFX_Mirror_e)mirror;
+		Opt.stClipRect.s32Xpos = dst->clip_rect.x;
+		Opt.stClipRect.s32Ypos = dst->clip_rect.y;
+		Opt.stClipRect.u32Width = dst->clip_rect.w;
+		Opt.stClipRect.u32Height = dst->clip_rect.h;
+
+		FlushCacheNeeded(src->pixels, src->pitch, SrcRect.s32Ypos, SrcRect.u32Height);
+		if (rotate & 1) FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.s32Ypos, DstRect.u32Width);
+		else FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.s32Ypos, DstRect.u32Height);
+
+		MI_GFX_BitBlit(&Src, &SrcRect, &Dst, &DstRect, &Opt, &Fence);
+		if (!nowait) MI_GFX_WaitAllDone(FALSE, Fence);
+	} else SDL_BlitSurface(src, srcrect, dst, dstrect);
+}
+void GFX_BlitSurface(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, 0, 0);
+}
+void GFX_BlitSurfaceNoWait(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, 0, 1);
+}
+void GFX_BlitSurfaceRotate(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t rotate) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, rotate, 0, 0);
+}
+void GFX_BlitSurfaceRotateNoWait(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t rotate) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, rotate, 0, 1);
+}
+void GFX_BlitSurfaceMirror(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t mirror) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, mirror, 0);
+}
+void GFX_BlitSurfaceMirrorNoWait(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t mirror) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, mirror, 1);
+}
+#ifdef	HAVE_OVERLAY
+//
+//	GFX SetupOverlaySurface / Setup Overlay Surface (mainly for retroarch)
+//
+void GFX_SetupOverlaySurface(SDL_Surface *src) {
+	if ((!src)||(!src->pixelsPa)) { ovrsurface = NULL; return; }
+
+	OvrSrc.phyAddr = src->pixelsPa;
+	OvrSrc.u32Width = src->w;
+	OvrSrc.u32Height = src->h;
+	OvrSrc.u32Stride = src->pitch;
+	OvrSrc.eColorFmt = GFX_ColorFmt(src);
+	OvrSrcRect.u32Width = OvrSrc.u32Width;
+	OvrSrcRect.u32Height = OvrSrc.u32Height;
+
+	memset(&OvrOpt, 0, sizeof(OvrOpt));
+	if (src->flags & SDL_SRCALPHA) {
+		OvrOpt.eDstDfbBldOp = E_MI_GFX_DFB_BLD_INVSRCALPHA;
+		OvrOpt.eDFBBlendFlag = E_MI_GFX_DFB_BLEND_SRC_PREMULTIPLY;
+		if (src->format->alpha == SDL_ALPHA_TRANSPARENT) { ovrsurface = NULL; return; }
+		if (src->format->alpha != SDL_ALPHA_OPAQUE) {
+			OvrOpt.u32GlobalSrcConstColor = (src->format->alpha << (src->format->Ashift - src->format->Aloss)) & src->format->Amask;
+			OvrOpt.eDFBBlendFlag = (MI_Gfx_DfbBlendFlags_e)
+					   (E_MI_GFX_DFB_BLEND_SRC_PREMULTIPLY | E_MI_GFX_DFB_BLEND_COLORALPHA | E_MI_GFX_DFB_BLEND_ALPHACHANNEL);
+		}
+	}
+	if (src->flags & SDL_SRCCOLORKEY) {
+		OvrOpt.stSrcColorKeyInfo.bEnColorKey = TRUE;
+		OvrOpt.stSrcColorKeyInfo.eCKeyFmt = OvrSrc.eColorFmt;
+		OvrOpt.stSrcColorKeyInfo.eCKeyOp = E_MI_GFX_RGB_OP_EQUAL;
+		OvrOpt.stSrcColorKeyInfo.stCKeyVal.u32ColorStart =
+		OvrOpt.stSrcColorKeyInfo.stCKeyVal.u32ColorEnd = src->format->colorkey;
+	}
+	OvrOpt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
+
+	ovrsurface = src;
+	return;
+}
+#endif
diff --git a/gfx/drivers/miyoomini/scaler_neon.c b/gfx/drivers/miyoomini/scaler_neon.c
new file mode 100644
index 0000000000..318fe16aac
--- /dev/null
+++ b/gfx/drivers/miyoomini/scaler_neon.c
@@ -0,0 +1,1831 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+
+//
+//	arm NEON / C integer scalers for ARMv7 devices
+//	args/	src :	src offset		address of top left corner
+//		dst :	dst offset		address	of top left corner
+//		sw  :	src width		pixels
+//		sh  :	src height		pixels
+//		sp  :	src pitch (stride)	bytes	if 0, (src width * [2|4]) is used
+//		dp  :	dst pitch (stride)	bytes	if 0, (src width * [2|4] * multiplier) is used
+//
+//	** NOTE **
+//	since 32bit aligned addresses need to be processed for NEON scalers,
+//	x-offset and stride pixels must be even# in the case of 16bpp,
+//	if odd#, then handled by the C scaler
+//
+
+//
+//	C scalers
+//
+void scale1x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp, uint32_t ymul) {
+	if (!sw||!sh||!ymul) return;
+	uint32_t swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ((ymul == 1)&&(swl == sp)&&(sp == dp)) memcpy(dst, src, sp*sh);
+	else {
+		for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+			for (uint32_t i=ymul; i>0; i--, dst=(uint8_t*)dst+dp) memcpy(dst, src, swl);
+		}
+	}
+}
+
+void scale1x1_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c16(src, dst, sw, sh, sp, dp, 1); }
+void scale1x2_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c16(src, dst, sw, sh, sp, dp, 2); }
+void scale1x3_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c16(src, dst, sw, sh, sp, dp, 3); }
+void scale1x4_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c16(src, dst, sw, sh, sp, dp, 4); }
+
+void scale1x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp, uint32_t ymul) {
+	if (!sw||!sh||!ymul) return;
+	uint32_t swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ((ymul == 1)&&(swl == sp)&&(sp == dp)) memcpy(dst, src, sp*sh);
+	else {
+		for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+			for (uint32_t i=ymul; i>0; i--, dst=(uint8_t*)dst+dp) memcpy(dst, src, swl);
+		}
+	}
+}
+
+void scale1x1_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c32(src, dst, sw, sh, sp, dp, 1); }
+void scale1x2_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c32(src, dst, sw, sh, sp, dp, 2); }
+void scale1x3_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c32(src, dst, sw, sh, sp, dp, 3); }
+void scale1x4_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale1x_c32(src, dst, sw, sh, sp, dp, 4); }
+
+void scale2x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp, uint32_t ymul) {
+	if (!sw||!sh||!ymul) return;
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=2) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			d[dx] = pix16|(pix16<<16);
+		}
+		void* __restrict dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=ymul-1; i>0; i--, dst=(uint8_t*)dst+dp) memcpy(dst, dstsrc, swl);
+	}
+}
+
+void scale2x1_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c16(src, dst, sw, sh, sp, dp, 1); }
+void scale2x2_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c16(src, dst, sw, sh, sp, dp, 2); }
+void scale2x3_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c16(src, dst, sw, sh, sp, dp, 3); }
+void scale2x4_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c16(src, dst, sw, sh, sp, dp, 4); }
+
+void scale2x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp, uint32_t ymul) {
+	if (!sw||!sh||!ymul) return;
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=2) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix;
+		}
+		void* __restrict dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=ymul-1; i>0; i--, dst=(uint8_t*)dst+dp) memcpy(dst, dstsrc, swl);
+	}
+}
+
+void scale2x1_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c32(src, dst, sw, sh, sp, dp, 1); }
+void scale2x2_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c32(src, dst, sw, sh, sp, dp, 2); }
+void scale2x3_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c32(src, dst, sw, sh, sp, dp, 3); }
+void scale2x4_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale2x_c32(src, dst, sw, sh, sp, dp, 4); }
+
+void scale4x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp, uint32_t ymul) {
+	if (!sw||!sh||!ymul) return;
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=4; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=4) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = dpix1; d[dx+2] = dpix2; d[dx+3] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d[dx+1] = dpix1;
+		}
+		void* __restrict dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=ymul-1; i>0; i--, dst=(uint8_t*)dst+dp) memcpy(dst, dstsrc, swl);
+	}
+}
+
+void scale4x1_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c16(src, dst, sw, sh, sp, dp, 1); }
+void scale4x2_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c16(src, dst, sw, sh, sp, dp, 2); }
+void scale4x3_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c16(src, dst, sw, sh, sp, dp, 3); }
+void scale4x4_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c16(src, dst, sw, sh, sp, dp, 4); }
+
+void scale4x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp, uint32_t ymul) {
+	if (!sw||!sh||!ymul) return;
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=4; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=4) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix; d[dx+3] = pix;
+		}
+		void* __restrict dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=ymul-1; i>0; i--, dst=(uint8_t*)dst+dp) memcpy(dst, dstsrc, swl);
+	}
+}
+
+void scale4x1_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c32(src, dst, sw, sh, sp, dp, 1); }
+void scale4x2_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c32(src, dst, sw, sh, sp, dp, 2); }
+void scale4x3_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c32(src, dst, sw, sh, sp, dp, 3); }
+void scale4x4_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	scale4x_c32(src, dst, sw, sh, sp, dp, 4); }
+
+//
+//	memcpy_neon (dst/src must be aligned 4, size must be aligned 2)
+//
+static void memcpy_neon(void* dst, void* src, uint32_t size) {
+	asm volatile (
+	"	bic r4, %[sz], #127	;"
+	"	add r3, %[s], %[sz]	;"	// r3 = endofs
+	"	add r4, %[s], r4	;"	// r4 = s128ofs
+	"	cmp %[s], r4		;"
+	"	beq 2f			;"
+	"1:	vldmia %[s]!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %[d]!, {q8-q15}	;"
+	"	cmp %[s], r4		;"
+	"	bne 1b			;"
+	"2:	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"	tst %[sz], #64		;"
+	"	beq 3f			;"
+	"	vldmia %[s]!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %[d]!, {q8-q11}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"3:	tst %[sz], #32		;"
+	"	beq 4f			;"
+	"	vldmia %[s]!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %[d]!, {q12-q13}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"4:	tst %[sz], #16		;"
+	"	beq 5f			;"
+	"	vldmia %[s]!, {q14}	;"	// 16 bytes
+	"	vstmia %[d]!, {q14}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"5:	tst %[sz], #8		;"
+	"	beq 6f			;"
+	"	vldmia %[s]!, {d30}	;"	// 8 bytes
+	"	vstmia %[d]!, {d30}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"6:	ldrh r4, [%[s]],#2	;"	// rest
+	"	strh r4, [%[d]],#2	;"
+	"	cmp %[s], r3		;"
+	"	bne 6b			;"
+	"7:				"
+	: [s]"+r"(src), [d]"+r"(dst)
+	: [sz]"r"(size)
+	: "r3","r4","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+//
+//	NEON scalers
+//
+
+void scale1x1_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x1_c16(src,dst,sw,sh,sp,dp); return; }
+	if ((swl == sp)&&(sp == dp)) memcpy_neon(dst, src, sp*sh);
+	else for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp) memcpy_neon(dst, src, swl);
+}
+
+void scale1x2_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x2_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl128 = swl & ~127;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x128bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	cmp %0, lr		;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 8f			;"
+	"	tst %3, #64		;"
+	"	beq 4f			;"
+	"	vldmia %0!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"4:	tst %3, #32		;"
+	"	beq 5f			;"
+	"	vldmia %0!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %1!, {q12-q13}	;"
+	"	vstmia r9!, {q12-q13}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"5:	tst %3, #16		;"
+	"	beq 6f			;"
+	"	vldmia %0!, {q14}	;"	// 16 bytes
+	"	vstmia %1!, {q14}	;"
+	"	vstmia r9!, {q14}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"6:	tst %3, #8		;"
+	"	beq 7f			;"
+	"	vldmia %0!, {d30}	;"	// 8 bytes
+	"	vstmia %1!, {d30}	;"
+	"	vstmia r9!, {d30}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"7:	ldr lr, [%0],#4		;"	// 4 bytes
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9]		;"
+	"8:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl128), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale1x3_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x3_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl128 = swl & ~127;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*3 - swl;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x128bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	cmp %0, lr		;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 8f			;"
+	"	tst %3, #64		;"
+	"	beq 4f			;"
+	"	vldmia %0!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	vstmia r10!, {q8-q11}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"4:	tst %3, #32		;"
+	"	beq 5f			;"
+	"	vldmia %0!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %1!, {q12-q13}	;"
+	"	vstmia r9!, {q12-q13}	;"
+	"	vstmia r10!, {q12-q13}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"5:	tst %3, #16		;"
+	"	beq 6f			;"
+	"	vldmia %0!, {q14}	;"	// 16 bytes
+	"	vstmia %1!, {q14}	;"
+	"	vstmia r9!, {q14}	;"
+	"	vstmia r10!, {q14}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"6:	tst %3, #8		;"
+	"	beq 7f			;"
+	"	vldmia %0!, {d30}	;"	// 8 bytes
+	"	vstmia %1!, {d30}	;"
+	"	vstmia r9!, {d30}	;"
+	"	vstmia r10!, {d30}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"7:	ldr lr, [%0],#4		;"	// 4 bytes
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9]		;"
+	"	str lr, [r10]		;"
+	"8:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl128), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale1x4_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x4_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl128 = swl & ~127;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x128bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	vstmia r11!, {q8-q15}	;"
+	"	cmp %0, lr		;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 8f			;"
+	"	tst %3, #64		;"
+	"	beq 4f			;"
+	"	vldmia %0!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	vstmia r10!, {q8-q11}	;"
+	"	vstmia r11!, {q8-q11}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"4:	tst %3, #32		;"
+	"	beq 5f			;"
+	"	vldmia %0!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %1!, {q12-q13}	;"
+	"	vstmia r9!, {q12-q13}	;"
+	"	vstmia r10!, {q12-q13}	;"
+	"	vstmia r11!, {q12-q13}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"5:	tst %3, #16		;"
+	"	beq 6f			;"
+	"	vldmia %0!, {q14}	;"	// 16 bytes
+	"	vstmia %1!, {q14}	;"
+	"	vstmia r9!, {q14}	;"
+	"	vstmia r10!, {q14}	;"
+	"	vstmia r11!, {q14}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"6:	tst %3, #8		;"
+	"	beq 7f			;"
+	"	vldmia %0!, {d30}	;"	// 8 bytes
+	"	vstmia %1!, {d30}	;"
+	"	vstmia r9!, {d30}	;"
+	"	vstmia r10!, {d30}	;"
+	"	vstmia r11!, {d30}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"7:	ldr lr, [%0],#4		;"	// 4 bytes
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9]		;"
+	"	str lr, [r10]		;"
+	"	str lr, [r11]		;"
+	"8:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl128), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale1x1_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x1_c32(src,dst,sw,sh,sp,dp); return; }
+	if ((swl == sp)&&(sp == dp)) memcpy_neon(dst, src, sp*sh);
+	else for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp) memcpy_neon(dst, src, swl);
+}
+
+void scale1x2_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x2_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl128 = swl & ~127;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x128bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %1!, {q8-q15}	;"
+	"	cmp %0, lr		;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 8f			;"
+	"	tst %3, #64		;"
+	"	beq 4f			;"
+	"	vldmia %0!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %1!, {q8-q11}	;"
+	"	cmp %0, r8		;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	beq 8f			;"
+	"4:	tst %3, #32		;"
+	"	beq 5f			;"
+	"	vldmia %0!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %1!, {q12-q13}	;"
+	"	cmp %0, r8		;"
+	"	vstmia r9!, {q12-q13}	;"
+	"	beq 8f			;"
+	"5:	tst %3, #16		;"
+	"	beq 6f			;"
+	"	vldmia %0!, {q14}	;"	// 16 bytes
+	"	vstmia %1!, {q14}	;"
+	"	cmp %0, r8		;"
+	"	vstmia r9!, {q14}	;"
+	"	beq 8f			;"
+	"6:	tst %3, #8		;"
+	"	beq 7f			;"
+	"	vldmia %0!, {d30}	;"	// 8 bytes
+	"	vstmia %1!, {d30}	;"
+	"	cmp %0, r8		;"
+	"	vstmia r9!, {d30}	;"
+	"	beq 8f			;"
+	"7:	ldr lr, [%0],#4		;"	// 4 bytes
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9]		;"
+	"8:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl128), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale1x3_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x3_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl128 = swl & ~127;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*3 - swl;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x128bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	cmp %0, lr		;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 8f			;"
+	"	tst %3, #64		;"
+	"	beq 4f			;"
+	"	vldmia %0!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	vstmia r10!, {q8-q11}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"4:	tst %3, #32		;"
+	"	beq 5f			;"
+	"	vldmia %0!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %1!, {q12-q13}	;"
+	"	vstmia r9!, {q12-q13}	;"
+	"	vstmia r10!, {q12-q13}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"5:	tst %3, #16		;"
+	"	beq 6f			;"
+	"	vldmia %0!, {q14}	;"	// 16 bytes
+	"	vstmia %1!, {q14}	;"
+	"	vstmia r9!, {q14}	;"
+	"	vstmia r10!, {q14}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"6:	tst %3, #8		;"
+	"	beq 7f			;"
+	"	vldmia %0!, {d30}	;"	// 8 bytes
+	"	vstmia %1!, {d30}	;"
+	"	vstmia r9!, {d30}	;"
+	"	vstmia r10!, {d30}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"7:	ldr lr, [%0],#4		;"	// 4 bytes
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9]		;"
+	"	str lr, [r10]		;"
+	"8:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl128), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale1x4_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x4_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl128 = swl & ~127;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x128bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	vstmia r11!, {q8-q15}	;"
+	"	cmp %0, lr		;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 8f			;"
+	"	tst %3, #64		;"
+	"	beq 4f			;"
+	"	vldmia %0!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	vstmia r10!, {q8-q11}	;"
+	"	vstmia r11!, {q8-q11}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"4:	tst %3, #32		;"
+	"	beq 5f			;"
+	"	vldmia %0!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %1!, {q12-q13}	;"
+	"	vstmia r9!, {q12-q13}	;"
+	"	vstmia r10!, {q12-q13}	;"
+	"	vstmia r11!, {q12-q13}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"5:	tst %3, #16		;"
+	"	beq 6f			;"
+	"	vldmia %0!, {q14}	;"	// 16 bytes
+	"	vstmia %1!, {q14}	;"
+	"	vstmia r9!, {q14}	;"
+	"	vstmia r10!, {q14}	;"
+	"	vstmia r11!, {q14}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"6:	tst %3, #8		;"
+	"	beq 7f			;"
+	"	vldmia %0!, {d30}	;"	// 8 bytes
+	"	vstmia %1!, {d30}	;"
+	"	vstmia r9!, {d30}	;"
+	"	vstmia r10!, {d30}	;"
+	"	vstmia r11!, {d30}	;"
+	"	cmp %0, r8		;"
+	"	beq 8f			;"
+	"7:	ldr lr, [%0],#4		;"	// 4 bytes
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9]		;"
+	"	str lr, [r10]		;"
+	"	str lr, [r11]		;"
+	"8:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl128), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x1_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x1_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x64bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 32 pixels 64 bytes
+	"	vdup.16 d0, d23[3]	;"
+	"	vdup.16 d1, d23[2]	;"
+	"	vext.16 d31, d1,d0,#2	;"
+	"	vdup.16 d0, d23[1]	;"
+	"	vdup.16 d1, d23[0]	;"
+	"	vext.16 d30, d1,d0,#2	;"
+	"	vdup.16 d0, d22[3]	;"
+	"	vdup.16 d1, d22[2]	;"
+	"	vext.16 d29, d1,d0,#2	;"
+	"	vdup.16 d0, d22[1]	;"
+	"	vdup.16 d1, d22[0]	;"
+	"	vext.16 d28, d1,d0,#2	;"
+	"	vdup.16 d0, d21[3]	;"
+	"	vdup.16 d1, d21[2]	;"
+	"	vext.16 d27, d1,d0,#2	;"
+	"	vdup.16 d0, d21[1]	;"
+	"	vdup.16 d1, d21[0]	;"
+	"	vext.16 d26, d1,d0,#2	;"
+	"	vdup.16 d0, d20[3]	;"
+	"	vdup.16 d1, d20[2]	;"
+	"	vext.16 d25, d1,d0,#2	;"
+	"	vdup.16 d0, d20[1]	;"
+	"	vdup.16 d1, d20[0]	;"
+	"	vext.16 d24, d1,d0,#2	;"
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"	tst %3, #32		;"
+	"	beq 4f			;"
+	"	vldmia %0!,{q8-q9}	;"	// 16 pixels
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8-q11}	;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	orr lr, lr, lsl #16	;"
+	"	cmp %0, r8		;"
+	"	str lr, [%1],#4		;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","lr","q0","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x2_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x2_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x64bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 32 pixels 64 bytes
+	"	vdup.16 d0, d23[3]	;"
+	"	vdup.16 d1, d23[2]	;"
+	"	vext.16 d31, d1,d0,#2	;"
+	"	vdup.16 d0, d23[1]	;"
+	"	vdup.16 d1, d23[0]	;"
+	"	vext.16 d30, d1,d0,#2	;"
+	"	vdup.16 d0, d22[3]	;"
+	"	vdup.16 d1, d22[2]	;"
+	"	vext.16 d29, d1,d0,#2	;"
+	"	vdup.16 d0, d22[1]	;"
+	"	vdup.16 d1, d22[0]	;"
+	"	vext.16 d28, d1,d0,#2	;"
+	"	vdup.16 d0, d21[3]	;"
+	"	vdup.16 d1, d21[2]	;"
+	"	vext.16 d27, d1,d0,#2	;"
+	"	vdup.16 d0, d21[1]	;"
+	"	vdup.16 d1, d21[0]	;"
+	"	vext.16 d26, d1,d0,#2	;"
+	"	vdup.16 d0, d20[3]	;"
+	"	vdup.16 d1, d20[2]	;"
+	"	vext.16 d25, d1,d0,#2	;"
+	"	vdup.16 d0, d20[1]	;"
+	"	vdup.16 d1, d20[0]	;"
+	"	vext.16 d24, d1,d0,#2	;"
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"	tst %3, #32		;"
+	"	beq 4f			;"
+	"	vldmia %0!,{q8-q9}	;"	// 16 pixels
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	orr lr, lr, lsl #16	;"
+	"	cmp %0, r8		;"
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9],#4		;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","lr","q0","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x3_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x3_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*3 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x64bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 32 pixels 64 bytes
+	"	vdup.16 d0, d23[3]	;"
+	"	vdup.16 d1, d23[2]	;"
+	"	vext.16 d31, d1,d0,#2	;"
+	"	vdup.16 d0, d23[1]	;"
+	"	vdup.16 d1, d23[0]	;"
+	"	vext.16 d30, d1,d0,#2	;"
+	"	vdup.16 d0, d22[3]	;"
+	"	vdup.16 d1, d22[2]	;"
+	"	vext.16 d29, d1,d0,#2	;"
+	"	vdup.16 d0, d22[1]	;"
+	"	vdup.16 d1, d22[0]	;"
+	"	vext.16 d28, d1,d0,#2	;"
+	"	vdup.16 d0, d21[3]	;"
+	"	vdup.16 d1, d21[2]	;"
+	"	vext.16 d27, d1,d0,#2	;"
+	"	vdup.16 d0, d21[1]	;"
+	"	vdup.16 d1, d21[0]	;"
+	"	vext.16 d26, d1,d0,#2	;"
+	"	vdup.16 d0, d20[3]	;"
+	"	vdup.16 d1, d20[2]	;"
+	"	vext.16 d25, d1,d0,#2	;"
+	"	vdup.16 d0, d20[1]	;"
+	"	vdup.16 d1, d20[0]	;"
+	"	vext.16 d24, d1,d0,#2	;"
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"	tst %3, #32		;"
+	"	beq 4f			;"
+	"	vldmia %0!,{q8-q9}	;"	// 16 pixels
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	vstmia r10!, {q8-q11}	;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	orr lr, lr, lsl #16	;"
+	"	cmp %0, r8		;"
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9],#4		;"
+	"	str lr, [r10],#4	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","lr","q0","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x4_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x3_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x64bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 32 pixels 64 bytes
+	"	vdup.16 d0, d23[3]	;"
+	"	vdup.16 d1, d23[2]	;"
+	"	vext.16 d31, d1,d0,#2	;"
+	"	vdup.16 d0, d23[1]	;"
+	"	vdup.16 d1, d23[0]	;"
+	"	vext.16 d30, d1,d0,#2	;"
+	"	vdup.16 d0, d22[3]	;"
+	"	vdup.16 d1, d22[2]	;"
+	"	vext.16 d29, d1,d0,#2	;"
+	"	vdup.16 d0, d22[1]	;"
+	"	vdup.16 d1, d22[0]	;"
+	"	vext.16 d28, d1,d0,#2	;"
+	"	vdup.16 d0, d21[3]	;"
+	"	vdup.16 d1, d21[2]	;"
+	"	vext.16 d27, d1,d0,#2	;"
+	"	vdup.16 d0, d21[1]	;"
+	"	vdup.16 d1, d21[0]	;"
+	"	vext.16 d26, d1,d0,#2	;"
+	"	vdup.16 d0, d20[3]	;"
+	"	vdup.16 d1, d20[2]	;"
+	"	vext.16 d25, d1,d0,#2	;"
+	"	vdup.16 d0, d20[1]	;"
+	"	vdup.16 d1, d20[0]	;"
+	"	vext.16 d24, d1,d0,#2	;"
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	vstmia r11!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"	tst %3, #32		;"
+	"	beq 4f			;"
+	"	vldmia %0!,{q8-q9}	;"	// 16 pixels
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r9!, {q8-q11}	;"
+	"	vstmia r10!, {q8-q11}	;"
+	"	vstmia r11!, {q8-q11}	;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	orr lr, lr, lsl #16	;"
+	"	cmp %0, r8		;"
+	"	str lr, [%1],#4		;"
+	"	str lr, [r9],#4		;"
+	"	str lr, [r10],#4	;"
+	"	str lr, [r11],#4	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q0","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x1_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x1_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x64bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 16 pixels 64 bytes
+	"	vdup.32 d31, d23[1]	;"
+	"	vdup.32 d30, d23[0]	;"
+	"	vdup.32 d29, d22[1]	;"
+	"	vdup.32 d28, d22[0]	;"
+	"	vdup.32 d27, d21[1]	;"
+	"	vdup.32 d26, d21[0]	;"
+	"	vdup.32 d25, d20[1]	;"
+	"	vdup.32 d24, d20[0]	;"
+	"	vdup.32 d23, d19[1]	;"
+	"	vdup.32 d22, d19[0]	;"
+	"	vdup.32 d21, d18[1]	;"
+	"	vdup.32 d20, d18[0]	;"
+	"	vdup.32 d19, d17[1]	;"
+	"	vdup.32 d18, d17[0]	;"
+	"	vdup.32 d17, d16[1]	;"
+	"	vdup.32 d16, d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x2_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x2_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x64bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 16 pixels 64 bytes
+	"	vdup.32 d31, d23[1]	;"
+	"	vdup.32 d30, d23[0]	;"
+	"	vdup.32 d29, d22[1]	;"
+	"	vdup.32 d28, d22[0]	;"
+	"	vdup.32 d27, d21[1]	;"
+	"	vdup.32 d26, d21[0]	;"
+	"	vdup.32 d25, d20[1]	;"
+	"	vdup.32 d24, d20[0]	;"
+	"	vdup.32 d23, d19[1]	;"
+	"	vdup.32 d22, d19[0]	;"
+	"	vdup.32 d21, d18[1]	;"
+	"	vdup.32 d20, d18[0]	;"
+	"	vdup.32 d19, d17[1]	;"
+	"	vdup.32 d18, d17[0]	;"
+	"	vdup.32 d17, d16[1]	;"
+	"	vdup.32 d16, d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x3_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x3_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*3 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x64bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 16 pixels 64 bytes
+	"	vdup.32 d31, d23[1]	;"
+	"	vdup.32 d30, d23[0]	;"
+	"	vdup.32 d29, d22[1]	;"
+	"	vdup.32 d28, d22[0]	;"
+	"	vdup.32 d27, d21[1]	;"
+	"	vdup.32 d26, d21[0]	;"
+	"	vdup.32 d25, d20[1]	;"
+	"	vdup.32 d24, d20[0]	;"
+	"	vdup.32 d23, d19[1]	;"
+	"	vdup.32 d22, d19[0]	;"
+	"	vdup.32 d21, d18[1]	;"
+	"	vdup.32 d20, d18[0]	;"
+	"	vdup.32 d19, d17[1]	;"
+	"	vdup.32 d18, d17[0]	;"
+	"	vdup.32 d17, d16[1]	;"
+	"	vdup.32 d16, d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	vstmia r10!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x4_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x4_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x64bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 16 pixels 64 bytes
+	"	vdup.32 d31, d23[1]	;"
+	"	vdup.32 d30, d23[0]	;"
+	"	vdup.32 d29, d22[1]	;"
+	"	vdup.32 d28, d22[0]	;"
+	"	vdup.32 d27, d21[1]	;"
+	"	vdup.32 d26, d21[0]	;"
+	"	vdup.32 d25, d20[1]	;"
+	"	vdup.32 d24, d20[0]	;"
+	"	vdup.32 d23, d19[1]	;"
+	"	vdup.32 d22, d19[0]	;"
+	"	vdup.32 d21, d18[1]	;"
+	"	vdup.32 d20, d18[0]	;"
+	"	vdup.32 d19, d17[1]	;"
+	"	vdup.32 d18, d17[0]	;"
+	"	vdup.32 d17, d16[1]	;"
+	"	vdup.32 d16, d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	vstmia r11!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	vstmia r10!, {d16}	;"
+	"	vstmia r11!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x1_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x1_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x32bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 16 pixels 32 bytes
+	"	vdup.16 d31,d19[3]	;"
+	"	vdup.16 d30,d19[2]	;"
+	"	vdup.16 d29,d19[1]	;"
+	"	vdup.16 d28,d19[0]	;"
+	"	vdup.16 d27,d18[3]	;"
+	"	vdup.16 d26,d18[2]	;"
+	"	vdup.16 d25,d18[1]	;"
+	"	vdup.16 d24,d18[0]	;"
+	"	vdup.16 d23,d17[3]	;"
+	"	vdup.16 d22,d17[2]	;"
+	"	vdup.16 d21,d17[1]	;"
+	"	vdup.16 d20,d17[0]	;"
+	"	vdup.16 d19,d16[3]	;"
+	"	vdup.16 d18,d16[2]	;"
+	"	vdup.16 d17,d16[1]	;"
+	"	vdup.16 d16,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	vdup.16 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x2_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x2_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x32bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 16 pixels 32 bytes
+	"	vdup.16 d31,d19[3]	;"
+	"	vdup.16 d30,d19[2]	;"
+	"	vdup.16 d29,d19[1]	;"
+	"	vdup.16 d28,d19[0]	;"
+	"	vdup.16 d27,d18[3]	;"
+	"	vdup.16 d26,d18[2]	;"
+	"	vdup.16 d25,d18[1]	;"
+	"	vdup.16 d24,d18[0]	;"
+	"	vdup.16 d23,d17[3]	;"
+	"	vdup.16 d22,d17[2]	;"
+	"	vdup.16 d21,d17[1]	;"
+	"	vdup.16 d20,d17[0]	;"
+	"	vdup.16 d19,d16[3]	;"
+	"	vdup.16 d18,d16[2]	;"
+	"	vdup.16 d17,d16[1]	;"
+	"	vdup.16 d16,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	vdup.16 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x3_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x3_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*3 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x32bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 16 pixels 32 bytes
+	"	vdup.16 d31,d19[3]	;"
+	"	vdup.16 d30,d19[2]	;"
+	"	vdup.16 d29,d19[1]	;"
+	"	vdup.16 d28,d19[0]	;"
+	"	vdup.16 d27,d18[3]	;"
+	"	vdup.16 d26,d18[2]	;"
+	"	vdup.16 d25,d18[1]	;"
+	"	vdup.16 d24,d18[0]	;"
+	"	vdup.16 d23,d17[3]	;"
+	"	vdup.16 d22,d17[2]	;"
+	"	vdup.16 d21,d17[1]	;"
+	"	vdup.16 d20,d17[0]	;"
+	"	vdup.16 d19,d16[3]	;"
+	"	vdup.16 d18,d16[2]	;"
+	"	vdup.16 d17,d16[1]	;"
+	"	vdup.16 d16,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	vstmia r10!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	vdup.16 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	vstmia r10!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x4_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x4_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x32bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 16 pixels 32 bytes
+	"	vdup.16 d31,d19[3]	;"
+	"	vdup.16 d30,d19[2]	;"
+	"	vdup.16 d29,d19[1]	;"
+	"	vdup.16 d28,d19[0]	;"
+	"	vdup.16 d27,d18[3]	;"
+	"	vdup.16 d26,d18[2]	;"
+	"	vdup.16 d25,d18[1]	;"
+	"	vdup.16 d24,d18[0]	;"
+	"	vdup.16 d23,d17[3]	;"
+	"	vdup.16 d22,d17[2]	;"
+	"	vdup.16 d21,d17[1]	;"
+	"	vdup.16 d20,d17[0]	;"
+	"	vdup.16 d19,d16[3]	;"
+	"	vdup.16 d18,d16[2]	;"
+	"	vdup.16 d17,d16[1]	;"
+	"	vdup.16 d16,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	vstmia r10!,{q8-q15}	;"
+	"	vstmia r11!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	vdup.16 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	vstmia r10!, {d16}	;"
+	"	vstmia r11!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x1_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x1_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x32bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 8 pixels 32 bytes
+	"	vdup.32 q15,d19[1]	;"
+	"	vdup.32 q14,d19[0]	;"
+	"	vdup.32 q13,d18[1]	;"
+	"	vdup.32 q12,d18[0]	;"
+	"	vdup.32 q11,d17[1]	;"
+	"	vdup.32 q10,d17[0]	;"
+	"	vdup.32 q9,d16[1]	;"
+	"	vdup.32 q8,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 q8, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x2_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x2_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x32bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 8 pixels 32 bytes
+	"	vdup.32 q15,d19[1]	;"
+	"	vdup.32 q14,d19[0]	;"
+	"	vdup.32 q13,d18[1]	;"
+	"	vdup.32 q12,d18[0]	;"
+	"	vdup.32 q11,d17[1]	;"
+	"	vdup.32 q10,d17[0]	;"
+	"	vdup.32 q9,d16[1]	;"
+	"	vdup.32 q8,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 q8, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8}	;"
+	"	vstmia r9!, {q8}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x3_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x3_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*3 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x32bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 8 pixels 32 bytes
+	"	vdup.32 q15,d19[1]	;"
+	"	vdup.32 q14,d19[0]	;"
+	"	vdup.32 q13,d18[1]	;"
+	"	vdup.32 q12,d18[0]	;"
+	"	vdup.32 q11,d17[1]	;"
+	"	vdup.32 q10,d17[0]	;"
+	"	vdup.32 q9,d16[1]	;"
+	"	vdup.32 q8,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	vstmia r10!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 q8, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8}	;"
+	"	vstmia r9!, {q8}	;"
+	"	vstmia r10!, {q8}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x4_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) return;
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x4_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x32bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 8 pixels 32 bytes
+	"	vdup.32 q15,d19[1]	;"
+	"	vdup.32 q14,d19[0]	;"
+	"	vdup.32 q13,d18[1]	;"
+	"	vdup.32 q12,d18[0]	;"
+	"	vdup.32 q11,d17[1]	;"
+	"	vdup.32 q10,d17[0]	;"
+	"	vdup.32 q9,d16[1]	;"
+	"	vdup.32 q8,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	vstmia r10!,{q8-q15}	;"
+	"	vstmia r11!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 q8, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8}	;"
+	"	vstmia r9!, {q8}	;"
+	"	vstmia r10!, {q8}	;"
+	"	vstmia r11!, {q8}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+/* Bridge to NEON scalers for Retroarch video driver */
+void scale1x1_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x1_n16(src, dst, sw, sh, sp, dp); }
+void scale1x2_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x2_n16(src, dst, sw, sh, sp, dp); }
+void scale1x3_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x3_n16(src, dst, sw, sh, sp, dp); }
+void scale1x4_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x4_n16(src, dst, sw, sh, sp, dp); }
+void scale1x1_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x1_n32(src, dst, sw, sh, sp, dp); }
+void scale1x2_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x2_n32(src, dst, sw, sh, sp, dp); }
+void scale1x3_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x3_n32(src, dst, sw, sh, sp, dp); }
+void scale1x4_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x4_n32(src, dst, sw, sh, sp, dp); }
+void scale2x1_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x1_n16(src, dst, sw, sh, sp, dp); }
+void scale2x2_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x2_n16(src, dst, sw, sh, sp, dp); }
+void scale2x3_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x3_n16(src, dst, sw, sh, sp, dp); }
+void scale2x4_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x4_n16(src, dst, sw, sh, sp, dp); }
+void scale2x1_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x1_n32(src, dst, sw, sh, sp, dp); }
+void scale2x2_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x2_n32(src, dst, sw, sh, sp, dp); }
+void scale2x3_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x3_n32(src, dst, sw, sh, sp, dp); }
+void scale2x4_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x4_n32(src, dst, sw, sh, sp, dp); }
+void scale4x1_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x1_n16(src, dst, sw, sh, sp, dp); }
+void scale4x2_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x2_n16(src, dst, sw, sh, sp, dp); }
+void scale4x3_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x3_n16(src, dst, sw, sh, sp, dp); }
+void scale4x4_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x4_n16(src, dst, sw, sh, sp, dp); }
+void scale4x1_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x1_n32(src, dst, sw, sh, sp, dp); }
+void scale4x2_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x2_n32(src, dst, sw, sh, sp, dp); }
+void scale4x3_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x3_n32(src, dst, sw, sh, sp, dp); }
+void scale4x4_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x4_n32(src, dst, sw, sh, sp, dp); }
diff --git a/gfx/drivers/miyoomini/scaler_neon.h b/gfx/drivers/miyoomini/scaler_neon.h
new file mode 100644
index 0000000000..aeb0c66200
--- /dev/null
+++ b/gfx/drivers/miyoomini/scaler_neon.h
@@ -0,0 +1,72 @@
+#ifndef __SCALER_NEON_H__
+#define __SCALER_NEON_H__
+#include <stdint.h>
+
+//
+//	arm NEON / C integer scalers for ARMv7 devices
+//	args/	src :	src offset		address of top left corner
+//		dst :	dst offset		address	of top left corner
+//		sw  :	src width		pixels
+//		sh  :	src height		pixels
+//		sp  :	src pitch (stride)	bytes	if 0, (src width * [2|4]) is used
+//		dp  :	dst pitch (stride)	bytes	if 0, (src width * [2|4] * multiplier) is used
+//
+//	** NOTE **
+//	since 32bit aligned addresses need to be processed for NEON scalers,
+//	x-offset and stride pixels must be even# in the case of 16bpp,
+//	if odd#, then handled by the C scaler
+//
+
+//	NEON scalers
+void scale1x1_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x1_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x2_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x2_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x3_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x3_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x4_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x4_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x1_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x1_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x2_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x2_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x3_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x3_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x4_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x4_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x1_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x1_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x2_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x2_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x3_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x3_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x4_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x4_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+
+//	C scalers
+void scale1x1_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x1_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x2_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x2_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x3_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x3_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x4_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x4_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x1_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x1_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x2_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x2_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x3_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x3_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x4_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x4_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x1_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x1_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x2_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x2_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x3_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x3_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x4_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x4_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+
+#endif
diff --git a/gfx/drivers/miyoomini/sdl_miyoomini_gfx.c b/gfx/drivers/miyoomini/sdl_miyoomini_gfx.c
new file mode 100644
index 0000000000..0011be488c
--- /dev/null
+++ b/gfx/drivers/miyoomini/sdl_miyoomini_gfx.c
@@ -0,0 +1,1220 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *  Copyright (C) 2011-2017 - Higor Euripedes
+ *  Copyright (C) 2019-2021 - James Leaver
+ *  Copyright (C)      2021 - John Parton
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <SDL/SDL.h>
+#include <SDL/SDL_video.h>
+
+#include <gfx/video_frame.h>
+#include <string/stdstring.h>
+#include <encodings/utf.h>
+#include <features/features_cpu.h>
+
+#include "gfx.c"
+#include "scaler_neon.c"
+#include <signal.h>
+#include <sys/mman.h>
+#include <sys/time.h>
+
+#ifdef HAVE_CONFIG_H
+#include "../../config.h"
+#endif
+
+#ifdef HAVE_MENU
+#include "../../menu/menu_driver.h"
+#endif
+
+#include "../../dingux/dingux_utils.h"
+
+#include "../../verbosity.h"
+#include "../../gfx/drivers_font_renderer/bitmap.h"
+#include "../../configuration.h"
+#include "../../file_path_special.h"
+#include "../../paths.h"
+#include "../../retroarch.h"
+#include "../../runloop.h"
+
+#define likely(x)   __builtin_expect(!!(x), 1)
+#define unlikely(x) __builtin_expect(!!(x), 0)
+
+#define SDL_MIYOOMINI_WIDTH  640
+#define SDL_MIYOOMINI_HEIGHT 480
+#define RGUI_MENU_WIDTH  320
+#define RGUI_MENU_HEIGHT 240
+#define SDL_NUM_FONT_GLYPHS 256
+#define OSD_TEXT_Y_MARGIN 4
+#define OSD_TEXT_LINES_MAX 3	/* 1 .. 7 */
+#define OSD_TEXT_LINE_LEN ((uint32_t)(RGUI_MENU_WIDTH / FONT_WIDTH_STRIDE)-1)
+#define OSD_TEXT_LEN_MAX (OSD_TEXT_LINE_LEN * OSD_TEXT_LINES_MAX)
+#define RGUI_MENU_STRETCH_FILE_PATH "/mnt/SDCARD/.tmp_update/config/RetroArch/.noMenuStretch"
+#define FB_DEVICE_FILE_PATH "/dev/fb0"
+#define NEW_RES_FILE_PATH "/tmp/new_res_available"
+
+uint32_t res_x, res_y;
+bool rgui_menu_stretch = true;
+SDL_Rect rgui_menu_dest_rect;
+typedef struct sdl_miyoomini_video sdl_miyoomini_video_t;
+struct sdl_miyoomini_video
+{
+   SDL_Surface *screen;
+   void (*scale_func)(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+   /* Scaling/padding/cropping parameters */
+   unsigned content_width;
+   unsigned content_height;
+   unsigned frame_width;
+   unsigned frame_height;
+   unsigned video_x;
+   unsigned video_y;
+   unsigned video_w;
+   unsigned video_h;
+   unsigned rotate;
+   bool rgb32;
+   bool menu_active;
+   bool was_in_menu;
+   retro_time_t last_frame_time;
+   retro_time_t ff_frame_time_min;
+   enum dingux_ipu_filter_type filter_type;
+   bool vsync;
+   bool keep_aspect;
+   bool scale_integer;
+   bool quitting;
+   bitmapfont_lut_t *osd_font;
+   uint32_t font_colour32;
+   SDL_Surface *menuscreen;
+   SDL_Surface *menuscreen_rgui;
+#ifdef HAVE_OVERLAY
+   SDL_Surface *overlay_surface;
+#endif
+   unsigned msg_count;
+   char msg_tmp[OSD_TEXT_LEN_MAX];
+};
+
+/* Clear OSD text area, without video_rect, rotate180 */
+static void sdl_miyoomini_clear_msgarea(void* buf, unsigned x, unsigned y, unsigned w, unsigned h, unsigned lines) {
+   if ( ( x == 0 ) && ( w == res_x  ) && ( y == 0 ) && ( h == res_y ) ) return;
+
+   uint32_t x0 = res_x - (x + w); /* left margin , right margin = x */
+   uint32_t y0 = res_y - (y + h); /* top margin , bottom margin = y */
+   uint32_t sl = x0 * sizeof(uint32_t); /* left buffer size */
+   uint32_t sr = x * sizeof(uint32_t); /* right buffer size */
+   uint32_t sw = w * sizeof(uint32_t); /* pitch */
+   uint32_t ss = res_x * sizeof(uint32_t); /* stride */
+   uint32_t vy = OSD_TEXT_Y_MARGIN + 2; /* clear start y offset */
+   uint32_t vh = FONT_HEIGHT_STRIDE * 2 * lines - 2; /* clear height */
+   uint32_t vh1 = (y0 < vy) ? 0 : (y0 - vy); if (vh1 > vh) vh1 = vh;
+   uint32_t vh2 = vh - vh1;
+   uint32_t ssl = ss * vh1 + sl;
+   uint32_t srl = sr + sl;
+   void* ofs = buf + vy * ss;
+
+   if (ssl) memset(ofs, 0, ssl);
+   ofs += ssl + sw;
+   for (; vh2>1; vh2--, ofs += ss) { if (srl) memset(ofs, 0, srl); }
+   if ((vh2) && (sr)) memset(ofs, 0, sr);
+}
+
+/* Print OSD text, flip callback, direct draw to framebuffer, 32bpp, 2x, rotate180 */
+static void sdl_miyoomini_print_msg(void* data) {
+   if (unlikely(!data)) return;
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+
+   void *screen_buf;
+   const char *str  = vid->msg_tmp;
+   uint32_t str_len = strlen_size(str, OSD_TEXT_LEN_MAX);
+   if (str_len) {
+      screen_buf              = fb_addr + (vinfo.yoffset * res_x * sizeof(uint32_t));
+      bool **font_lut         = vid->osd_font->lut;
+      uint32_t str_lines      = (uint32_t)((str_len - 1) / OSD_TEXT_LINE_LEN) + 1;
+      uint32_t str_counter    = OSD_TEXT_LINE_LEN;
+      const int x_pos_def     = res_x - (FONT_WIDTH_STRIDE * 2);
+      int x_pos               = x_pos_def;
+      int y_pos               = OSD_TEXT_Y_MARGIN - 4 + (FONT_HEIGHT_STRIDE * 2 * str_lines);
+
+      for (; str_len > 0; str_len--) {
+         /* Check for out of bounds x coordinates */
+         if (!str_counter--) {
+            x_pos = x_pos_def; y_pos -= (FONT_HEIGHT_STRIDE * 2); str_counter = OSD_TEXT_LINE_LEN;
+         }
+         /* Deal with spaces first, for efficiency */
+         if (*str == ' ') str++;
+         else {
+            uint32_t i, j;
+            bool *symbol_lut;
+            uint32_t symbol = utf8_walk(&str);
+
+            /* Stupid hack: 'oe' ligatures are not really
+             * standard extended ASCII, so we have to waste
+             * CPU cycles performing a conversion from the
+             * unicode values... */
+            if (symbol == 339) /* Latin small ligature oe */
+               symbol = 156;
+            if (symbol == 338) /* Latin capital ligature oe */
+               symbol = 140;
+
+            if (symbol >= SDL_NUM_FONT_GLYPHS) continue;
+
+            symbol_lut = font_lut[symbol];
+
+            for (j = 0; j < FONT_HEIGHT; j++) {
+               uint32_t buff_offset = ((y_pos - (j * 2) ) * res_x) + x_pos;
+
+               for (i = 0; i < FONT_WIDTH; i++) {
+                  if (*(symbol_lut + i + (j * FONT_WIDTH))) {
+                     uint32_t *screen_buf_ptr = (uint32_t*)screen_buf + buff_offset - (i * 2);
+
+                     /* Bottom shadow (1) */
+                     screen_buf_ptr[+0] = 0;
+                     screen_buf_ptr[+1] = 0;
+                     screen_buf_ptr[+2] = 0;
+                     screen_buf_ptr[+3] = 0;
+
+                     /* Bottom shadow (2) */
+                     screen_buf_ptr[res_x+0] = 0;
+                     screen_buf_ptr[res_x+1] = 0;
+                     screen_buf_ptr[res_x+2] = 0;
+                     screen_buf_ptr[res_x+3] = 0;
+
+                     /* Text pixel + right shadow (1) */
+                     screen_buf_ptr[(res_x*2)+0] = 0;
+                     screen_buf_ptr[(res_x*2)+1] = 0;
+                     screen_buf_ptr[(res_x*2)+2] = vid->font_colour32;
+                     screen_buf_ptr[(res_x*2)+3] = vid->font_colour32;
+
+                     /* Text pixel + right shadow (2) */
+                     screen_buf_ptr[(res_x*3)+0] = 0;
+                     screen_buf_ptr[(res_x*3)+1] = 0;
+                     screen_buf_ptr[(res_x*3)+2] = vid->font_colour32;
+                     screen_buf_ptr[(res_x*3)+3] = vid->font_colour32;
+                  }
+               }
+            }
+         }
+         x_pos -= FONT_WIDTH_STRIDE * 2;
+      }
+      vid->msg_count |= (str_lines << 6);
+   }
+   if (vid->msg_count & 7) {
+      /* clear recent OSD text */
+      screen_buf = fb_addr;
+      uint32_t target_offset = vinfo.yoffset + res_y;
+      if (target_offset != res_y * 3) screen_buf += target_offset * res_x * sizeof(uint32_t);
+      sdl_miyoomini_clear_msgarea(screen_buf, vid->video_x, vid->video_y, vid->video_w, vid->video_h, vid->msg_count & 7);
+   }
+   vid->msg_count >>= 3;
+}
+
+/* Nearest neighbor scalers */
+#define NN_SHIFT 16
+void scalenn_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+   if (unlikely(!data||!sw||!sh)) return;
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   uint32_t dw = vid->video_w;
+   uint32_t dh = vid->video_h;
+
+   uint32_t x_step = (sw << NN_SHIFT) / dw + 1;
+   uint32_t y_step = (sh << NN_SHIFT) / dh + 1;
+
+   uint32_t in_stride  = sp >> 1;
+   uint32_t out_stride = dp >> 1;
+
+   uint16_t* in_ptr  = (uint16_t*)src;
+   uint16_t* out_ptr = (uint16_t*)dst;
+
+   uint32_t oy = 0;
+   uint32_t y  = 0;
+
+   /* Reading 16bits takes a little time,
+      so try not to read as much as possible in the case of 16bpp */
+   if (dh > sh) {
+      if (dw > sw) {
+         do {
+            uint32_t col = dw;
+            uint32_t ox  = 0;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            uint16_t pix = in_ptr[0];
+            do {
+               uint32_t tx = x >> NN_SHIFT;
+               if (tx != ox) {
+                  pix = in_ptr[tx];
+                  ox  = tx;
+               }
+               *(out_ptr++) = pix;
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            uint16_t* optrtmp2 = optrtmp1;
+            for(; ty == oy; y += y_step, ty = y >> NN_SHIFT) {
+               if (!--dh) return;
+               optrtmp2 += out_stride;
+               memcpy(optrtmp2, optrtmp1, dw << 1);
+            }
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp2 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      } else {
+         do {
+            uint32_t col = dw;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            do {
+               *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            uint16_t* optrtmp2 = optrtmp1;
+            for(; ty == oy; y += y_step, ty = y >> NN_SHIFT) {
+               if (!--dh) return;
+               optrtmp2 += out_stride;
+               memcpy(optrtmp2, optrtmp1, dw << 1);
+            }
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp2 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      }
+   } else {
+      if (dw > sw) {
+         do {
+            uint32_t col = dw;
+            uint32_t ox  = 0;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            uint16_t pix = in_ptr[0];
+            do {
+               uint32_t tx = x >> NN_SHIFT;
+               if (tx != ox) {
+                  pix = in_ptr[tx];
+                  ox  = tx;
+               }
+               *(out_ptr++) = pix;
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp1 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      } else {
+         do {
+            uint32_t col = dw;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            do {
+               *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp1 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      }
+   }
+}
+
+void scalenn_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+   if (unlikely(!data||!sw||!sh)) return;
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   uint32_t dw = vid->video_w;
+   uint32_t dh = vid->video_h;
+
+   uint32_t x_step = (sw << NN_SHIFT) / dw + 1;
+   uint32_t y_step = (sh << NN_SHIFT) / dh + 1;
+
+   uint32_t in_stride  = sp >> 2;
+   uint32_t out_stride = dp >> 2;
+
+   uint32_t* in_ptr  = (uint32_t*)src;
+   uint32_t* out_ptr = (uint32_t*)dst;
+
+   uint32_t oy = 0;
+   uint32_t y  = 0;
+
+   /* Reading 32bit is fast when cached,
+      so the x-axis is not considered in the case of 32bpp */
+   if (dh > sh) {
+      do {
+         uint32_t col = dw;
+         uint32_t x   = 0;
+
+         uint32_t* optrtmp1 = out_ptr;
+
+         do {
+            *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+            x           += x_step;
+         } while (--col);
+
+         y += y_step;
+         uint32_t ty = y >> NN_SHIFT;
+         uint32_t* optrtmp2 = optrtmp1;
+         for(; ty == oy; y += y_step, ty = y >> NN_SHIFT) {
+            if (!--dh) return;
+            optrtmp2 += out_stride;
+            memcpy(optrtmp2, optrtmp1, dw << 2);
+         }
+         in_ptr += (ty - oy) * in_stride;
+         out_ptr = optrtmp2 + out_stride;
+         oy      = ty;
+      } while (--dh);
+   } else {
+      do {
+         uint32_t col = dw;
+         uint32_t x   = 0;
+
+         uint32_t* optrtmp1 = out_ptr;
+
+         do {
+            *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+            x           += x_step;
+         } while (--col);
+
+         y += y_step;
+         uint32_t ty = y >> NN_SHIFT;
+         in_ptr += (ty - oy) * in_stride;
+         out_ptr = optrtmp1 + out_stride;
+         oy      = ty;
+      } while (--dh);
+   }
+}
+
+/* Clear border x3 screens for framebuffer (rotate180) */
+static void sdl_miyoomini_clear_border(void* buf, unsigned x, unsigned y, unsigned w, unsigned h) {
+   if ( (x == 0) && (y == 0) && (w == res_x) && (h == res_y) ) return;
+   if ( (w == 0) || (h == 0) ) { memset(buf, 0, res_x * res_y * sizeof(uint32_t) * 3); return; }
+
+   uint32_t x0 = res_x - (x + w); /* left margin , right margin = x */
+   uint32_t y0 = res_y - (y + h); /* top margin , bottom margin = y */
+   uint32_t sl = x0 * sizeof(uint32_t); /* left buffer size */
+   uint32_t sr = x * sizeof(uint32_t); /* right buffer size */
+   uint32_t st = y0 * res_x * sizeof(uint32_t); /* top buffer size */
+   uint32_t sb = y * res_x * sizeof(uint32_t); /* bottom buffer size */
+   uint32_t srl = sr + sl;
+   uint32_t stl = st + sl;
+   uint32_t srb = sr + sb;
+   uint32_t srbtl = srl + sb + st;
+   uint32_t sw = w * sizeof(uint32_t); /* pitch */
+   uint32_t ss = res_x * sizeof(uint32_t); /* stride */
+   uint32_t i;
+
+   if (stl) memset(buf, 0, stl); /* 1st top + 1st left */
+   buf += stl + sw;
+   for (i=h-1; i>0; i--, buf += ss) {
+      if (srl) memset(buf, 0, srl); /* right + left */
+   }
+   if (srbtl) memset(buf, 0, srbtl); /* last right + bottom + top + 1st left */
+   buf += srbtl + sw;
+   for (i=h-1; i>0; i--, buf += ss) {
+      if (srl) memset(buf, 0, srl); /* right + left */
+   }
+   if (srbtl) memset(buf, 0, srbtl); /* last right + bottom + top + 1st left */
+   buf += srbtl + sw;
+   for (i=h-1; i>0; i--, buf += ss) {
+      if (srl) memset(buf, 0, srl); /* right + left */
+   }
+   if (srb) memset(buf, 0, srb); /* last right + last bottom */
+}
+
+static FILE *__get_cpuclock_file(void)
+{
+   FILE *fp = NULL;
+   char config_directory[PATH_MAX_LENGTH];
+   char cpuclock_config_path[PATH_MAX_LENGTH];
+   rarch_system_info_t *system = &runloop_state_get_ptr()->system;
+   const char *core_name = system ? system->info.library_name : NULL;
+
+   if (!string_is_empty(core_name)) {
+      /* Get base config directory */
+      fill_pathname_application_special(config_directory, sizeof(config_directory), APPLICATION_SPECIAL_DIRECTORY_CONFIG);
+
+      // Get core config path for cpuclock.txt
+      fill_pathname_join_special_ext(cpuclock_config_path, config_directory, core_name, "cpuclock", ".txt", PATH_MAX_LENGTH);
+
+      fp = fopen(cpuclock_config_path, "r");
+      RARCH_LOG("[CPU]: Path %s: %s\n", fp ? "found" : "not found", cpuclock_config_path);
+   }
+   
+   if (!fp) {
+      fp = fopen("/proc/self/cwd/cpuclock.txt", "r");
+      RARCH_LOG("[CPU]: Path %s: ./cpuclock.txt\n", fp ? "found" : "not found");
+   }
+
+   return fp;
+}
+
+/* Set cpuclock */
+#define	BASE_REG_RIU_PA		(0x1F000000)
+#define	BASE_REG_MPLL_PA	(BASE_REG_RIU_PA + 0x103000*2)
+#define	PLL_SIZE		(0x1000)
+static void set_cpuclock(int clock) {
+	sync();
+	int fd_mem = open("/dev/mem", O_RDWR);
+	void* pll_map = mmap(0, PLL_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, fd_mem, BASE_REG_MPLL_PA);
+
+	uint32_t post_div;
+	if (clock >= 800000) post_div = 2;
+	else if (clock >= 400000) post_div = 4;
+	else if (clock >= 200000) post_div = 8;
+	else post_div = 16;
+
+	static const uint64_t divsrc = 432000000llu * 524288;
+	uint32_t rate = (clock * 1000)/16 * post_div / 2;
+	uint32_t lpf = (uint32_t)(divsrc / rate);
+	volatile uint16_t* p16 = (uint16_t*)pll_map;
+
+	uint32_t cur_post_div = (p16[0x232] & 0x0F) + 1;
+	uint32_t tmp_post_div = cur_post_div;
+	if (post_div > cur_post_div) {
+		while (tmp_post_div != post_div) {
+			tmp_post_div <<= 1;
+			p16[0x232] = (p16[0x232] & 0xF0) | ((tmp_post_div-1) & 0x0F);
+		}
+	}
+
+	p16[0x2A8] = 0x0000;
+	p16[0x2AE] = 0x000F;
+	p16[0x2A4] = lpf&0xFFFF;
+	p16[0x2A6] = lpf>>16;
+	p16[0x2B0] = 0x0001;
+	p16[0x2B2] |= 0x1000;
+	p16[0x2A8] = 0x0001;
+	while( !(p16[0x2BA]&1) );
+	p16[0x2A0] = lpf&0xFFFF;
+	p16[0x2A2] = lpf>>16;
+
+	if (post_div < cur_post_div) {
+		while (tmp_post_div != post_div) {
+			tmp_post_div >>= 1;
+			p16[0x232] = (p16[0x232] & 0xF0) | ((tmp_post_div-1) & 0x0F);
+		}
+	}
+
+	munmap(pll_map, PLL_SIZE);
+	close(fd_mem);
+}
+
+/* Set CPU governor */
+enum cpugov { PERFORMANCE = 0, POWERSAVE = 1, ONDEMAND = 2, USERSPACE = 3 };
+static void sdl_miyoomini_set_cpugovernor(enum cpugov gov) {
+   const char govstr[4][12] = { "performance", "powersave", "ondemand", "userspace" };
+   const char fn_min_freq[] = "/sys/devices/system/cpu/cpufreq/policy0/scaling_min_freq";
+   const char fn_governor[] = "/sys/devices/system/cpu/cpufreq/policy0/scaling_governor";
+   const char fn_setspeed[] = "/sys/devices/system/cpu/cpufreq/policy0/scaling_setspeed";
+   static uint32_t minfreq = 0;
+   FILE* fp;
+
+   if (!minfreq) {
+      /* save min_freq */
+      fp = fopen(fn_min_freq, "r");
+      if (fp) { fscanf(fp, "%d", &minfreq); fclose(fp); }
+      /* set min_freq to lowest */
+      fp = fopen(fn_min_freq, "w");
+      if (fp) { fprintf(fp, "%d", 0); fclose(fp); }
+   }
+
+   if (gov == ONDEMAND) {
+      /* revert min_freq */
+      fp = fopen(fn_min_freq, "w");
+      if (fp) { fprintf(fp, "%d", minfreq); fclose(fp); }
+      minfreq = 0;
+   }
+
+   /* set cpu clock to value in cpuclock.txt */
+   if (gov == PERFORMANCE) {
+      fp = __get_cpuclock_file();
+      if (fp) {
+         int cpuclock = 0;
+         fscanf(fp, "%d", &cpuclock); fclose(fp);
+         if ((cpuclock >= 100)&&(cpuclock <= 2400)) {
+            fp = fopen(fn_governor, "w");
+            if (fp) { fwrite(govstr[USERSPACE], 1, strlen(govstr[USERSPACE]), fp); fclose(fp); }
+            fp = fopen(fn_setspeed, "w");
+            if (fp) { fprintf(fp, "%d", cpuclock * 1000); fclose(fp); }
+            set_cpuclock(cpuclock * 1000);
+            RARCH_LOG("[CPU]: Set clock: %d MHz\n", cpuclock);
+            return;
+         }
+      }
+   }
+
+   /* set governor */
+   fp = fopen(fn_governor, "w");
+   if (fp) { fwrite(govstr[gov], 1, strlen(govstr[gov]), fp); fclose(fp); }
+}
+
+static void sdl_miyoomini_toggle_powersave(bool state) {
+   sdl_miyoomini_set_cpugovernor(state ? POWERSAVE : PERFORMANCE);
+}
+
+static void sdl_miyoomini_sighandler(int sig) {
+   switch (sig) {
+   case SIGSTOP:
+      sdl_miyoomini_toggle_powersave(true);
+      break;
+   case SIGCONT:
+      sdl_miyoomini_toggle_powersave(false);
+      break;
+   default:
+      break;
+   }
+}
+
+static void sdl_miyoomini_init_font_color(sdl_miyoomini_video_t *vid) {
+   settings_t *settings = config_get_ptr();
+   uint32_t red         = 0xFF;
+   uint32_t green       = 0xFF;
+   uint32_t blue        = 0xFF;
+
+   if (settings) {
+      red   = (uint32_t)((settings->floats.video_msg_color_r * 255.0f) + 0.5f) & 0xFF;
+      green = (uint32_t)((settings->floats.video_msg_color_g * 255.0f) + 0.5f) & 0xFF;
+      blue  = (uint32_t)((settings->floats.video_msg_color_b * 255.0f) + 0.5f) & 0xFF;
+   }
+
+   /* Convert to XRGB8888 */
+   vid->font_colour32 = (red << 16) | (green << 8) | blue;
+}
+
+static void sdl_miyoomini_gfx_free(void *data) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   if (GFX_GetFlipCallback()) {
+      GFX_SetFlipCallback(NULL, NULL); usleep(0x2000); /* wait for finish callback */
+   }
+   GFX_WaitAllDone();
+   if (vid->screen) GFX_FreeSurface(vid->screen);
+   if (vid->menuscreen) GFX_FreeSurface(vid->menuscreen);
+   if (vid->menuscreen_rgui) GFX_FreeSurface(vid->menuscreen_rgui);
+#ifdef HAVE_OVERLAY
+   if (vid->overlay_surface) { GFX_SetupOverlaySurface(NULL); GFX_FreeSurface(vid->overlay_surface); }
+#endif
+   GFX_Quit();
+
+   if (vid->osd_font) bitmapfont_free_lut(vid->osd_font);
+
+   free(vid);
+
+   sdl_miyoomini_set_cpugovernor(ONDEMAND);
+}
+
+static void sdl_miyoomini_input_driver_init(
+      const char *input_drv_name, const char *joypad_drv_name,
+      input_driver_t **input, void **input_data) {
+   /* Sanity check */
+   if (!input || !input_data) return;
+
+   *input      = NULL;
+   *input_data = NULL;
+
+   /* If input driver name is empty, cannot
+    * initialise anything... */
+   if (string_is_empty(input_drv_name)) return;
+
+   signal(SIGSTOP, sdl_miyoomini_sighandler);
+   signal(SIGCONT, sdl_miyoomini_sighandler);
+
+   if (string_is_equal(input_drv_name, "sdl_dingux")) {
+      *input_data = input_driver_init_wrap(&input_sdl_dingux,
+            joypad_drv_name);
+      if (*input_data) *input = &input_sdl_dingux;
+      return;
+   }
+
+#if defined(HAVE_SDL) || defined(HAVE_SDL2)
+   if (string_is_equal(input_drv_name, "sdl")) {
+      *input_data = input_driver_init_wrap(&input_sdl,
+            joypad_drv_name);
+      if (*input_data) *input = &input_sdl;
+      return;
+   }
+#endif
+
+#if defined(HAVE_UDEV)
+   if (string_is_equal(input_drv_name, "udev")) {
+      *input_data = input_driver_init_wrap(&input_udev,
+            joypad_drv_name);
+      if (*input_data) *input = &input_udev;
+      return;
+   }
+#endif
+
+#if defined(__linux__)
+   if (string_is_equal(input_drv_name, "linuxraw")) {
+      *input_data = input_driver_init_wrap(&input_linuxraw,
+            joypad_drv_name);
+      if (*input_data) *input = &input_linuxraw;
+      return;
+   }
+#endif
+}
+
+static void sdl_miyoomini_set_output(sdl_miyoomini_video_t* vid, unsigned width, unsigned height, bool rgb32) {
+   vid->content_width  = width;
+   vid->content_height = height;
+   if (vid->rotate & 1) { width = vid->content_height; height = vid->content_width; }
+
+   /* Calculate scaling factor */
+   uint32_t xmul = (res_x<<16) / width;
+   uint32_t ymul = (res_y<<16) / height;
+   uint32_t mul_int = (xmul < ymul ? xmul : ymul)>>16;
+   /* Change to aspect/fullscreen scaler when integer & screen size is over (no crop) */
+   if (vid->scale_integer && mul_int) {
+      /* Integer Scaling */
+      vid->video_w = width * mul_int;
+      vid->video_h = height * mul_int;
+      if (!vid->keep_aspect) {
+         if(!(width == res_x && height == res_y)) {
+            /* Integer + Fullscreen , keep 4:3 for CRT console emulators */
+            uint32_t Wx3 = vid->video_w * 3;
+            uint32_t Hx4 = vid->video_h * 4;
+            if (Wx3 != Hx4) {
+               if (Wx3 > Hx4) vid->video_h = Wx3 / 4;
+               else           vid->video_w = Hx4 / 3;
+            }
+         }
+      }
+      vid->video_x = (res_x - vid->video_w) >> 1;
+      vid->video_y = (res_y - vid->video_h) >> 1;
+   } else if (vid->keep_aspect) {
+      /* Aspect Scaling */
+      if (xmul > ymul) {
+         vid->video_w  = (width * res_y) / height;
+         vid->video_h = res_y;
+         vid->video_x = (res_x - vid->video_w) >> 1;
+         vid->video_y = 0;
+      } else {
+         vid->video_w  = res_x;
+         vid->video_h = (height * res_x) / width;
+         vid->video_x = 0;
+         vid->video_y = (res_y - vid->video_h) >> 1;
+      }
+   } else {
+      /* Fullscreen */
+      vid->video_w = res_x;
+      vid->video_h = res_y;
+      vid->video_x = 0;
+      vid->video_y = 0;
+   }
+   /* align to x4 bytes */
+   if (!rgb32) { vid->video_x &= ~1; vid->video_w &= ~1; }
+
+   /* Select scaler to use */
+   uint32_t scale_xmul = 0, scale_ymul = 0;
+   if ( (vid->filter_type != DINGUX_IPU_FILTER_NEAREST) || (vid->scale_integer && mul_int && vid->keep_aspect) ) {
+      scale_xmul = scale_ymul = 1;
+      if ( (vid->scale_integer) || (vid->filter_type == DINGUX_IPU_FILTER_BICUBIC) ) {
+         // to be at least 80% of the post-scaling size
+         scale_xmul = ((vid->video_w<<2)/5 / width) +1;
+         scale_ymul = ((vid->video_h<<2)/5 / height) +1;
+         if ((scale_xmul == 3)||(scale_xmul > 4)) scale_xmul = 4; // 4x scaler is faster than 3x
+         if (scale_ymul > 4) scale_ymul = 4;
+      }
+   }
+   vid->frame_width  = scale_xmul ? vid->content_width  * scale_xmul : vid->video_w;
+   vid->frame_height = scale_ymul ? vid->content_height * scale_ymul : vid->video_h;
+
+   static void (* const func[2][3][4])(void*, void* __restrict, void* __restrict, uint32_t, uint32_t, uint32_t, uint32_t) = {
+      { { &scale1x1_16, &scale1x2_16, &scale1x3_16, &scale1x4_16 },
+        { &scale2x1_16, &scale2x2_16, &scale2x3_16, &scale2x4_16 },
+        { &scale4x1_16, &scale4x2_16, &scale4x3_16, &scale4x4_16 } },
+      { { &scale1x1_32, &scale1x2_32, &scale1x3_32, &scale1x4_32 },
+        { &scale2x1_32, &scale2x2_32, &scale2x3_32, &scale2x4_32 },
+        { &scale4x1_32, &scale4x2_32, &scale4x3_32, &scale4x4_32 } }
+   };
+
+   if (!scale_xmul) {
+      vid->scale_func = rgb32 ? scalenn_32 : scalenn_16;
+   } else {
+      vid->scale_func = func[rgb32?1:0][(scale_xmul>2)?2:scale_xmul-1][scale_ymul-1];
+   }
+
+   //RARCH_LOG("[SCALE] cw:%d ch:%d fw:%d fh:%d x:%d y:%d w:%d h:%d xmul:%d ymul:%d\n",vid->content_width,vid->content_height,
+   //   vid->frame_width,vid->frame_height,vid->video_x,vid->video_y,vid->video_w,vid->video_h,scale_xmul,scale_ymul);
+
+   /* Attempt to change video mode */
+   GFX_WaitAllDone();
+   if (vid->screen) GFX_FreeSurface(vid->screen);
+   vid->screen = GFX_CreateRGBSurface(
+         0, vid->frame_width, vid->frame_height, rgb32 ? 32 : 16, 0, 0, 0, 0);
+
+   /* Check whether selected display mode is valid */
+   if (unlikely(!vid->screen)) RARCH_ERR("[MI_GFX]: Failed to init GFX surface\n");
+   /* Clear border */
+   else if (!vid->menu_active) sdl_miyoomini_clear_border(fb_addr, vid->video_x, vid->video_y, vid->video_w, vid->video_h);
+}
+
+static void *sdl_miyoomini_gfx_init(const video_info_t *video,
+      input_driver_t **input, void **input_data) {
+   sdl_miyoomini_video_t *vid                    = NULL;
+   uint32_t sdl_subsystem_flags                  = SDL_WasInit(0);
+   settings_t *settings                          = config_get_ptr();
+   const char *input_drv_name                 = settings->arrays.input_driver;
+   const char *joypad_drv_name                = settings->arrays.input_joypad_driver;
+
+   sdl_miyoomini_set_cpugovernor(PERFORMANCE);
+
+   if (access(NEW_RES_FILE_PATH, F_OK) == 0) {
+      RARCH_LOG("[MI_GFX]: 560p available, changing resolution\n");
+      system("/mnt/SDCARD/.tmp_update/script/change_resolution.sh 752x560");
+   }
+
+    int fb = open(FB_DEVICE_FILE_PATH, O_RDWR);
+    if (fb == -1) {
+        RARCH_ERR("Error opening framebuffer device");
+        return NULL;
+    }
+
+    struct fb_var_screeninfo vinfo;
+    if (ioctl(fb, FBIOGET_VSCREENINFO, &vinfo)) {
+        RARCH_ERR("Error reading variable information");
+        close(fb);
+        return NULL;
+    }
+
+   res_x = vinfo.xres;
+   res_y = vinfo.yres;
+   close(fb);
+
+   RARCH_LOG("[MI_GFX]: Resolution: %ux%u\n", res_x, res_y);
+
+   if (access(RGUI_MENU_STRETCH_FILE_PATH, F_OK) == 0 || (res_x == 640 && res_y == 480)){
+      RARCH_LOG("[MI_GFX]: Menu stretch disabled\n");
+      rgui_menu_stretch = false;
+   }
+
+   rgui_menu_dest_rect = (SDL_Rect){(res_x - RGUI_MENU_WIDTH * 2) / 2, (res_y - RGUI_MENU_HEIGHT * 2) / 2, RGUI_MENU_WIDTH * 2, RGUI_MENU_HEIGHT * 2};
+   /* Initialise graphics subsystem, if required */
+   if (sdl_subsystem_flags == 0) {
+      if (SDL_Init(SDL_INIT_VIDEO) < 0) return NULL;
+   } else if ((sdl_subsystem_flags & SDL_INIT_VIDEO) == 0) {
+      if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0) return NULL;
+   }
+
+   vid = (sdl_miyoomini_video_t*)calloc(1, sizeof(*vid));
+   if (!vid) return NULL;
+
+   GFX_Init();
+
+   vid->menuscreen = GFX_CreateRGBSurface(
+         0, res_x, res_y, 16, 0, 0, 0, 0);
+   vid->menuscreen_rgui = GFX_CreateRGBSurface(
+         0, RGUI_MENU_WIDTH, RGUI_MENU_HEIGHT, 16, 0, 0, 0, 0);
+
+   if (!vid->menuscreen||!vid->menuscreen_rgui) {
+      RARCH_ERR("[MI_GFX]: Failed to init GFX surface\n");
+      goto error;
+   }
+
+   vid->content_width     = res_x;
+   vid->content_height    = res_y;
+   vid->rgb32             = video->rgb32;
+   vid->vsync             = video->vsync;
+   vid->keep_aspect       = settings->bools.video_dingux_ipu_keep_aspect;
+   vid->scale_integer     = settings->bools.video_scale_integer;
+   vid->filter_type       = (enum dingux_ipu_filter_type)settings->uints.video_dingux_ipu_filter_type;
+   vid->menu_active       = false;
+   vid->was_in_menu       = false;
+   vid->quitting          = false;
+   vid->ff_frame_time_min = 16667;
+
+   sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+
+   GFX_SetFlipFlags(vid->vsync ? GFX_BLOCKING : 0);
+
+   sdl_miyoomini_input_driver_init(input_drv_name,
+         joypad_drv_name, input, input_data);
+
+   /* Initialise OSD font */
+   sdl_miyoomini_init_font_color(vid);
+
+   vid->osd_font = bitmapfont_get_lut();
+
+   if (!vid->osd_font ||
+       vid->osd_font->glyph_max <
+            (SDL_NUM_FONT_GLYPHS - 1)) {
+      RARCH_ERR("[SDL1]: Failed to init OSD font\n");
+      goto error;
+   }
+
+   return vid;
+
+error:
+   sdl_miyoomini_gfx_free(vid);
+   return NULL;
+}
+
+static bool sdl_miyoomini_gfx_frame(void *data, const void *frame,
+      unsigned width, unsigned height, uint64_t frame_count,
+      unsigned pitch, const char *msg, video_frame_info_t *video_info) {
+   sdl_miyoomini_video_t* vid = (sdl_miyoomini_video_t*)data;
+
+   /* Return early if:
+    * - Input sdl_miyoomini_video_t struct is NULL
+    *   (cannot realistically happen)
+    * - Menu is inactive and input 'content' frame
+    *   data is NULL (may happen when e.g. a running
+    *   core skips a frame) */
+   if (unlikely(!vid || (!frame && !vid->menu_active))) return true;
+
+   /* If fast forward is currently active, we may
+    * push frames at an 'unlimited' rate. Since the
+    * display has a fixed refresh rate of 60 Hz, this
+    * represents wasted effort. We therefore drop any
+    * 'excess' frames in this case.
+    * (Note that we *only* do this when fast forwarding.
+    * Attempting this trick while running content normally
+    * will cause bad frame pacing) */
+   if (unlikely(video_info->input_driver_nonblock_state)) {
+      retro_time_t current_time = cpu_features_get_time_usec();
+
+      if ((current_time - vid->last_frame_time) < vid->ff_frame_time_min)
+         return true;
+
+      vid->last_frame_time = current_time;
+   }
+
+#ifdef HAVE_MENU
+   menu_driver_frame(video_info->menu_is_alive, video_info);
+#endif
+
+   /* Render OSD text at flip */
+   if (msg) {
+      memcpy(vid->msg_tmp, msg, sizeof(vid->msg_tmp));
+      GFX_SetFlipCallback(sdl_miyoomini_print_msg, vid);
+   } else if (vid->msg_count) {
+      vid->msg_tmp[0] = 0;
+      GFX_SetFlipCallback(sdl_miyoomini_print_msg, vid);
+   } else {
+      GFX_SetFlipCallback(NULL, NULL);
+   }
+
+   if (likely(!vid->menu_active)) {
+      /* Clear border if we were in the menu on the previous frame */
+      if (unlikely(vid->was_in_menu)) {
+         sdl_miyoomini_clear_border(fb_addr, vid->video_x, vid->video_y, vid->video_w, vid->video_h);
+         vid->was_in_menu = false;
+      }
+      /* Update video mode if width/height have changed */
+      if (unlikely( (vid->content_width  != width ) ||
+                    (vid->content_height != height) )) {
+         sdl_miyoomini_set_output(vid, width, height, vid->rgb32);
+      }
+      /* WaitAllDone to make sure the most recent frame is drawn complete */
+      MI_GFX_WaitAllDone(FALSE, flipFence);
+      /* SW Blit frame to GFX surface with scaling */
+      vid->scale_func(vid, (void*)frame, vid->screen->pixels, width, height, pitch, vid->screen->pitch);
+      /* HW Blit GFX surface to Framebuffer and Flip */
+      GFX_UpdateRect(vid->screen, vid->video_x, vid->video_y, vid->video_w, vid->video_h);
+   } else {
+      SDL_SoftStretch(vid->menuscreen_rgui, NULL, vid->menuscreen, rgui_menu_stretch ? NULL : &rgui_menu_dest_rect);
+      stOpt.eRotate = E_MI_GFX_ROTATE_180;
+      GFX_Flip(vid->menuscreen);
+      stOpt.eRotate = vid->rotate;
+   }
+   return true;
+}
+
+static void sdl_miyoomini_set_texture_enable(void *data, bool state, bool full_screen) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   if (state == vid->menu_active) return;
+   vid->menu_active = state;
+
+   sdl_miyoomini_toggle_powersave(state);
+
+   if (state) {
+      system("playActivity stop_all &");
+      vid->was_in_menu = true;
+   }
+   else {
+      system("playActivity resume &");
+   }
+}
+
+static void sdl_miyoomini_set_texture_frame(void *data, const void *frame, bool rgb32,
+      unsigned width, unsigned height, float alpha) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+
+   if (unlikely( !vid || rgb32 || (width != RGUI_MENU_WIDTH) || (height != RGUI_MENU_HEIGHT))) return;
+
+   memcpy_neon(vid->menuscreen_rgui->pixels, (void*)frame,
+      RGUI_MENU_WIDTH * RGUI_MENU_HEIGHT * sizeof(uint16_t));
+}
+
+static void sdl_miyoomini_gfx_set_nonblock_state(void *data, bool toggle,
+      bool adaptive_vsync_enabled, unsigned swap_interval) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   bool vsync            = !toggle;
+
+   /* Check whether vsync status has changed */
+   if (vid->vsync != vsync)
+   {
+      vid->vsync              = vsync;
+      GFX_SetFlipFlags(vsync ? GFX_BLOCKING : 0);
+   }
+}
+
+static void sdl_miyoomini_gfx_check_window(sdl_miyoomini_video_t *vid) {
+   SDL_Event event;
+
+   SDL_PumpEvents();
+   while (SDL_PeepEvents(&event, 1, SDL_GETEVENT, SDL_QUITMASK))
+   {
+      if (event.type != SDL_QUIT)
+         continue;
+
+      vid->quitting = true;
+      sdl_miyoomini_set_cpugovernor(ONDEMAND);
+      break;
+   }
+}
+
+static bool sdl_miyoomini_gfx_alive(void *data) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return false;
+
+   sdl_miyoomini_gfx_check_window(vid);
+   return !vid->quitting;
+}
+
+static bool sdl_miyoomini_gfx_focus(void *data) { return true; }
+static bool sdl_miyoomini_gfx_suppress_screensaver(void *data, bool enable) { return false; }
+static bool sdl_miyoomini_gfx_has_windowed(void *data) { return false; }
+
+static void sdl_miyoomini_gfx_set_rotation(void *data, unsigned rotation) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+   switch (rotation) {
+      case 1:
+         stOpt.eRotate = E_MI_GFX_ROTATE_90; break;
+      case 2:
+         stOpt.eRotate = E_MI_GFX_ROTATE_0; break;
+      case 3:
+         stOpt.eRotate = E_MI_GFX_ROTATE_270; break;
+      default:
+         stOpt.eRotate = E_MI_GFX_ROTATE_180; break;
+   }
+   if (vid->rotate != stOpt.eRotate) {
+      vid->rotate = stOpt.eRotate;
+      sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+   }
+}
+
+static void sdl_miyoomini_gfx_viewport_info(void *data, struct video_viewport *vp) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   vp->x = vp->y = 0;
+   vp->width  = vp->full_width  = vid->content_width;
+   vp->height = vp->full_height = vid->content_height;
+}
+
+static float sdl_miyoomini_get_refresh_rate(void *data) { return 60.0f; }
+
+static void sdl_miyoomini_set_filtering(void *data, unsigned index, bool smooth, bool ctx_scaling) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   settings_t *settings       = config_get_ptr();
+   if (unlikely(!vid || !settings)) return;
+
+   enum dingux_ipu_filter_type ipu_filter_type = (settings) ?
+         (enum dingux_ipu_filter_type)settings->uints.video_dingux_ipu_filter_type :
+         DINGUX_IPU_FILTER_BICUBIC;
+
+   /* Update software filter setting, if required */
+   if (vid->filter_type != ipu_filter_type) {
+      vid->filter_type = ipu_filter_type;
+      sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+   }
+}
+
+static void sdl_miyoomini_apply_state_changes(void *data) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   settings_t *settings       = config_get_ptr();
+   if (unlikely(!vid || !settings)) return;
+
+   bool keep_aspect       = (settings) ? settings->bools.video_dingux_ipu_keep_aspect : true;
+   bool integer_scaling   = (settings) ? settings->bools.video_scale_integer : false;
+
+   if ((vid->keep_aspect != keep_aspect) ||
+       (vid->scale_integer != integer_scaling)) {
+      vid->keep_aspect   = keep_aspect;
+      vid->scale_integer = integer_scaling;
+
+      /* Aspect/scaling changes require all frame
+       * dimension/padding/cropping parameters to
+       * be recalculated. Easiest method is to just
+       * (re-)set the current output video mode */
+      sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+   }
+}
+
+static uint32_t sdl_miyoomini_get_flags(void *data) { return 0; }
+
+static const video_poke_interface_t sdl_miyoomini_poke_interface = {
+   sdl_miyoomini_get_flags,
+   NULL, /* load_texture */
+   NULL, /* unload_texture */
+   NULL, /* set_video_mode */
+   sdl_miyoomini_get_refresh_rate,
+   sdl_miyoomini_set_filtering,
+   NULL, /* get_video_output_size */
+   NULL, /* get_video_output_prev */
+   NULL, /* get_video_output_next */
+   NULL, /* get_current_framebuffer */
+   NULL, /* get_proc_address */
+   NULL, /* set_aspect_ratio */
+   sdl_miyoomini_apply_state_changes,
+   sdl_miyoomini_set_texture_frame,
+   sdl_miyoomini_set_texture_enable,
+   NULL, /* set_osd_msg */
+   NULL, /* sdl_show_mouse */
+   NULL, /* sdl_grab_mouse_toggle */
+   NULL, /* get_current_shader */
+   NULL, /* get_current_software_framebuffer */
+   NULL, /* get_hw_render_interface */
+   NULL, /* set_hdr_max_nits */
+   NULL, /* set_hdr_paper_white_nits */
+   NULL, /* set_hdr_contrast */
+   NULL  /* set_hdr_expand_gamut */
+};
+
+static void sdl_miyoomini_get_poke_interface(void *data, const video_poke_interface_t **iface) {
+   *iface = &sdl_miyoomini_poke_interface;
+}
+
+static bool sdl_miyoomini_gfx_set_shader(void *data,
+      enum rarch_shader_type type, const char *path) { return false; }
+
+#ifdef HAVE_OVERLAY
+
+static void sdl_miyoomini_overlay_enable(void *data, bool state) {
+	sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t *)data;
+	if (!vid) return;
+
+	if ((state)&&(vid->overlay_surface)) GFX_SetupOverlaySurface(vid->overlay_surface);
+	else GFX_SetupOverlaySurface(NULL);
+}
+
+static bool sdl_miyoomini_overlay_load(void *data, const void *image_data, unsigned num_images) {
+	sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t *)data;
+	if (!vid) return false;
+
+	struct texture_image *images = (struct texture_image *)image_data;
+	void* pixels = images[0].pixels;
+	uint32_t width = images[0].width;
+	uint32_t height = images[0].height;
+
+	if (vid->overlay_surface) GFX_FreeSurface(vid->overlay_surface);
+	SDL_Surface *ostmp = SDL_CreateRGBSurfaceFrom(pixels, width, height, 32, width*4,
+				0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
+	SDL_Surface *ostmp2 = GFX_DuplicateSurface(ostmp);
+	SDL_FreeSurface(ostmp);
+	vid->overlay_surface = GFX_CreateRGBSurface(0, res_x, res_y, 32,
+				0x00FF0000, 0x0000FF00, 0x000000FF, 0xFF000000);
+	ostmp2->flags &= ~SDL_SRCALPHA;
+	GFX_BlitSurfaceRotate(ostmp2, NULL, vid->overlay_surface, NULL, 2);
+	GFX_FreeSurface(ostmp2);
+
+	settings_t *settings = config_get_ptr();
+	vid->overlay_surface->flags |= SDL_SRCALPHA;
+	vid->overlay_surface->format->alpha = (settings) ? settings->floats.input_overlay_opacity * 0xFF : 255;
+	GFX_SetupOverlaySurface(vid->overlay_surface);
+
+	return true;
+}
+
+static void sdl_miyoomini_overlay_tex_geom(void *data, unsigned idx, float x, float y, float w, float h) { }
+static void sdl_miyoomini_overlay_vertex_geom(void *data, unsigned idx, float x, float y, float w, float h) { }
+static void sdl_miyoomini_overlay_full_screen(void *data, bool enable) { }
+
+static void sdl_miyoomini_overlay_set_alpha(void *data, unsigned idx, float mod) {
+	sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t *)data;
+	if ((!idx)&&(vid)&&(vid->overlay_surface)) {
+		uint8_t value = mod * 0xFF;
+		if (!(vid->overlay_surface->flags & SDL_SRCALPHA)||(vid->overlay_surface->format->alpha != value)) {
+			vid->overlay_surface->format->alpha = value;
+			GFX_SetupOverlaySurface(vid->overlay_surface);
+		}
+	}
+	return;
+}
+
+static const video_overlay_interface_t sdl_miyoomini_overlay = {
+	sdl_miyoomini_overlay_enable,
+	sdl_miyoomini_overlay_load,
+	sdl_miyoomini_overlay_tex_geom,
+	sdl_miyoomini_overlay_vertex_geom,
+	sdl_miyoomini_overlay_full_screen,
+	sdl_miyoomini_overlay_set_alpha,
+};
+
+void sdl_miyoomini_gfx_get_overlay_interface(void *data, const video_overlay_interface_t **iface)
+{
+    sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t *)data;
+    if (!vid) return;
+    *iface = &sdl_miyoomini_overlay;
+}
+
+#endif
+
+video_driver_t video_sdl_dingux = {
+   sdl_miyoomini_gfx_init,
+   sdl_miyoomini_gfx_frame,
+   sdl_miyoomini_gfx_set_nonblock_state,
+   sdl_miyoomini_gfx_alive,
+   sdl_miyoomini_gfx_focus,
+   sdl_miyoomini_gfx_suppress_screensaver,
+   sdl_miyoomini_gfx_has_windowed,
+   sdl_miyoomini_gfx_set_shader,
+   sdl_miyoomini_gfx_free,
+   "sdl_dingux",
+   NULL, /* set_viewport */
+   sdl_miyoomini_gfx_set_rotation,
+   sdl_miyoomini_gfx_viewport_info,
+   NULL, /* read_viewport  */
+   NULL, /* read_frame_raw */
+#ifdef HAVE_OVERLAY
+   sdl_miyoomini_gfx_get_overlay_interface,
+#endif
+   sdl_miyoomini_get_poke_interface
+};
diff --git a/gfx/drivers/sdl_dingux_gfx.c b/gfx/drivers/sdl_dingux_gfx.c
index 5b710e887d..bf0fff79df 100644
--- a/gfx/drivers/sdl_dingux_gfx.c
+++ b/gfx/drivers/sdl_dingux_gfx.c
@@ -15,6 +15,9 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "miyoomini/sdl_miyoomini_gfx.c"
+#else
 
 #include <stdlib.h>
 #include <string.h>
@@ -1143,3 +1146,4 @@ video_driver_t video_sdl_dingux = {
 #endif
    sdl_dingux_get_poke_interface
 };
+#endif
diff --git a/gfx/drivers_font_renderer/bitmapfont_6x10.c b/gfx/drivers_font_renderer/bitmapfont_6x10.c
index c0974a86e0..d5cb51438a 100644
--- a/gfx/drivers_font_renderer/bitmapfont_6x10.c
+++ b/gfx/drivers_font_renderer/bitmapfont_6x10.c
@@ -45,6 +45,11 @@
 #define FONT_6X10_GLYPH_MIN_LSE 0x100
 #define FONT_6X10_GLYPH_MAX_LSE 0x24F
 
+#define FONT_6X10_FILE_RUS "bitmap6x10_rus.bin"
+#define FONT_6X10_SIZE_RUS 2432
+#define FONT_6X10_GLYPH_MIN_RUS 0x400
+#define FONT_6X10_GLYPH_MAX_RUS 0x45F
+
 /* Loads a font of the specified language
  * Returns NULL if language is invalid or
  * font file is missing */
@@ -75,7 +80,13 @@ bitmapfont_lut_t *bitmapfont_6x10_load(unsigned language)
 	      glyph_min = FONT_6X10_GLYPH_MIN_ENG;
 	      glyph_max = FONT_6X10_GLYPH_MAX_ENG;
 	      break;
-	      /* All Latin alphabet languages go here */
+	   case RETRO_LANGUAGE_RUSSIAN:
+        font_file = FONT_6X10_FILE_RUS;
+        font_size = FONT_6X10_SIZE_RUS;
+        glyph_min = FONT_6X10_GLYPH_MIN_RUS;
+        glyph_max = FONT_6X10_GLYPH_MAX_RUS;
+        break;
+	   /* All Latin alphabet languages go here */
 	   case RETRO_LANGUAGE_FRENCH:
 	   case RETRO_LANGUAGE_SPANISH:
 	   case RETRO_LANGUAGE_GERMAN:
diff --git a/gfx/video_filter.c b/gfx/video_filter.c
index 092a5d2a81..ea16e7a5f1 100644
--- a/gfx/video_filter.c
+++ b/gfx/video_filter.c
@@ -347,16 +347,19 @@ static bool append_softfilter_plugs(rarch_softfilter_t *filt,
       if (!filt->plugs[i].impl)
          return false;
    }
-
+ #if !defined(HAVE_DYLIB)
    return true;
 }
-#elif defined(HAVE_DYLIB)
+ #endif
+#endif
+#if defined(HAVE_DYLIB)
+ #if !defined(HAVE_FILTERS_BUILTIN)
 static bool append_softfilter_plugs(rarch_softfilter_t *filt,
       struct string_list *list)
 {
    unsigned i;
    softfilter_simd_mask_t mask = (softfilter_simd_mask_t)cpu_features_get();
-
+ #endif
    for (i = 0; i < list->size; i++)
    {
       softfilter_get_implementation_t cb;
@@ -409,7 +412,7 @@ static bool append_softfilter_plugs(rarch_softfilter_t *filt,
 
    return true;
 }
-#else
+#elif !defined(HAVE_FILTERS_BUILTIN)
 static bool append_softfilter_plugs(rarch_softfilter_t *filt,
       struct string_list *list)
 {
diff --git a/input/drivers_joypad/sdl_dingux_joypad.c b/input/drivers_joypad/sdl_dingux_joypad.c
index 543fe5b630..4a0e4ffd78 100644
--- a/input/drivers_joypad/sdl_dingux_joypad.c
+++ b/input/drivers_joypad/sdl_dingux_joypad.c
@@ -13,6 +13,9 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "sdl_miyoomini_joypad.c"
+#else
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -811,3 +814,4 @@ input_device_driver_t sdl_dingux_joypad = {
    sdl_dingux_joypad_name,
    "sdl_dingux",
 };
+#endif
diff --git a/input/drivers_joypad/sdl_miyoomini_joypad.c b/input/drivers_joypad/sdl_miyoomini_joypad.c
new file mode 100644
index 0000000000..0528946333
--- /dev/null
+++ b/input/drivers_joypad/sdl_miyoomini_joypad.c
@@ -0,0 +1,412 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2011-2020 - Daniel De Matteis
+ *  Copyright (C) 2019-2020 - James Leaver
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#include <SDL/SDL.h>
+
+#include <libretro.h>
+
+#include "../input_driver.h"
+#include "../../config.def.h"
+#include "../../tasks/tasks_internal.h"
+#include "../../verbosity.h"
+
+#include <unistd.h>
+#include <fcntl.h>
+
+/* Simple joypad driver designed to rationalise
+ * the bizarre keyboard/gamepad hybrid setup
+ * of OpenDingux devices, exclusive for miyoomini */
+
+#define SDL_MIYOOMINI_JOYPAD_NAME "Dingux Gamepad"
+
+/* Vibration time at 100% vibration strength */
+#define SDL_MIYOOMINI_RUMBLE_MS   200
+
+/* Uncomment if you want the MENU button to be used exclusively for MENU
+#define SDL_MIYOOMINI_HAS_MENU_TOGGLE
+*/
+/* Miyoomini input map to keyboard keys */
+#define SDL_MIYOOMINI_SDLK_X      SDLK_LSHIFT
+#define SDL_MIYOOMINI_SDLK_A      SDLK_SPACE
+#define SDL_MIYOOMINI_SDLK_B      SDLK_LCTRL
+#define SDL_MIYOOMINI_SDLK_Y      SDLK_LALT
+#define SDL_MIYOOMINI_SDLK_L      SDLK_e
+#define SDL_MIYOOMINI_SDLK_R      SDLK_t
+#define SDL_MIYOOMINI_SDLK_L2     SDLK_TAB
+#define SDL_MIYOOMINI_SDLK_R2     SDLK_BACKSPACE
+#define SDL_MIYOOMINI_SDLK_SELECT SDLK_RCTRL
+#define SDL_MIYOOMINI_SDLK_START  SDLK_RETURN
+#if (!defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE))
+#define SDL_MIYOOMINI_SDLK_L3     SDLK_ESCAPE    /* MENU */
+#define SDL_MIYOOMINI_SDLK_R3     SDLK_POWER     /* POWER */
+#else
+#define SDL_MIYOOMINI_SDLK_L3     SDLK_KP_DIVIDE /* no use */
+#define SDL_MIYOOMINI_SDLK_R3     SDLK_KP_PERIOD /* no use */
+#define SDL_MIYOOMINI_SDLK_MENU   SDLK_ESCAPE    /* MENU */
+#endif
+#define SDL_MIYOOMINI_SDLK_UP     SDLK_UP
+#define SDL_MIYOOMINI_SDLK_RIGHT  SDLK_RIGHT
+#define SDL_MIYOOMINI_SDLK_DOWN   SDLK_DOWN
+#define SDL_MIYOOMINI_SDLK_LEFT   SDLK_LEFT
+
+typedef struct {
+   uint16_t pad_state;
+   bool connected;
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   bool menu_toggle;
+#endif
+   uint32_t rumble_time;
+} miyoomini_joypad_t;
+
+static miyoomini_joypad_t miyoomini_joypad;
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+/* TODO/FIXME - global referenced outside */
+extern uint64_t lifecycle_state;
+#endif
+
+void miyoomini_rumble(uint16_t strength) {
+   static char lastvalue = 0;
+   const char str_export[2] = "48";
+   const char str_direction[3] = "out";
+   char value[1];
+   int fd;
+
+   value[0] = (strength == 0 ? 0x31 : 0x30);
+   if (lastvalue != value[0]) {
+      fd = open("/sys/class/gpio/export", O_WRONLY);
+      if (fd > 0) { write(fd, str_export, 2); close(fd); }
+      fd = open("/sys/class/gpio/gpio48/direction", O_WRONLY);
+      if (fd > 0) { write(fd, str_direction, 3); close(fd); }
+      fd = open("/sys/class/gpio/gpio48/value", O_WRONLY);
+      if (fd > 0) { write(fd, value, 1); close(fd); }
+      lastvalue = value[0];
+   }
+}
+
+uint32_t miyoomini_rumble_finish(uint32_t interval) {
+   miyoomini_rumble(0);
+   return 0;
+}
+
+static bool sdl_miyoomini_joypad_set_rumble(unsigned pad,
+      enum retro_rumble_effect effect, uint16_t strength) {
+   if (pad) return false;
+
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   if ( (joypad->rumble_time)&&(strength) ) {
+      miyoomini_rumble(strength);
+      SDL_SetTimer(joypad->rumble_time, miyoomini_rumble_finish);
+   }
+   return true;
+}
+
+static bool sdl_miyoomini_joypad_set_rumble_gain(unsigned pad, unsigned gain) {
+   if (pad != 0) return false;
+   if (gain > 100) gain = 100;
+
+   /* Set gain (actually rumble_time for miyoomini) */
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   joypad->rumble_time = SDL_MIYOOMINI_RUMBLE_MS * gain / 100;
+
+   return true;
+}
+
+static const char *sdl_miyoomini_joypad_name(unsigned port) {
+   if (port != 0) return NULL;
+   return SDL_MIYOOMINI_JOYPAD_NAME;
+}
+
+static void sdl_miyoomini_joypad_connect(void) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   /* 'Register' joypad connection via autoconfig task */
+   input_autoconfigure_connect(
+         sdl_miyoomini_joypad_name(0), /* name */
+         NULL,                         /* display_name */
+         sdl_dingux_joypad.ident,      /* driver */
+         0,                            /* port */
+         0,                            /* vid */
+         0);                           /* pid */
+
+   joypad->connected = true;
+}
+
+static void sdl_miyoomini_joypad_disconnect(void) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   if (joypad->connected)
+      input_autoconfigure_disconnect(0, sdl_dingux_joypad.ident);
+
+   memset(joypad, 0, sizeof(miyoomini_joypad_t));
+}
+
+static void sdl_miyoomini_joypad_destroy(void) {
+   SDL_Event event;
+
+   /* Disconnect joypad */
+   sdl_miyoomini_joypad_disconnect();
+
+   /* Stop rumble */
+   SDL_SetTimer(0, NULL);
+   miyoomini_rumble(0);
+
+   /* Flush out all pending events */
+   while (SDL_PollEvent(&event));
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   BIT64_CLEAR(lifecycle_state, RARCH_MENU_TOGGLE);
+#endif
+}
+
+static void *sdl_miyoomini_joypad_init(void *data) {
+   miyoomini_joypad_t *joypad      = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   memset(joypad, 0, sizeof(miyoomini_joypad_t));
+
+   /* Init for rumble */
+   if (!SDL_WasInit(SDL_INIT_TIMER)) SDL_InitSubSystem(SDL_INIT_TIMER);
+   settings_t *settings = config_get_ptr();
+   unsigned rumble_gain = settings ? settings->uints.input_rumble_gain
+                                   : DEFAULT_RUMBLE_GAIN;
+   sdl_miyoomini_joypad_set_rumble_gain(0, rumble_gain);
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   BIT64_CLEAR(lifecycle_state, RARCH_MENU_TOGGLE);
+#endif
+   /* Connect joypad */
+   sdl_miyoomini_joypad_connect();
+
+   return (void*)-1;
+}
+
+static bool sdl_miyoomini_joypad_query_pad(unsigned port) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   return (port == 0) && joypad->connected;
+}
+
+static int32_t sdl_miyoomini_joypad_button(unsigned port, uint16_t joykey) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   if (port != 0) return 0;
+   return (joypad->pad_state & (1 << joykey));
+}
+
+static void sdl_miyoomini_joypad_get_buttons(unsigned port, input_bits_t *state) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   /* Macros require braces here... */
+   if (port == 0) {
+      BITS_COPY16_PTR(state, joypad->pad_state);
+   } else {
+      BIT256_CLEAR_ALL_PTR(state);
+   }
+}
+
+static int16_t sdl_miyoomini_joypad_axis_state(unsigned port, uint32_t joyaxis) { return 0; }
+
+static int16_t sdl_miyoomini_joypad_axis(unsigned port, uint32_t joyaxis) {
+   if (port != 0) return 0;
+   return sdl_miyoomini_joypad_axis_state(port, joyaxis);
+}
+
+static int16_t sdl_miyoomini_joypad_state(
+      rarch_joypad_info_t *joypad_info,
+      const struct retro_keybind *binds,
+      unsigned port) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   uint16_t port_idx       = joypad_info->joy_idx;
+   int16_t ret             = 0;
+   size_t i;
+
+   if (port_idx != 0) return 0;
+
+   for (i = 0; i < RARCH_FIRST_CUSTOM_BIND; i++) {
+      /* Auto-binds are per joypad, not per user. */
+      const uint64_t joykey  = (binds[i].joykey != NO_BTN)
+         ? binds[i].joykey  : joypad_info->auto_binds[i].joykey;
+
+      if ((uint16_t)joykey != NO_BTN &&
+            (joypad->pad_state & (1 << (uint16_t)joykey)))
+         ret |= (1 << i);
+   }
+
+   return ret;
+}
+
+static void sdl_miyoomini_joypad_poll(void) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   SDL_Event event;
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   /* Note: The menu toggle key is an awkward special
+    * case - the press/release events happen almost
+    * instantaneously, and since we only sample once
+    * per frame the input is often 'missed'.
+    * If the toggle key gets pressed, we therefore have
+    * to wait until the *next* frame to release it */
+   if (joypad->menu_toggle) {
+      BIT64_CLEAR(lifecycle_state, RARCH_MENU_TOGGLE);
+      joypad->menu_toggle = false;
+   }
+#endif
+
+   /* All digital inputs map to keyboard keys */
+   while (SDL_PollEvent(&event))
+   {
+      switch (event.type)
+      {
+         case SDL_KEYDOWN:
+            switch (event.key.keysym.sym)
+            {
+               case SDL_MIYOOMINI_SDLK_X:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_X);
+                  break;
+               case SDL_MIYOOMINI_SDLK_A:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_A);
+                  break;
+               case SDL_MIYOOMINI_SDLK_B:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_B);
+                  break;
+               case SDL_MIYOOMINI_SDLK_Y:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_Y);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L2:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R2:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_SELECT:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_SELECT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_START:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_START);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L3:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R3:
+               case SDLK_UNKNOWN:	// for stockSDL POWER button
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_UP:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_UP);
+                  break;
+               case SDL_MIYOOMINI_SDLK_RIGHT:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_RIGHT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_DOWN:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_DOWN);
+                  break;
+               case SDL_MIYOOMINI_SDLK_LEFT:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_LEFT);
+                  break;
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+               case SDL_MIYOOMINI_SDLK_MENU:
+                  BIT64_SET(lifecycle_state, RARCH_MENU_TOGGLE);
+                  joypad->menu_toggle = true;
+                  break;
+#endif
+               default:
+                  break;
+            }
+            break;
+         case SDL_KEYUP:
+            switch (event.key.keysym.sym)
+            {
+               case SDL_MIYOOMINI_SDLK_X:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_X);
+                  break;
+               case SDL_MIYOOMINI_SDLK_A:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_A);
+                  break;
+               case SDL_MIYOOMINI_SDLK_B:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_B);
+                  break;
+               case SDL_MIYOOMINI_SDLK_Y:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_Y);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L2:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R2:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_SELECT:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_SELECT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_START:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_START);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L3:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R3:
+               case SDLK_UNKNOWN:	// for stockSDL POWER button
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_UP:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_UP);
+                  break;
+               case SDL_MIYOOMINI_SDLK_RIGHT:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_RIGHT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_DOWN:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_DOWN);
+                  break;
+               case SDL_MIYOOMINI_SDLK_LEFT:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_LEFT);
+                  break;
+               default:
+                  break;
+            }
+            break;
+         default:
+            break;
+      }
+   }
+
+}
+
+input_device_driver_t sdl_dingux_joypad = {
+   sdl_miyoomini_joypad_init,
+   sdl_miyoomini_joypad_query_pad,
+   sdl_miyoomini_joypad_destroy,
+   sdl_miyoomini_joypad_button,
+   sdl_miyoomini_joypad_state,
+   sdl_miyoomini_joypad_get_buttons,
+   sdl_miyoomini_joypad_axis,
+   sdl_miyoomini_joypad_poll,
+   sdl_miyoomini_joypad_set_rumble,
+   sdl_miyoomini_joypad_set_rumble_gain,
+   sdl_miyoomini_joypad_name,
+   "sdl_dingux",
+};
diff --git a/libretro-common/audio/conversion/float_to_s16.c b/libretro-common/audio/conversion/float_to_s16.c
index 770981d9c1..cbbd0908f7 100644
--- a/libretro-common/audio/conversion/float_to_s16.c
+++ b/libretro-common/audio/conversion/float_to_s16.c
@@ -32,12 +32,11 @@
 #include <audio/conversion/float_to_s16.h>
 
 #if (defined(__ARM_NEON__) || defined(HAVE_NEON))
+#include <arm_neon.h>
 static bool float_to_s16_neon_enabled = false;
 #ifdef HAVE_ARM_NEON_ASM_OPTIMIZATIONS
 void convert_float_s16_asm(int16_t *out,
       const float *in, size_t samples);
-#else
-#include <arm_neon.h>
 #endif
 
 void convert_float_to_s16(int16_t *out,
diff --git a/miyoomini.c b/miyoomini.c
new file mode 100644
index 0000000000..47b4427bf3
--- /dev/null
+++ b/miyoomini.c
@@ -0,0 +1,210 @@
+#if defined(MIYOOMINI)
+
+#include "miyoomini.h"
+#include "configuration.h"
+#include "file/config_file.h"
+#include "file_path_special.h"
+#include "gfx/video_driver.h"
+#include "paths.h"
+#include "runloop.h"
+#include "string/stdstring.h"
+#include "verbosity.h"
+#include <fcntl.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+static int res_x = 0, res_y = 0;
+
+/**
+ * @brief Displays an on-screen notification of the current scaling option.
+ *
+ * The 4 states are:
+ * 1. Integer scaling: OFF (Original) - resolution
+ * 2. Integer scaling: OFF (4:3) - resolution
+ * 3. Integer scaling: ON (Original) - resolution
+ * 4. Integer scaling: ON (4:3) - resolution
+ *
+ * @param settings
+ */
+static void show_miyoo_fullscreen_notification(settings_t *settings) {
+  char msg[PATH_MAX_LENGTH];
+  struct retro_message_ext msg_obj = {0};
+
+  msg[0] = '\0';
+
+  if (res_x == 0 || res_y == 0) {
+    const char *fb_device = "/dev/fb0";
+    int fb = open(fb_device, O_RDWR);
+
+    if (fb == -1) {
+      RARCH_ERR("Error opening framebuffer device");
+    } else {
+      struct fb_var_screeninfo vinfo;
+      if (ioctl(fb, FBIOGET_VSCREENINFO, &vinfo)) {
+        RARCH_ERR("Error reading variable information");
+        close(fb);
+      } else {
+        res_x = vinfo.xres;
+        res_y = vinfo.yres;
+      }
+    }
+  }
+
+  snprintf(msg, sizeof(msg), "Integer scaling: %s (%s) - %dx%d",
+           settings->bools.video_scale_integer ? "ON" : "OFF",
+           settings->bools.video_dingux_ipu_keep_aspect ? "Original" : "4:3",
+           res_x, res_y);
+
+  msg_obj.msg = msg;
+  msg_obj.duration = 1000;
+  msg_obj.priority = 3;
+  msg_obj.level = RETRO_LOG_INFO;
+  msg_obj.target = RETRO_MESSAGE_TARGET_ALL;
+  msg_obj.type = RETRO_MESSAGE_TYPE_STATUS;
+  msg_obj.progress = -1;
+
+  runloop_environment_cb(RETRO_ENVIRONMENT_SET_MESSAGE_EXT, &msg_obj);
+}
+
+/**
+ * @brief Get the override path for a specific type
+ *
+ * @param override_path Output parameter for override path
+ * @param type Override type
+ */
+static void get_override_path(char *override_path, enum override_type type) {
+  char config_directory[PATH_MAX_LENGTH];
+  char content_dir_name[PATH_MAX_LENGTH];
+  rarch_system_info_t *system = &runloop_state_get_ptr()->system;
+  const char *game_name = NULL;
+  const char *core_name = system ? system->info.library_name : NULL;
+  const char *rarch_path_basename = path_get(RARCH_PATH_BASENAME);
+  bool has_content = !string_is_empty(rarch_path_basename);
+
+  /* > Cannot save an override if we have no core
+   * > Cannot save a per-game or per-content-directory
+   *   override if we have no content */
+  if (string_is_empty(core_name) || (!has_content && type != OVERRIDE_CORE))
+    return;
+
+  /* Get base config directory */
+  fill_pathname_application_special(config_directory, sizeof(config_directory),
+                                    APPLICATION_SPECIAL_DIRECTORY_CONFIG);
+
+  switch (type) {
+  case OVERRIDE_CORE:
+    fill_pathname_join_special_ext(override_path, config_directory, core_name,
+                                   core_name, FILE_PATH_CONFIG_EXTENSION,
+                                   PATH_MAX_LENGTH);
+    break;
+  case OVERRIDE_GAME:
+    game_name = path_basename_nocompression(rarch_path_basename);
+    fill_pathname_join_special_ext(override_path, config_directory, core_name,
+                                   game_name, FILE_PATH_CONFIG_EXTENSION,
+                                   PATH_MAX_LENGTH);
+    break;
+  case OVERRIDE_CONTENT_DIR:
+    fill_pathname_parent_dir_name(content_dir_name, rarch_path_basename,
+                                  sizeof(content_dir_name));
+    fill_pathname_join_special_ext(override_path, config_directory, core_name,
+                                   content_dir_name, FILE_PATH_CONFIG_EXTENSION,
+                                   PATH_MAX_LENGTH);
+    break;
+  case OVERRIDE_NONE:
+  default:
+    break;
+  }
+}
+
+/**
+ * @brief Checks if a config override of [type] exists and contains either the
+ * "keep aspect" or "integer scaling" option
+ *
+ * @param override_path Override path
+ * @return true Config override contains scaling options - use it
+ * @return false Config override does not contain scaling options
+ */
+static bool check_config_has_scaling(const char *override_path) {
+  bool ret = false;
+  config_file_t *conf = NULL;
+
+  if ((conf = config_file_new_from_path_to_string(override_path))) {
+    ret = !!config_get_entry(conf, "video_dingux_ipu_keep_aspect") ||
+          !!config_get_entry(conf, "video_scale_integer");
+    config_file_free(conf);
+  }
+
+  return ret;
+}
+
+/**
+ * @brief Saves the "keep aspect" and "integer scaling" options as a config
+ * override.
+ *
+ * @param settings
+ * @return true Config override was saved successfully
+ * @return false Config override was not saved
+ */
+static bool write_core_override_aspect_scale(settings_t *settings) {
+  char override_path[PATH_MAX_LENGTH] = {0};
+  config_file_t *conf = NULL;
+
+  get_override_path(override_path, OVERRIDE_GAME);
+
+  if (!path_is_directory(override_path) ||
+      !check_config_has_scaling(override_path)) {
+    get_override_path(override_path, OVERRIDE_CONTENT_DIR);
+
+    if (!path_is_directory(override_path)) {
+      get_override_path(override_path, OVERRIDE_CORE);
+    }
+  }
+
+  if (string_is_empty(override_path))
+    return false;
+
+  // Use existing override file, if exists, or create new config file
+  if (!(conf = config_file_new_from_path_to_string(override_path)))
+    conf = config_file_new_alloc();
+
+  // Set the two overrides - leave everything else as-is
+  config_set_string(conf, "video_dingux_ipu_keep_aspect",
+                    (settings->bools.video_dingux_ipu_keep_aspect) ? "true"
+                                                                   : "false");
+
+  config_set_string(conf, "video_scale_integer",
+                    (settings->bools.video_scale_integer) ? "true" : "false");
+
+  // Write override file
+  bool ret = config_file_write(conf, override_path, false);
+  config_file_free(conf);
+
+  return ret;
+}
+
+/**
+ * @brief Toggle scaling options.
+ *
+ * The 4 states are:
+ * 1. Integer scaling: OFF (Original)
+ * 2. Integer scaling: OFF (4:3)
+ * 3. Integer scaling: ON (Original)
+ * 4. Integer scaling: ON (4:3)
+ *
+ * @param settings
+ */
+void miyoo_event_fullscreen_impl(settings_t *settings) {
+  settings->bools.video_dingux_ipu_keep_aspect =
+      !settings->bools.video_dingux_ipu_keep_aspect;
+  if (settings->bools.video_dingux_ipu_keep_aspect) {
+    settings->bools.video_scale_integer = !settings->bools.video_scale_integer;
+  }
+
+  video_driver_apply_state_changes();
+
+  show_miyoo_fullscreen_notification(settings);
+  write_core_override_aspect_scale(settings);
+}
+
+#endif
diff --git a/miyoomini.h b/miyoomini.h
new file mode 100644
index 0000000000..9dbf4bc836
--- /dev/null
+++ b/miyoomini.h
@@ -0,0 +1,9 @@
+#pragma once
+
+#if defined(MIYOOMINI)
+
+#include "configuration.h"
+
+void miyoo_event_fullscreen_impl(settings_t *settings);
+
+#endif
diff --git a/retroarch.c b/retroarch.c
index d28825d383..6bb120bd89 100644
--- a/retroarch.c
+++ b/retroarch.c
@@ -211,6 +211,10 @@
 #include "lakka.h"
 #endif
 
+#if defined(MIYOOMINI)
+#include "miyoomini.h"
+#endif
+
 #define _PSUPP(var, name, desc) printf("  %s:\n\t\t%s: %s\n", name, desc, var ? "yes" : "no")
 
 #define FAIL_CPU(simd_type) do { \
@@ -3757,6 +3761,9 @@ bool command_event(enum event_command cmd, void *data)
          return false;
 #endif
       case CMD_EVENT_FULLSCREEN_TOGGLE:
+#if defined(MIYOOMINI)
+         miyoo_event_fullscreen_impl(settings);
+#else
          {
             audio_driver_state_t
                *audio_st              = audio_state_get_ptr();
@@ -3808,6 +3815,7 @@ bool command_event(enum event_command cmd, void *data)
             if (userdata && *userdata == true)
                video_driver_cached_frame();
          }
+#endif
          break;
       case CMD_EVENT_DISK_APPEND_IMAGE:
          {
