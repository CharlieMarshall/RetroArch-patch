diff --git a/Makefile b/Makefile
index 4ec77cfab6..d960c4962b 100644
--- a/Makefile
+++ b/Makefile
@@ -1,201 +1,164 @@
-HAVE_FILE_LOGGER=1
-NEED_CXX_LINKER?=0
-NEED_GOLD_LINKER?=0
-MISSING_DECLS   =0
-
-ifneq ($(C90_BUILD),)
-   C89_BUILD=1
-endif
-
-include config.mk
-
-# Put your favorite compile flags in this file, if you want different defaults than upstream.
-# Do not attempt to create that file upstream.
-# (It'd be better to put this comment in that file, but .gitignore doesn't work on files that exist in the repo.)
--include Makefile.local
-
-ifeq ($(HAVE_ANGLE), 1)
-TARGET = retroarch_angle
-else
+#########################
+## Toolchain variables ##
+#########################
+
+# Default toolchain directory
+TOOLCHAIN_DIR=/opt/miyoomini83
+
+# All toolchain-related variables may be
+# overridden via the command line
+
+CC		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-gcc
+CXX		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-g++
+STRIP		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-strip
+
+SDL_CONFIG	?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/bin/sdl-config
+FREETYPE_CONFIG	?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/bin/freetype-config
+
+INC_DIR		?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/include
+LIB_DIR		?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/lib
+
+LTO		= -flto
+STRIP_BIN	= 1
+
+#########################
+#########################
+
+PACKAGE_NAME = retroarch
+
+DEBUG ?= 0
+
+MIYOOMINI = 1
+DINGUX = 1
+HAVE_SCREENSHOTS = 1
+HAVE_REWIND = 1
+HAVE_7ZIP = 1
+HAVE_AL = 0
+HAVE_ALSA = 0
+HAVE_DSP_FILTER = 1
+HAVE_VIDEO_FILTER = 1
+HAVE_STATIC_VIDEO_FILTERS = 1
+HAVE_STATIC_AUDIO_FILTERS = 1
+HAVE_FILTERS_BUILTIN	= 1
+HAVE_BUILTINMBEDTLS = 0
+HAVE_BUILTINZLIB = 1
+HAVE_C99 = 1
+HAVE_CC = 1
+#HAVE_CC_RESAMPLER = 1
+HAVE_CHD = 1
+HAVE_COMMAND = 0
+HAVE_CXX = 1
+HAVE_DR_MP3 = 1
+HAVE_DYNAMIC = 1
+HAVE_DYLIB = 1
+HAVE_EGL = 0
+HAVE_FREETYPE = 0
+HAVE_GDI = 1
+HAVE_GETADDRINFO = 0
+HAVE_GETOPT_LONG = 1
+HAVE_GLSL = 0
+HAVE_HID = 1
+HAVE_IBXM = 1
+HAVE_IMAGEVIEWER = 0
+HAVE_LANGEXTRA = 0
+HAVE_LIBRETRODB = 1
+HAVE_MENU = 1
+HAVE_MENU_COMMON = 1
+HAVE_GFX_WIDGETS = 0
+HAVE_MMAP = 1
+HAVE_OPENDINGUX_FBDEV = 0
+HAVE_OPENGL = 0
+HAVE_OPENGL1 = 0
+HAVE_OPENGLES = 0
+HAVE_OPENGLES3 = 0
+HAVE_OPENGL_CORE = 0
+HAVE_OPENSSL = 0
+HAVE_OVERLAY = 0
+HAVE_RBMP = 1
+HAVE_RJPEG = 1
+HAVE_RPILED = 0
+HAVE_RPNG = 1
+HAVE_RUNAHEAD = 0
+HAVE_SDL_DINGUX = 1
+HAVE_SHADERPIPELINE = 0
+HAVE_STB_FONT = 0
+HAVE_STB_IMAGE = 0
+HAVE_STB_VORBIS = 0
+HAVE_STDIN_CMD = 0
+HAVE_STRCASESTR = 1
+HAVE_THREADS = 1
+HAVE_UDEV = 0
+HAVE_RGUI = 1
+HAVE_MATERIALUI = 0
+HAVE_XMB = 0
+HAVE_OZONE = 0
+HAVE_ZLIB = 1
+HAVE_CONFIGFILE = 1
+HAVE_PATCH = 1
+HAVE_CHEATS = 1
+HAVE_CHEEVOS = 0
+HAVE_LIBSHAKE = 0
+HAVE_CORE_INFO_CACHE = 1
+#HAVE_TINYALSA = 1
+HAVE_NEAREST_RESAMPLER = 1
+HAVE_NEON = 1
+HAVE_OSS = 1
+HAVE_AUDIOIO = 1
+
+OS = Linux
 TARGET = retroarch
-endif
 
 OBJ :=
-LIBS :=
-DEF_FLAGS := -I.
+LINK := $(CXX)
+DEF_FLAGS := -marm -mtune=cortex-a7 -march=armv7ve+simd -mfpu=neon-vfpv4 -mfloat-abi=hard -ffast-math -fomit-frame-pointer
+DEF_FLAGS += -ffunction-sections -fdata-sections
+DEF_FLAGS += -I. -Ideps -Ideps/stb -DMIYOOMINI -DDINGUX -MMD
+DEF_FLAGS += -Wall -Wno-unused-variable $(LTO)
+DEF_FLAGS += -std=gnu99 -D_GNU_SOURCE
+LIBS := -ldl -lz -lrt -pthread -lmi_sys -lmi_gfx -lmi_ao
+CFLAGS := 
+CXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS
 ASFLAGS :=
-DEFINES := -DHAVE_CONFIG_H -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64
-DEFINES += -DGLOBAL_CONFIG_DIR='"$(GLOBAL_CONFIG_DIR)"'
-DEFINES += -DASSETS_DIR='"$(DESTDIR)$(ASSETS_DIR)"'
-DEFINES += -DFILTERS_DIR='"$(DESTDIR)$(FILTERS_DIR)"'
-DEFINES += -DCORE_INFO_DIR='"$(DESTDIR)$(CORE_INFO_DIR)"'
+LDFLAGS := -Wl,--gc-sections -s
+INCLUDE_DIRS = -I$(INC_DIR)
+LIBRARY_DIRS = -L$(LIB_DIR)
+DEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY
+DEFINES += -DHAVE_C99=1 -DHAVE_CXX=1
+DEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1 -DHAVE_OSS -DHAVE_AUDIOIO
+DEFINES += -DHAVE_FILTERS_BUILTIN -DHAVE_ARM_NEON_ASM_OPTIMIZATIONS
+
+SDL_DINGUX_CFLAGS := $(shell $(SDL_CONFIG) --cflags)
+SDL_DINGUX_LIBS := $(shell $(SDL_CONFIG) --libs)
+FREETYPE_CFLAGS := $(shell $(FREETYPE_CONFIG) --cflags)
+FREETYPE_LIBS := $(shell $(FREETYPE_CONFIG) --libs)
+MMAP_LIBS = -lc
 
 OBJDIR_BASE := obj-unix
 
-ifeq ($(NEED_GOLD_LINKER), 1)
-   LDFLAGS += -fuse-ld=gold
-endif
-
 ifeq ($(DEBUG), 1)
    OBJDIR := $(OBJDIR_BASE)/debug
-   CFLAGS ?= -O0 -g
-   CXXFLAGS ?= -O0 -g
-   DEFINES += -DDEBUG -D_DEBUG
+   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG
 else
    OBJDIR := $(OBJDIR_BASE)/release
-   CFLAGS ?= -O3
-   CXXFLAGS ?= -O3
-   DEF_FLAGS += -ffast-math
-endif
-
-DEF_FLAGS += -Wall
-
-ifneq ($(findstring BSD,$(OS)),)
-   DEF_FLAGS += -DBSD
-   LDFLAGS += -L/usr/local/lib
-   UDEV_CFLAGS += -I/usr/local/include/libepoll-shim
-   UDEV_LIBS += -lepoll-shim
-endif
-
-ifneq ($(findstring DOS,$(OS)),)
-   DEF_FLAGS += -march=i386
-   LDFLAGS += -lemu
-endif
-
-ifneq ($(findstring FPGA,$(OS)),)
-   DEFINES += -DHAVE_FPGA
-endif
-
-ifneq ($(findstring Win32,$(OS)),)
-   LDFLAGS += -static-libgcc -lwinmm -limm32
+   DEF_FLAGS += -Ofast -DNDEBUG
 endif
 
 include Makefile.common
 
-ifeq ($(shell $(CC) -v 2>&1 | grep -c "clang"),1)
-   DEF_FLAGS += -Wno-invalid-source-encoding -Wno-incompatible-ms-struct
-endif
-
-ifeq ($(shell $(CC) -v 2>&1 | grep -c "tcc"),1)
-   MD = -MD
-else
-   MD = -MMD
-endif
+DEF_FLAGS += $(INCLUDE_DIRS)
+LDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)
+CFLAGS += $(DEF_FLAGS)
+CXXFLAGS += $(DEF_FLAGS)
 
 HEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)
 
-ifeq ($(MISSING_DECLS), 1)
-   DEF_FLAGS += -Werror=missing-declarations
-endif
-
-ifeq ($(HAVE_DYLIB), 1)
-   LIBS += $(DYLIB_LIB)
-endif
-
-ifeq ($(HAVE_DYNAMIC), 1)
-   LIBS += $(DYLIB_LIB)
-else
-   LIBS += $(libretro)
-endif
-
-ifneq ($(V),1)
-   Q := @
-endif
-
-ifeq ($(HAVE_DRMINGW), 1)
-   DEF_FLAGS += -DHAVE_DRMINGW
-   LDFLAGS += $(DRMINGW_LIBS)
-endif
-
-ifneq ($(findstring Win32,$(OS)),)
-   LDFLAGS += -mwindows
-endif
-
-ifneq ($(CXX_BUILD), 1)
-   ifneq ($(C89_BUILD),)
-      CFLAGS += -std=c89 -ansi -pedantic -Werror=pedantic -Wno-long-long -Werror=declaration-after-statement
-   else ifeq ($(HAVE_C99), 1)
-      CFLAGS += $(C99_CFLAGS)
-   endif
-
-   CFLAGS += -D_GNU_SOURCE
-endif
-
-DEF_FLAGS += $(INCLUDE_DIRS) -Ideps -Ideps/stb
-
-CFLAGS += $(DEF_FLAGS)
-CXXFLAGS += $(DEF_FLAGS) -D__STDC_CONSTANT_MACROS
-OBJCFLAGS :=  $(CFLAGS) -D__STDC_CONSTANT_MACROS
-
-ifeq ($(HAVE_CXX), 1)
-   ifeq ($(CXX_BUILD), 1)
-      LINK = $(CXX)
-      CFLAGS   := $(CXXFLAGS) -xc++
-      CFLAGS   += -DCXX_BUILD
-      CXXFLAGS += -DCXX_BUILD
-   else ifeq ($(NEED_CXX_LINKER),1)
-      LINK = $(CXX)
-   else
-      LINK = $(CC)
-   endif
-else
-   LINK = $(CC)
-endif
+Q := @
 
 RARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))
 
-ifneq ($(X86),)
-   CFLAGS += -m32
-   CXXFLAGS += -m32
-   LDFLAGS += -m32
-endif
-
-ifneq ($(SANITIZER),)
-   CFLAGS   := -fsanitize=$(SANITIZER) $(CFLAGS)
-   CXXFLAGS := -fsanitize=$(SANITIZER) $(CXXFLAGS)
-   LDFLAGS  := -fsanitize=$(SANITIZER) $(LDFLAGS)
-endif
-
-ifneq ($(findstring $(GPERFTOOLS),profiler),)
-   LIBS += -lprofiler
-endif
-ifneq ($(findstring $(GPERFTOOLS),tcmalloc),)
-   LIBS += -ltcmalloc
-endif
-
-# Qt MOC generation, required for QObject-derived classes
-ifneq ($(MOC_HEADERS),)
-    # prefix moc_ to base filename of paths and change extension from h to cpp, so a/b/foo.h becomes a/b/moc_foo.cpp
-    MOC_SRC := $(join $(addsuffix moc_,$(addprefix $(OBJDIR)/,$(dir $(MOC_HEADERS)))), $(notdir $(MOC_HEADERS:.h=.cpp)))
-    MOC_OBJ := $(patsubst %.cpp,%.o,$(MOC_SRC))
-    RARCH_OBJ += $(MOC_OBJ)
-endif
-
-all: $(TARGET) config.mk
-
-$(MOC_SRC):
-	@$(if $(Q), $(shell echo echo MOC $<),)
-	$(eval MOC_TMP := $(patsubst %.h,%_moc.cpp,$@))
-	$(Q)QT_SELECT=$(QT_VERSION) $(MOC) -o $(MOC_TMP) $<
-
-$(foreach x,$(join $(addsuffix :,$(MOC_SRC)),$(MOC_HEADERS)),$(eval $x))
-
-$(MOC_OBJ):
-	@$(if $(Q), $(shell echo echo CXX $<),)
-	$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<
-
-$(foreach x,$(join $(addsuffix :,$(MOC_OBJ)),$(MOC_SRC)),$(eval $x))
+all: $(TARGET)
 
-ifeq ($(MAKECMDGOALS),clean)
-config.mk:
-else
 -include $(RARCH_OBJ:.o=.d)
-ifeq ($(HAVE_CONFIG_MK),)
-config.mk: configure qb/*
-	@echo "config.mk is outdated or non-existing. Run ./configure again."
-	@exit 1
-endif
-endif
 
 SYMBOL_MAP := -Wl,-Map=output.map
 
@@ -203,12 +166,16 @@ $(TARGET): $(RARCH_OBJ)
 	@$(if $(Q), $(shell echo echo LD $@),)
 	$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)
 
-$(OBJDIR)/%.o: %.c config.h config.mk
+ifeq ($(STRIP_BIN),1)
+	$(STRIP) --strip-unneeded $(TARGET)
+endif
+
+$(OBJDIR)/%.o: %.c
 	@mkdir -p $(dir $@)
 	@$(if $(Q), $(shell echo echo CC $<),)
-	$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) $(MD) -c -o $@ $<
+	$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<
 
-$(OBJDIR)/%.o: %.cpp config.h config.mk
+$(OBJDIR)/%.o: %.cpp
 	@mkdir -p $(dir $@)
 	@$(if $(Q), $(shell echo echo CXX $<),)
 	$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<
@@ -218,78 +185,17 @@ $(OBJDIR)/%.o: %.m
 	@$(if $(Q), $(shell echo echo OBJC $<),)
 	$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<
 
-$(OBJDIR)/%.o: %.S config.h config.mk $(HEADERS)
+$(OBJDIR)/%.o: %.S $(HEADERS)
 	@mkdir -p $(dir $@)
 	@$(if $(Q), $(shell echo echo AS $<),)
 	$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<
 
-$(OBJDIR)/%.o: %.rc $(HEADERS)
-	@mkdir -p $(dir $@)
-	@$(if $(Q), $(shell echo echo WINDRES $<),)
-	$(Q)$(WINDRES) -o $@ $<
-
-install: $(TARGET)
-	mkdir -p $(DESTDIR)$(BIN_DIR) 2>/dev/null || /bin/true
-	mkdir -p $(DESTDIR)$(GLOBAL_CONFIG_DIR) 2>/dev/null || /bin/true
-	mkdir -p $(DESTDIR)$(DATA_DIR)/applications 2>/dev/null || /bin/true
-	mkdir -p $(DESTDIR)$(DATA_DIR)/metainfo 2>/dev/null || /bin/true
-	mkdir -p $(DESTDIR)$(DOC_DIR) 2>/dev/null || /bin/true
-	mkdir -p $(DESTDIR)$(MAN_DIR)/man6 2>/dev/null || /bin/true
-	mkdir -p $(DESTDIR)$(DATA_DIR)/pixmaps 2>/dev/null || /bin/true
-	cp $(TARGET) $(DESTDIR)$(BIN_DIR)
-	cp tools/cg2glsl.py $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl
-	cp retroarch.cfg $(DESTDIR)$(GLOBAL_CONFIG_DIR)
-	cp com.libretro.RetroArch.appdata.xml $(DESTDIR)$(DATA_DIR)/metainfo
-	cp retroarch.desktop $(DESTDIR)$(DATA_DIR)/applications
-	cp docs/retroarch.6 $(DESTDIR)$(MAN_DIR)/man6
-	cp docs/retroarch-cg2glsl.6 $(DESTDIR)$(MAN_DIR)/man6
-	cp media/retroarch.svg $(DESTDIR)$(DATA_DIR)/pixmaps
-	cp COPYING $(DESTDIR)$(DOC_DIR)
-	cp README.md $(DESTDIR)$(DOC_DIR)
-	chmod 755 $(DESTDIR)$(BIN_DIR)/$(TARGET)
-	chmod 755 $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl
-	chmod 644 $(DESTDIR)$(GLOBAL_CONFIG_DIR)/retroarch.cfg
-	chmod 644 $(DESTDIR)$(DATA_DIR)/applications/retroarch.desktop
-	chmod 644 $(DESTDIR)$(DATA_DIR)/metainfo/com.libretro.RetroArch.appdata.xml
-	chmod 644 $(DESTDIR)$(MAN_DIR)/man6/retroarch.6
-	chmod 644 $(DESTDIR)$(MAN_DIR)/man6/retroarch-cg2glsl.6
-	chmod 644 $(DESTDIR)$(DATA_DIR)/pixmaps/retroarch.svg
-	@if test -d media/assets && test $(HAVE_ASSETS); then \
-		echo "Installing media assets..."; \
-		mkdir -p $(DESTDIR)$(ASSETS_DIR)/assets; \
-		if test $(HAVE_MATERIALUI) = 1; then \
-			cp -r media/assets/glui/ $(DESTDIR)$(ASSETS_DIR)/assets; \
-		fi; \
-		if test $(HAVE_XMB) = 1; then \
-			cp -r media/assets/xmb/ $(DESTDIR)$(ASSETS_DIR)/assets; \
-		fi; \
-		if test $(HAVE_OZONE) = 1; then \
-			cp -r media/assets/ozone/ $(DESTDIR)$(ASSETS_DIR)/assets; \
-		fi; \
-		cp media/assets/COPYING $(DESTDIR)$(DOC_DIR)/COPYING.assets; \
-		echo "Asset copying done."; \
-	fi
-
-uninstall:
-	rm -f $(DESTDIR)$(BIN_DIR)/$(TARGET)
-	rm -f $(DESTDIR)$(BIN_DIR)/retroarch-cg2glsl
-	rm -f $(DESTDIR)$(GLOBAL_CONFIG_DIR)/retroarch.cfg
-	rm -f $(DESTDIR)$(DATA_DIR)/applications/retroarch.desktop
-	rm -f $(DESTDIR)$(DATA_DIR)/metainfo/com.libretro.RetroArch.appdata.xml
-	rm -f $(DESTDIR)$(DATA_DIR)/pixmaps/retroarch.svg
-	rm -f $(DESTDIR)$(DOC_DIR)/COPYING
-	rm -f $(DESTDIR)$(DOC_DIR)/COPYING.assets
-	rm -f $(DESTDIR)$(DOC_DIR)/README.md
-	rm -f $(DESTDIR)$(MAN_DIR)/man6/retroarch.6
-	rm -f $(DESTDIR)$(MAN_DIR)/man6/retroarch-cg2glsl.6
-	rm -rf $(DESTDIR)$(ASSETS_DIR)
-
 clean:
 	rm -rf $(OBJDIR_BASE)
 	rm -f $(TARGET)
 	rm -f *.d
 
-.PHONY: all install uninstall clean
+.PHONY: all clean
 
 print-%:
 	@echo '$*=$($*)'
diff --git a/Makefile_ml b/Makefile_ml
new file mode 100644
index 0000000000..932eae2025
--- /dev/null
+++ b/Makefile_ml
@@ -0,0 +1,201 @@
+#########################
+## Toolchain variables ##
+#########################
+
+# Default toolchain directory
+TOOLCHAIN_DIR=/opt/miyoomini83
+
+# All toolchain-related variables may be
+# overridden via the command line
+
+CC		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-gcc
+CXX		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-g++
+STRIP		= $(TOOLCHAIN_DIR)/bin/arm-linux-gnueabihf-strip
+
+SDL_CONFIG	?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/bin/sdl-config
+FREETYPE_CONFIG	?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/bin/freetype-config
+
+INC_DIR		?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/include
+LIB_DIR		?= $(TOOLCHAIN_DIR)/arm-linux-gnueabihf/libc/usr/lib
+
+LTO		= -flto
+STRIP_BIN	= 1
+
+#########################
+#########################
+
+PACKAGE_NAME = retroarch
+
+DEBUG ?= 0
+
+MIYOOMINI = 1
+DINGUX = 1
+HAVE_SCREENSHOTS = 1
+HAVE_REWIND = 1
+HAVE_7ZIP = 1
+HAVE_AL = 0
+HAVE_ALSA = 0
+HAVE_DSP_FILTER = 1
+HAVE_VIDEO_FILTER = 1
+HAVE_STATIC_VIDEO_FILTERS = 1
+HAVE_STATIC_AUDIO_FILTERS = 1
+HAVE_FILTERS_BUILTIN	= 1
+HAVE_BUILTINMBEDTLS = 0
+HAVE_BUILTINZLIB = 1
+HAVE_C99 = 1
+HAVE_CC = 1
+#HAVE_CC_RESAMPLER = 1
+HAVE_CHD = 1
+HAVE_COMMAND = 0
+HAVE_CXX = 1
+HAVE_DR_MP3 = 1
+HAVE_DYNAMIC = 1
+HAVE_DYLIB = 1
+HAVE_EGL = 0
+HAVE_FREETYPE = 0
+HAVE_GDI = 1
+HAVE_GETADDRINFO = 0
+HAVE_GETOPT_LONG = 1
+HAVE_GLSL = 0
+HAVE_HID = 1
+HAVE_IBXM = 1
+HAVE_IMAGEVIEWER = 0
+HAVE_LANGEXTRA = 1
+HAVE_LIBRETRODB = 1
+HAVE_MENU = 1
+HAVE_MENU_COMMON = 1
+HAVE_GFX_WIDGETS = 0
+HAVE_MMAP = 1
+HAVE_OPENDINGUX_FBDEV = 0
+HAVE_OPENGL = 0
+HAVE_OPENGL1 = 0
+HAVE_OPENGLES = 0
+HAVE_OPENGLES3 = 0
+HAVE_OPENGL_CORE = 0
+HAVE_OPENSSL = 0
+HAVE_OVERLAY = 0
+HAVE_RBMP = 1
+HAVE_RJPEG = 1
+HAVE_RPILED = 0
+HAVE_RPNG = 1
+HAVE_RUNAHEAD = 0
+HAVE_SDL_DINGUX = 1
+HAVE_SHADERPIPELINE = 0
+HAVE_STB_FONT = 0
+HAVE_STB_IMAGE = 0
+HAVE_STB_VORBIS = 0
+HAVE_STDIN_CMD = 0
+HAVE_STRCASESTR = 1
+HAVE_THREADS = 1
+HAVE_UDEV = 0
+HAVE_RGUI = 1
+HAVE_MATERIALUI = 0
+HAVE_XMB = 0
+HAVE_OZONE = 0
+HAVE_ZLIB = 1
+HAVE_CONFIGFILE = 1
+HAVE_PATCH = 1
+HAVE_CHEATS = 1
+HAVE_CHEEVOS = 0
+HAVE_LIBSHAKE = 0
+HAVE_CORE_INFO_CACHE = 1
+#HAVE_TINYALSA = 1
+HAVE_NEAREST_RESAMPLER = 1
+HAVE_NEON = 1
+HAVE_OSS = 1
+HAVE_AUDIOIO = 1
+
+OS = Linux
+TARGET = retroarch_multilang
+
+OBJ :=
+LINK := $(CXX)
+DEF_FLAGS := -marm -mtune=cortex-a7 -march=armv7ve+simd -mfpu=neon-vfpv4 -mfloat-abi=hard -ffast-math -fomit-frame-pointer
+DEF_FLAGS += -ffunction-sections -fdata-sections
+DEF_FLAGS += -I. -Ideps -Ideps/stb -DMIYOOMINI -DDINGUX -MMD
+DEF_FLAGS += -Wall -Wno-unused-variable $(LTO)
+DEF_FLAGS += -std=gnu99 -D_GNU_SOURCE
+LIBS := -ldl -lz -lrt -pthread -lmi_sys -lmi_gfx -lmi_ao
+CFLAGS := 
+CXXFLAGS := -fno-exceptions -fno-rtti -std=c++11 -D__STDC_CONSTANT_MACROS
+ASFLAGS :=
+LDFLAGS := -Wl,--gc-sections -s
+INCLUDE_DIRS = -I$(INC_DIR)
+LIBRARY_DIRS = -L$(LIB_DIR)
+DEFINES := -DRARCH_INTERNAL -D_FILE_OFFSET_BITS=64 -UHAVE_STATIC_DUMMY
+DEFINES += -DHAVE_C99=1 -DHAVE_CXX=1
+DEFINES += -DHAVE_GETOPT_LONG=1 -DHAVE_STRCASESTR=1 -DHAVE_DYNAMIC=1 -DHAVE_OSS -DHAVE_AUDIOIO
+DEFINES += -DHAVE_FILTERS_BUILTIN -DHAVE_ARM_NEON_ASM_OPTIMIZATIONS
+
+SDL_DINGUX_CFLAGS := $(shell $(SDL_CONFIG) --cflags)
+SDL_DINGUX_LIBS := $(shell $(SDL_CONFIG) --libs)
+FREETYPE_CFLAGS := $(shell $(FREETYPE_CONFIG) --cflags)
+FREETYPE_LIBS := $(shell $(FREETYPE_CONFIG) --libs)
+MMAP_LIBS = -lc
+
+OBJDIR_BASE := obj-unix
+
+ifeq ($(DEBUG), 1)
+   OBJDIR := $(OBJDIR_BASE)/debug
+   DEF_FLAGS += -O0 -g -DDEBUG -D_DEBUG
+else
+   OBJDIR := $(OBJDIR_BASE)/release
+   DEF_FLAGS += -Ofast -DNDEBUG
+endif
+
+include Makefile.common
+
+DEF_FLAGS += $(INCLUDE_DIRS)
+LDFLAGS += $(CFLAGS) $(CXXFLAGS) $(DEF_FLAGS)
+CFLAGS += $(DEF_FLAGS)
+CXXFLAGS += $(DEF_FLAGS)
+
+HEADERS = $(wildcard */*/*.h) $(wildcard */*.h) $(wildcard *.h)
+
+Q := @
+
+RARCH_OBJ := $(addprefix $(OBJDIR)/,$(OBJ))
+
+all: $(TARGET)
+
+-include $(RARCH_OBJ:.o=.d)
+
+SYMBOL_MAP := -Wl,-Map=output.map
+
+$(TARGET): $(RARCH_OBJ)
+	@$(if $(Q), $(shell echo echo LD $@),)
+	$(Q)$(LINK) -o $@ $(RARCH_OBJ) $(LIBS) $(LDFLAGS) $(LIBRARY_DIRS)
+
+ifeq ($(STRIP_BIN),1)
+	$(STRIP) --strip-unneeded $(TARGET)
+endif
+
+$(OBJDIR)/%.o: %.c
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo CC $<),)
+	$(Q)$(CC) $(CPPFLAGS) $(CFLAGS) $(DEFINES) -c -o $@ $<
+
+$(OBJDIR)/%.o: %.cpp
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo CXX $<),)
+	$(Q)$(CXX) $(CPPFLAGS) $(CXXFLAGS) $(DEFINES) -MMD -c -o $@ $<
+
+$(OBJDIR)/%.o: %.m
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo OBJC $<),)
+	$(Q)$(CXX) $(OBJCFLAGS) $(DEFINES) -MMD -c -o $@ $<
+
+$(OBJDIR)/%.o: %.S $(HEADERS)
+	@mkdir -p $(dir $@)
+	@$(if $(Q), $(shell echo echo AS $<),)
+	$(Q)$(CC) $(CFLAGS) $(ASFLAGS) $(DEFINES) -c -o $@ $<
+
+clean:
+	rm -rf $(OBJDIR_BASE)
+	rm -f $(TARGET)
+	rm -f *.d
+
+.PHONY: all clean
+
+print-%:
+	@echo '$*=$($*)'
diff --git a/audio/drivers/audioio.c b/audio/drivers/audioio.c
index 8176a0d7b4..b32a5a97ef 100644
--- a/audio/drivers/audioio.c
+++ b/audio/drivers/audioio.c
@@ -13,6 +13,10 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "audioio_miyoomini.c"
+#else
+
 #include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -210,3 +214,5 @@ audio_driver_t audio_audioio = {
    audioio_write_avail,
    audioio_buffer_size,
 };
+
+#endif
diff --git a/audio/drivers/audioio_miyoomini.c b/audio/drivers/audioio_miyoomini.c
new file mode 100644
index 0000000000..970e473caa
--- /dev/null
+++ b/audio/drivers/audioio_miyoomini.c
@@ -0,0 +1,253 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+      MIAO audio driver for miyoomini
+      The name "audioio" is used to minimize the number of files to be rewritten as much as possible,
+      but /dev/audio is not used.
+*/
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define YIELD_WAIT /* Flag to wait with sched_yield() when the wait time is less than 10ms */
+
+#include <sdkdir/mi_ao.h>
+#ifdef	YIELD_WAIT
+#include <sched.h>
+#ifndef	SCHED_IDLE
+#define SCHED_IDLE 5
+#endif
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include "../../config.h"
+#endif
+
+#include "../audio_driver.h"
+#include "../../verbosity.h"
+
+/* MI_AO_SendFrame Max bytes */
+#define MIAO_MAX_BUFSIZE 51200
+
+typedef struct miao_audio
+{
+   MI_AUDIO_Frame_t AoSendFrame;
+   size_t bufsize;
+   uint32_t freq;
+   bool nonblock;
+   bool is_paused;
+   void* nullbuf;
+} miao_audio_t;
+
+static void *miao_init(const char *device,
+      unsigned rate, unsigned latency,
+      unsigned block_frames,
+      unsigned *new_rate)
+{
+   MI_AUDIO_Attr_t attr;
+   uint32_t samples;
+
+   miao_audio_t *miaoaudio = (miao_audio_t*)calloc(1, sizeof(miao_audio_t));
+   if (!miaoaudio) return NULL;
+
+   const int freqtable[] = { 8000,11025,12000,16000,22050,24000,32000,44100,48000 };
+   for (uint32_t i=0; i<(sizeof(freqtable)/sizeof(int)); i++) {
+      if (rate <= freqtable[i]) { miaoaudio->freq = freqtable[i]; break; }
+   } if (rate > 48000) miaoaudio->freq = 48000;
+
+   if (miaoaudio->freq != rate) {
+      *new_rate = miaoaudio->freq;
+      RARCH_WARN("[MIAO]: Requested sample rate not supported, adjusting output rate to %d Hz.\n", *new_rate);
+   }
+
+   miaoaudio->bufsize = (latency * miaoaudio->freq / 1000) << 2;
+   miaoaudio->bufsize = (miaoaudio->bufsize + 15) & ~15;
+   if ( miaoaudio->bufsize == 0 ) miaoaudio->bufsize = 16;
+   else if ( miaoaudio->bufsize > MIAO_MAX_BUFSIZE ) miaoaudio->bufsize = MIAO_MAX_BUFSIZE;
+
+   RARCH_LOG("[MIAO]: Requested %u ms latency, got %.2f ms\n",
+         latency, (float)( (miaoaudio->bufsize >> 2) * 1000 / miaoaudio->freq ) );
+
+   samples = miaoaudio->bufsize >> 2;
+   if ( samples > 2048 ) samples = 2048;
+
+   memset(&attr, 0, sizeof(attr));
+   attr.eSamplerate = (MI_AUDIO_SampleRate_e)miaoaudio->freq;
+   attr.eSoundmode = E_MI_AUDIO_SOUND_MODE_STEREO;
+   attr.u32ChnCnt = 2;
+   attr.u32PtNumPerFrm = samples;
+   /* Maybe unnecessary but just in case */
+   miaoaudio->AoSendFrame.eSoundmode = E_MI_AUDIO_SOUND_MODE_STEREO;
+
+   if (MI_AO_SetPubAttr(0,&attr)) goto error;
+   if (MI_AO_Enable(0)) goto error;
+   if (MI_AO_EnableChn(0,0)) goto error;
+   if (MI_AO_SetVolume(0,0)) goto error;
+   if (MI_AO_SetMute(0, FALSE)) goto error;
+
+   /* Send pre-fill null data */
+   miaoaudio->nullbuf = calloc(1, miaoaudio->bufsize);
+   if (!miaoaudio->nullbuf) goto error;
+   miaoaudio->AoSendFrame.apVirAddr[0] = miaoaudio->nullbuf;
+   miaoaudio->AoSendFrame.u32Len = miaoaudio->bufsize;
+   MI_AO_ClearChnBuf(0,0);
+   MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+
+   return miaoaudio;
+
+error:
+   free(miaoaudio);
+   RARCH_ERR("[MIAO]: Failed to initialize...\n");
+   return NULL;
+}
+
+static ssize_t miao_write(void *data, const void *buf, size_t size)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   if ((!size)||(miaoaudio->is_paused)) return 0;
+
+   miaoaudio->AoSendFrame.apVirAddr[0] = (void*)buf;
+   ssize_t write_bytes;
+   uint32_t usleepclock;
+
+   MI_AO_ChnState_t status;
+   MI_AO_QueryChnStat(0, 0, &status);
+   int avail = miaoaudio->bufsize - status.u32ChnBusyNum;
+
+   if ( (avail < size) && (!miaoaudio->nonblock) ) {
+      write_bytes = size;
+      miaoaudio->AoSendFrame.u32Len = write_bytes;
+      MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+
+      /* wait process for miyoomini with 10ms sleep precision */
+      MI_AO_QueryChnStat(0, 0, &status);
+      if (status.u32ChnBusyNum > miaoaudio->bufsize) {
+         usleepclock = (uint64_t)(status.u32ChnBusyNum - miaoaudio->bufsize) * 1000000 / (miaoaudio->freq << 2);
+#ifndef YIELD_WAIT
+         if ( usleepclock ) usleep(usleepclock);
+#else
+         if ( usleepclock > 0x2800 ) usleep(usleepclock - 0x2800); /* 0.24ms margin */
+
+         const struct sched_param scprm = {0};
+         int policy = sched_getscheduler(0);
+         sched_setscheduler(0, SCHED_IDLE, &scprm);
+         do { sched_yield(); MI_AO_QueryChnStat(0, 0, &status);
+         } while(status.u32ChnBusyNum > miaoaudio->bufsize);
+         sched_setscheduler(0, policy, &scprm);
+#endif
+      }
+   } else {
+      write_bytes = avail > size ? size : avail;
+      if (write_bytes > 0) {
+         miaoaudio->AoSendFrame.u32Len = write_bytes;
+         MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+      } else return 0;
+   }
+   return write_bytes;
+}
+
+static bool miao_stop(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   if (!miaoaudio->is_paused) {
+      MI_AO_SetMute(0, TRUE);
+      miaoaudio->is_paused = true;
+   }
+   return true;
+}
+
+static bool miao_start(void *data, bool is_shutdown)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   if (miaoaudio->is_paused) {
+      /* Send pre-fill null data */
+      miaoaudio->AoSendFrame.apVirAddr[0] = miaoaudio->nullbuf;
+      miaoaudio->AoSendFrame.u32Len = miaoaudio->bufsize;
+      MI_AO_ClearChnBuf(0,0);
+      MI_AO_SendFrame(0, 0, &miaoaudio->AoSendFrame, 0);
+      MI_AO_SetMute(0, FALSE);
+      miaoaudio->is_paused = false;
+   }
+   return true;
+}
+
+static bool miao_alive(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   return !miaoaudio->is_paused;
+}
+
+static void miao_set_nonblock_state(void *data, bool state)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   miaoaudio->nonblock = state;
+}
+
+static void miao_free(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   MI_AO_SetMute(0, FALSE);
+   MI_AO_ClearChnBuf(0,0);
+   MI_AO_DisableChn(0,0);
+   MI_AO_Disable(0);
+   free(miaoaudio->nullbuf);
+   free(data);
+}
+
+static bool miao_use_float(void *data)
+{
+   (void)data;
+   return false;
+}
+
+static size_t miao_write_avail(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   MI_AO_ChnState_t status;
+
+   MI_AO_QueryChnStat(0, 0, &status);
+   int avail = MIAO_MAX_BUFSIZE - status.u32ChnBusyNum;
+/* not sure which is better value... */
+/* int avail = miaoaudio->bufsize - status.u32ChnBusyNum; */
+   return (avail > 0) ? avail : 0;
+}
+
+static size_t miao_buffer_size(void *data)
+{
+   miao_audio_t *miaoaudio = (miao_audio_t*)data;
+   return MIAO_MAX_BUFSIZE;
+/* return miaoaudio->bufsize; */
+}
+
+audio_driver_t audio_audioio = {
+   miao_init,
+   miao_write,
+   miao_stop,
+   miao_start,
+   miao_alive,
+   miao_set_nonblock_state,
+   miao_free,
+   miao_use_float,
+   "audioio",
+   NULL,
+   NULL,
+   miao_write_avail,
+   miao_buffer_size,
+};
diff --git a/audio/drivers/oss.c b/audio/drivers/oss.c
index 52b525ac34..da2f2e1a78 100644
--- a/audio/drivers/oss.c
+++ b/audio/drivers/oss.c
@@ -13,6 +13,10 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "oss_miyoomini.c"
+#else
+
 #include <stdio.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -228,3 +232,4 @@ audio_driver_t audio_oss = {
    oss_write_avail,
    oss_buffer_size,
 };
+#endif
diff --git a/audio/drivers/oss_miyoomini.c b/audio/drivers/oss_miyoomini.c
new file mode 100644
index 0000000000..df5d597805
--- /dev/null
+++ b/audio/drivers/oss_miyoomini.c
@@ -0,0 +1,244 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+      Modified OSS driver exclusively for miyoomini
+      Supports both AudioFix: ON / OFF
+*/
+
+/* To use audioserver, must use open instead of open64 */
+#ifdef _FILE_OFFSET_BITS
+#undef _FILE_OFFSET_BITS
+#define _FILE_OFFSET_BITS 32
+#endif
+
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/soundcard.h>
+#include <sdkdir/mi_ao.h>
+
+#ifdef HAVE_CONFIG_H
+#include "../../config.h"
+#endif
+
+#include "../audio_driver.h"
+#include "../../verbosity.h"
+
+#define DEFAULT_OSS_DEV "/dev/dsp"
+
+typedef struct oss_audio
+{
+   int fd;
+   bool is_paused;
+   bool nonblock;
+   bool audioserver;
+} oss_audio_t;
+
+static void *oss_init(const char *device,
+      unsigned rate, unsigned latency,
+      unsigned block_frames,
+      unsigned *new_out_rate)
+{
+   int frags, frag, channels, format, new_rate;
+   oss_audio_t *ossaudio  = (oss_audio_t*)calloc(1, sizeof(oss_audio_t));
+   const char *oss_device = device ? device : DEFAULT_OSS_DEV;
+
+   if (!ossaudio)
+      return NULL;
+
+   /* Open /dev/dsp with audioserver check */
+   /* Use the fact that padsp replaces open, but not __open */
+   extern int __open(const char *file, int oflag);
+   if ((ossaudio->fd = __open(oss_device, O_WRONLY)) < 0) {
+      if ((ossaudio->fd = open(oss_device, O_WRONLY)) < 0) {
+         free(ossaudio);
+         perror("open");
+         return NULL;
+      }
+      ossaudio->audioserver = true;
+      RARCH_LOG("[OSS]: Using audioserver.\n");
+  }
+
+   frags = (latency * rate * 4) / (1000 * (1 << 10));
+   frag  = (frags << 16) | 10;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_SETFRAGMENT, &frag) < 0)
+      RARCH_WARN("Cannot set fragment sizes. Latency might not be as expected ...\n");
+
+   channels = 2;
+   format   = AFMT_S16_LE;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_CHANNELS, &channels) < 0)
+      goto error;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_SETFMT, &format) < 0)
+      goto error;
+
+   new_rate = rate;
+   if (!ossaudio->audioserver) {
+      /* stock oss supports 48k, 32k, 16k, 8k only */
+      if ( new_rate > 32000 ) new_rate = 48000;
+      else if ( new_rate > 16000 ) new_rate = 32000;
+      else if ( new_rate > 8000 ) new_rate = 16000;
+      else new_rate = 8000;
+   }
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_SPEED, &new_rate) < 0)
+      goto error;
+
+   if (new_rate != (int)rate)
+   {
+      RARCH_WARN("Requested sample rate not supported. Adjusting output rate to %d Hz.\n", new_rate);
+      *new_out_rate = new_rate;
+   }
+
+   if (!ossaudio->audioserver) {
+      /* mi_ao init is required for stock oss */
+      MI_AUDIO_Attr_t attr;
+      memset(&attr, 0, sizeof(attr));
+      attr.eSamplerate = new_rate;
+      attr.eSoundmode = E_MI_AUDIO_SOUND_MODE_STEREO;
+      attr.u32ChnCnt = 2;
+      attr.u32PtNumPerFrm = 256;
+      MI_AO_SetPubAttr(0, &attr);
+   }
+
+   return ossaudio;
+
+error:
+   close(ossaudio->fd);
+   if (ossaudio)
+      free(ossaudio);
+   perror("ioctl");
+   return NULL;
+}
+
+static ssize_t oss_write(void *data, const void *buf, size_t size)
+{
+   ssize_t ret;
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   /* For stock oss, no playback during fast forward to avoid blocking */
+   if ( (size == 0) || ((!ossaudio->audioserver)&&(ossaudio->nonblock)) )
+      return 0;
+
+   if ((ret = write(ossaudio->fd, buf, size)) < 0)
+   {
+      if (errno == EAGAIN && (fcntl(ossaudio->fd, F_GETFL) & O_NONBLOCK))
+         return 0;
+
+      return -1;
+   }
+
+   return ret;
+}
+
+static bool oss_stop(void *data)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   ossaudio->is_paused = true;
+   return true;
+}
+
+static bool oss_start(void *data, bool is_shutdown)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+   if (!ossaudio) return false;
+
+   ossaudio->is_paused = false;
+   return true;
+}
+
+static bool oss_alive(void *data)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+   return !ossaudio->is_paused;
+}
+
+static void oss_set_nonblock_state(void *data, bool state)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   if (state) fcntl(ossaudio->fd, F_SETFL, fcntl(ossaudio->fd, F_GETFL) | O_NONBLOCK);
+   else       fcntl(ossaudio->fd, F_SETFL, fcntl(ossaudio->fd, F_GETFL) & (~O_NONBLOCK));
+
+   ossaudio->nonblock = state;
+}
+
+static void oss_free(void *data)
+{
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   close(ossaudio->fd);
+   free(data);
+}
+
+static size_t oss_write_avail(void *data)
+{
+   audio_buf_info info;
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      RARCH_ERR("[OSS]: SNDCTL_DSP_GETOSPACE failed ...\n");
+      return 0;
+   }
+
+   return info.bytes;
+}
+
+static size_t oss_buffer_size(void *data)
+{
+   audio_buf_info info;
+   oss_audio_t *ossaudio  = (oss_audio_t*)data;
+
+   if (ioctl(ossaudio->fd, SNDCTL_DSP_GETOSPACE, &info) < 0)
+   {
+      RARCH_ERR("[OSS]: SNDCTL_DSP_GETOSPACE failed ...\n");
+      return 1; /* Return something non-zero to avoid SIGFPE. */
+   }
+
+   return info.fragsize * info.fragstotal;
+}
+
+static bool oss_use_float(void *data)
+{
+   (void)data;
+   return false;
+}
+
+audio_driver_t audio_oss = {
+   oss_init,
+   oss_write,
+   oss_stop,
+   oss_start,
+   oss_alive,
+   oss_set_nonblock_state,
+   oss_free,
+   oss_use_float,
+   "oss",
+   NULL,
+   NULL,
+   oss_write_avail,
+   oss_buffer_size,
+};
diff --git a/audio/drivers/sdl_audio.c b/audio/drivers/sdl_audio.c
index 56554083f5..1ac734992a 100644
--- a/audio/drivers/sdl_audio.c
+++ b/audio/drivers/sdl_audio.c
@@ -13,6 +13,9 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "sdl_audio_miyoomini.c"
+#else
 
 #include <stdint.h>
 #include <stddef.h>
@@ -276,3 +279,4 @@ audio_driver_t audio_sdl = {
    sdl_audio_write_avail,
    NULL
 };
+#endif
diff --git a/audio/drivers/sdl_audio_miyoomini.c b/audio/drivers/sdl_audio_miyoomini.c
new file mode 100644
index 0000000000..6cd59aa360
--- /dev/null
+++ b/audio/drivers/sdl_audio_miyoomini.c
@@ -0,0 +1,273 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/*
+      SDL audio driver for miyoomini customSDL
+      Can be used with standard SDL as well
+*/
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <boolean.h>
+#include <rthreads/rthreads.h>
+#include <queues/fifo_queue.h>
+#include <retro_inline.h>
+#include <retro_math.h>
+
+#include "SDL.h"
+#include "SDL_audio.h"
+
+#include "../audio_driver.h"
+#include "../../verbosity.h"
+
+#define SDL_AUDIO_SAMPLES 512
+
+typedef struct sdl_audio
+{
+#ifdef HAVE_THREADS
+   slock_t *lock;
+   scond_t *cond;
+#endif
+   fifo_buffer_t *buffer;
+   bool nonblock;
+   bool is_paused;
+   size_t bufsize;
+} sdl_audio_t;
+
+static void sdl_audio_cb(void *data, Uint8 *stream, int len)
+{
+   sdl_audio_t  *sdl = (sdl_audio_t*)data;
+   size_t      avail = FIFO_READ_AVAIL(sdl->buffer);
+   size_t write_size = len > (int)avail ? avail : len;
+
+   fifo_read(sdl->buffer, stream, write_size);
+#ifdef HAVE_THREADS
+   scond_signal(sdl->cond);
+#endif
+#ifdef HAVE_SDL2
+   /* If underrun, fill rest with silence. */
+   if (len > (int)avail) memset(stream + write_size, 0, len - write_size);
+#endif
+}
+
+static void *sdl_audio_init(const char *device,
+      unsigned rate, unsigned latency,
+      unsigned block_frames,
+      unsigned *new_rate)
+{
+   int frames;
+   SDL_AudioSpec out;
+   SDL_AudioSpec spec           = {0};
+   void *tmp                    = NULL;
+   sdl_audio_t *sdl             = NULL;
+   uint32_t sdl_subsystem_flags = SDL_WasInit(0);
+
+   (void)device;
+
+   /* Initialise audio subsystem, if required */
+   if (sdl_subsystem_flags == 0)
+   {
+      if (SDL_Init(SDL_INIT_AUDIO) < 0)
+         return NULL;
+   }
+   else if ((sdl_subsystem_flags & SDL_INIT_AUDIO) == 0)
+   {
+      if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0)
+         return NULL;
+   }
+
+   sdl = (sdl_audio_t*)calloc(1, sizeof(*sdl));
+   if (!sdl)
+      return NULL;
+
+   frames        = (latency * (rate - 1)) / (1000 * SDL_AUDIO_SAMPLES) + 1;
+   if (frames < 2) frames = 2; /* at least 2 frames */
+
+   spec.freq     = rate;
+   spec.format   = AUDIO_S16SYS;
+   spec.channels = 2;
+   spec.samples  = SDL_AUDIO_SAMPLES;
+   spec.callback = sdl_audio_cb;
+   spec.userdata = sdl;
+
+   if (SDL_OpenAudio(&spec, &out) < 0)
+   {
+      RARCH_ERR("[SDL audio]: Failed to open SDL audio: %s\n", SDL_GetError());
+      goto error;
+   }
+
+   *new_rate                = out.freq;
+
+#ifdef HAVE_THREADS
+   sdl->lock                = slock_new();
+   sdl->cond                = scond_new();
+#endif
+
+   RARCH_LOG("[SDL audio]: Requested %u ms latency, got %d ms\n",
+         latency, (int)(out.samples * frames * 1000 / (*new_rate)));
+
+   /* Create a buffer twice as big as needed */
+   sdl->bufsize = out.samples * out.channels * sizeof(int16_t) * frames * 2;
+   sdl->buffer  = fifo_new(sdl->bufsize);
+
+   /* Allocate the null-buffer and prefill */
+   tmp = calloc(1, (sdl->bufsize / 2));
+   if (tmp) { fifo_write(sdl->buffer, tmp, (sdl->bufsize / 2)); free(tmp); }
+
+   SDL_PauseAudio(0);
+
+   return sdl;
+
+error:
+   free(sdl);
+   return NULL;
+}
+
+static ssize_t sdl_audio_write(void *data, const void *buf, size_t size)
+{
+   ssize_t ret      = 0;
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+
+   if (sdl->nonblock)
+   {
+      size_t avail, write_amt;
+
+      SDL_LockAudio();
+      avail = FIFO_WRITE_AVAIL(sdl->buffer);
+      write_amt = avail > size ? size : avail;
+      fifo_write(sdl->buffer, buf, write_amt);
+      SDL_UnlockAudio();
+      ret = write_amt;
+   }
+   else
+   {
+      size_t written = 0;
+
+      while (written < size)
+      {
+         size_t avail;
+
+         SDL_LockAudio();
+         avail = FIFO_WRITE_AVAIL(sdl->buffer);
+
+         if (avail < (sdl->bufsize/2))
+         {
+            SDL_UnlockAudio();
+#ifdef HAVE_THREADS
+            slock_lock(sdl->lock);
+            scond_wait(sdl->cond, sdl->lock);
+            slock_unlock(sdl->lock);
+#endif
+         }
+         else
+         {
+            size_t write_amt = size - written > avail ? avail : size - written;
+            fifo_write(sdl->buffer, (const char*)buf + written, write_amt);
+            SDL_UnlockAudio();
+            written += write_amt;
+         }
+      }
+      ret = written;
+   }
+
+   return ret;
+}
+
+static bool sdl_audio_stop(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   SDL_PauseAudio(1);
+   sdl->is_paused = true;
+   return true;
+}
+
+static bool sdl_audio_alive(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   return !sdl->is_paused;
+}
+
+static bool sdl_audio_start(void *data, bool is_shutdown)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   SDL_PauseAudio(0);
+   sdl->is_paused = false;
+   return true;
+}
+
+static void sdl_audio_set_nonblock_state(void *data, bool state)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   sdl->nonblock = state;
+}
+
+static void sdl_audio_free(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+
+   SDL_CloseAudio();
+
+   fifo_free(sdl->buffer);
+#ifdef HAVE_THREADS
+   slock_free(sdl->lock);
+   scond_free(sdl->cond);
+#endif
+   free(sdl);
+}
+
+static bool sdl_audio_use_float(void *data)
+{
+   (void)data;
+   return false;
+}
+
+static size_t sdl_audio_write_avail(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   SDL_LockAudio();
+   size_t avail = FIFO_WRITE_AVAIL(sdl->buffer);
+   SDL_UnlockAudio();
+   return avail;
+}
+
+static size_t sdl_audio_buffer_size(void *data)
+{
+   sdl_audio_t *sdl = (sdl_audio_t*)data;
+   return sdl->bufsize;
+}
+
+audio_driver_t audio_sdl = {
+   sdl_audio_init,
+   sdl_audio_write,
+   sdl_audio_stop,
+   sdl_audio_start,
+   sdl_audio_alive,
+   sdl_audio_set_nonblock_state,
+   sdl_audio_free,
+   sdl_audio_use_float,
+#ifdef HAVE_SDL2
+   "sdl2",
+#else
+   "sdl",
+#endif
+   NULL,
+   NULL,
+   sdl_audio_write_avail,
+   sdl_audio_buffer_size,
+};
diff --git a/dingux/dingux_utils.c b/dingux/dingux_utils.c
index b50b9c566a..e6a43537d6 100644
--- a/dingux/dingux_utils.c
+++ b/dingux/dingux_utils.c
@@ -22,7 +22,10 @@
 #if defined(RS90)
 #include <lists/dir_list.h>
 #endif
-
+#if defined(MIYOOMINI)
+#include "sys/ioctl.h"
+#include <fcntl.h>
+#endif
 #include <stdlib.h>
 
 #include "dingux_utils.h"
@@ -53,9 +56,6 @@
 /* Miyoo defines */
 #define MIYOO_BATTERY_VOLTAGE_NOW_FILE    "/sys/class/power_supply/miyoo-battery/voltage_now"
 
-/* RetroFW */
-#define RETROFW_BATTERY_VOLTAGE_NOW_FILE "/proc/jz/battery"
-
 /* Enables/disables downscaling when using
  * the IPU hardware scaler */
 bool dingux_ipu_set_downscaling_enable(bool enable)
@@ -250,67 +250,6 @@ bool dingux_ipu_reset(void)
 #endif
 }
 
-#if defined(RETROFW)
-static uint64_t read_battery_ignore_size(const char *path)
-{
-   int64_t file_len   = 0;
-   char file_buf[20];
-   int sys_file_value = 0;
-   RFILE *file;
-
-   /* Check whether file exists */
-   if (!path_is_valid(path))
-      return -1;
-
-   memset(file_buf, 0, sizeof(file_buf));
-
-   if (!(file = filestream_open(path,
-         RETRO_VFS_FILE_ACCESS_READ,
-         RETRO_VFS_FILE_ACCESS_HINT_NONE)))
-      return -1;
-
-   file_len = filestream_read(file, file_buf, sizeof(file_buf) - 1);
-   if (filestream_close(file) != 0)
-      if (file)
-         free(file);
-
-   if (file_len <= 0)
-      return -1;
-
-   return strtoul(file_buf, NULL, 10);
-}
-
-int retrofw_get_battery_level(enum frontend_powerstate *state)
-{
-   /* retrofw battery only provides "voltage_now". Values are based on gmenu2x with some interpolation */
-   uint32_t rawval = read_battery_ignore_size(RETROFW_BATTERY_VOLTAGE_NOW_FILE);
-   int voltage_now = rawval & 0x7fffffff;
-   if (voltage_now > 10000)
-   {
-      *state = FRONTEND_POWERSTATE_NONE;
-      return -1;
-   }
-   if (rawval & 0x80000000)
-   {
-      *state = FRONTEND_POWERSTATE_CHARGING;
-      if (voltage_now > 4000)
-         *state = FRONTEND_POWERSTATE_CHARGED;
-   }
-   else
-      *state = FRONTEND_POWERSTATE_ON_POWER_SOURCE;
-   if (voltage_now < 0)
-      return -1; /* voltage_now not available */
-   if (voltage_now > 4000)
-      return 100;
-   if (voltage_now > 3700)
-      return 40 + (voltage_now - 3700) / 5;
-   if (voltage_now > 3520)
-      return 20 + (voltage_now - 3520) / 9;
-   if (voltage_now > 3330)
-      return 1 + (voltage_now - 3330) * 10;
-   return 0;
-}
-#else
 static int dingux_read_battery_sys_file(const char *path)
 {
    int64_t file_len   = 0;
@@ -373,6 +312,36 @@ int dingux_get_battery_level(void)
       return -1;
 
    return (int)(((voltage_now - voltage_min) * 100) / (voltage_max - voltage_min));
+#elif defined(MIYOOMINI)
+   typedef struct {
+      int channel_value;
+      int adc_value;
+   } SAR_ADC_CONFIG_READ;
+   #define SARADC_IOC_MAGIC                     'a'
+   #define IOCTL_SAR_INIT                       _IO(SARADC_IOC_MAGIC, 0)
+   #define IOCTL_SAR_SET_CHANNEL_READ_VALUE     _IO(SARADC_IOC_MAGIC, 1)
+   static SAR_ADC_CONFIG_READ  adcCfg = {0,0};
+   static int sar_fd = 0;
+   if (!sar_fd) {
+      sar_fd = open("/dev/sar", O_WRONLY);
+      ioctl(sar_fd, IOCTL_SAR_INIT, NULL);
+   }
+   ioctl(sar_fd, IOCTL_SAR_SET_CHANNEL_READ_VALUE, &adcCfg);
+
+   int percBat = 0;
+   if (adcCfg.adc_value >= 528){
+      percBat = adcCfg.adc_value-478;
+   }
+   else if ((adcCfg.adc_value >= 512) && (adcCfg.adc_value < 528)){
+      percBat = (int)(adcCfg.adc_value*2.125-1068);
+   }
+   else if ((adcCfg.adc_value >= 480) && (adcCfg.adc_value < 512)){
+      percBat = (int)(adcCfg.adc_value* 0.51613 - 243.742);
+   }
+   if (percBat>100){
+      percBat=100;
+   }
+   return  percBat;
 #elif defined(MIYOO)
    /* miyoo-battery only provides "voltage_now". Results are based on
     * value distribution while running a game at max load. */
@@ -408,7 +377,6 @@ int dingux_get_battery_level(void)
    return dingux_read_battery_sys_file(DINGUX_BATTERY_CAPACITY_FILE);
 #endif
 }
-#endif
 
 /* Fetches the path of the base 'retroarch'
  * directory */
diff --git a/gfx/drivers/miyoomini/gfx.c b/gfx/drivers/miyoomini/gfx.c
new file mode 100644
index 0000000000..f040a436bf
--- /dev/null
+++ b/gfx/drivers/miyoomini/gfx.c
@@ -0,0 +1,925 @@
+#include <stdio.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <pthread.h>
+#include <linux/fb.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <SDL/SDL.h>
+#include <sdkdir/mi_sys.h>
+#include <sdkdir/mi_gfx.h>
+
+#define	pixelsPa	unused1
+#define ALIGN4K(val)	((val+4095)&(~4095))
+//	FREEMMA		: force free all allocated MMAs when init & quit
+//#define FREEMMA
+//	GFX_BLOCKING	: limit to 60fps but never skips frames
+//			:  in case of clearing all buffers by GFX_Flip()x3, needs to use BLOCKING (or GFX_FlipForce())
+//	GFX_FLIPWAIT	: wait until Blit is done when flip
+//			:  when NOWAIT, do not clear/write source surface immediately after Flip
+//			:  if absolutely necessary, use GFX_WaitAllDone() before write (or GFX_FlipWait())
+enum { GFX_BLOCKING = 1, GFX_FLIPWAIT = 2 };
+//#define	DEFAULTFLIPFLAGS	(GFX_BLOCKING | GFX_FLIPWAIT)		// low performance with blocking
+//#define	DEFAULTFLIPFLAGS	(GFX_FLIPWAIT)				// middle performance nonblock, recommended for most cases
+#define	DEFAULTFLIPFLAGS	0					// high performance but with the above precautions
+
+int			fd_fb = 0;
+void			*fb_addr;
+struct			fb_fix_screeninfo finfo;
+struct			fb_var_screeninfo vinfo;
+MI_GFX_Surface_t	stSrc;
+MI_GFX_Rect_t		stSrcRect;
+MI_GFX_Surface_t	stDst;
+MI_GFX_Rect_t		stDstRect;
+MI_GFX_Opt_t		stOpt;
+volatile uint32_t	now_flipping;
+MI_PHY			shadowPa;
+uint32_t		shadowsize;
+pthread_t		flip_pt;
+pthread_mutex_t		flip_mx;
+pthread_cond_t		flip_req;
+pthread_cond_t		flip_start;
+MI_U16			flipFence;
+uint32_t		flipFlags;
+SDL_Surface		*sHWsurface;
+SDL_Surface		*videosurface;
+MI_GFX_Surface_t	sHW;
+MI_GFX_Rect_t		sHWRect;
+MI_GFX_Opt_t		sHWOpt;
+void			(*flip_callback)(void*) = NULL;
+void			*userdata_callback = NULL;
+#ifndef	FREEMMA
+#define			MMADBMAX	100
+uint32_t		mma_db[MMADBMAX];
+#endif
+
+//
+//	Actual Flip thread
+//
+static void* GFX_FlipThread(void* param) {
+	uint32_t	target_offset;
+	MI_U16		Fence;
+	pthread_mutex_lock(&flip_mx);
+	while(1) {
+		while (!now_flipping) pthread_cond_wait(&flip_req, &flip_mx);
+		Fence = flipFence;
+		do {	target_offset = vinfo.yoffset + 480;
+			if ( target_offset == 1440 ) target_offset = 0;
+			vinfo.yoffset = target_offset;
+			pthread_cond_signal(&flip_start);
+			pthread_mutex_unlock(&flip_mx);
+			if (flip_callback) {
+				// Wait done always when callback is active
+				MI_GFX_WaitAllDone(FALSE, flipFence); Fence = 0;
+				flip_callback(userdata_callback);
+			} else if (Fence) { MI_GFX_WaitAllDone(FALSE, Fence); Fence = 0; }
+			ioctl(fd_fb, FBIOPAN_DISPLAY, &vinfo);
+			pthread_mutex_lock(&flip_mx);
+		} while(--now_flipping);
+	}
+	return 0;
+}
+
+//
+//	Actual Flip thread ( for single HW surface )
+//		blit from sHWsurface to FB every frame
+//
+static void* GFX_FlipThreadSingleHW(void* param) {
+	MI_GFX_Surface_t Src = sHW;
+	MI_GFX_Rect_t SrcRect = sHWRect;
+	MI_GFX_Surface_t Dst = stDst;
+	MI_GFX_Rect_t DstRect = stDstRect;
+	MI_U16 Fence;
+	uint32_t sHWsize4K = ALIGN4K(sHWsurface->pitch * sHWsurface->h);
+	uint32_t target_offset;
+
+	while(1) {
+		MI_SYS_FlushInvCache(sHWsurface->pixels, sHWsize4K);
+		target_offset = vinfo.yoffset ^ 480;
+		Dst.phyAddr = finfo.smem_start + (640*target_offset*4);
+		MI_GFX_BitBlit(&Src, &SrcRect, &Dst, &DstRect, &stOpt, &Fence);
+		usleep(0x2000);	// wait about 10ms
+		vinfo.yoffset = target_offset;
+		if (flip_callback) flip_callback(userdata_callback);
+		ioctl(fd_fb, FBIOPAN_DISPLAY, &vinfo);
+	}
+	return 0;
+}
+
+//
+//	Get GFX_ColorFmt from SDL_Surface
+//
+static inline MI_GFX_ColorFmt_e	GFX_ColorFmt(SDL_Surface *surface) {
+	if (surface) {
+		if (surface->format->BytesPerPixel == 2) {
+			if (surface->format->Amask == 0x0000) return E_MI_GFX_FMT_RGB565;
+			if (surface->format->Amask == 0x8000) return E_MI_GFX_FMT_ARGB1555;
+			if (surface->format->Amask == 0xF000) return E_MI_GFX_FMT_ARGB4444;
+			if (surface->format->Amask == 0x0001) return E_MI_GFX_FMT_RGBA5551;
+			if (surface->format->Amask == 0x000F) return E_MI_GFX_FMT_RGBA4444;
+			return E_MI_GFX_FMT_RGB565;
+		}
+		if (surface->format->Bmask == 0x000000FF) return E_MI_GFX_FMT_ARGB8888;
+		if (surface->format->Rmask == 0x000000FF) return E_MI_GFX_FMT_ABGR8888;
+	}
+	return E_MI_GFX_FMT_ARGB8888;
+}
+
+//
+//	Get SYS_PixelFormat from SDL_Surface
+//
+static inline MI_SYS_PixelFormat_e	SYS_PixelFormat(SDL_Surface *surface) {
+	if (surface) {
+		if (surface->format->BytesPerPixel == 2) {
+			if (surface->format->Amask == 0x0000) return E_MI_SYS_PIXEL_FRAME_RGB565;
+			if (surface->format->Amask == 0x8000) return E_MI_SYS_PIXEL_FRAME_ARGB1555;
+			if (surface->format->Amask == 0xF000) return E_MI_SYS_PIXEL_FRAME_ARGB4444;
+			return E_MI_SYS_PIXEL_FRAME_RGB565;
+		}
+		if (surface->format->Bmask == 0x000000FF) return E_MI_SYS_PIXEL_FRAME_ARGB8888;
+		if (surface->format->Rmask == 0x000000FF) return E_MI_SYS_PIXEL_FRAME_ABGR8888;
+		if (surface->format->Amask == 0x000000FF) return E_MI_SYS_PIXEL_FRAME_BGRA8888;
+	}
+	return E_MI_SYS_PIXEL_FRAME_ARGB8888;
+}
+
+//
+//	Flush write cache of needed segments
+//		x and w are not considered since 4K units
+//
+static inline void FlushCacheNeeded(void* pixels, uint32_t pitch, uint32_t y, uint32_t h) {
+	uintptr_t pixptr = (uintptr_t)pixels;
+	uintptr_t startaddress = (pixptr + pitch*y)&(~4095);
+	uint32_t size = ALIGN4K(pixptr + pitch*(y+h)) - startaddress;
+	if (size) MI_SYS_FlushInvCache((void*)startaddress, size);
+}
+
+//
+//	GFX Flip / in place of SDL_Flip
+//		HW Blit : surface -> FB(backbuffer) with Rotate180/bppConvert/Scaling
+//			and Request Flip
+//		*Note* blit from entire surface(or clip_rect if specified) to entire framebuffer(or sHWsurface)
+//
+void	GFX_FlipExec(SDL_Surface *surface, uint32_t flags) {
+	uint32_t	target_offset, surfacesize;
+
+	if ((fd_fb)&&(surface)&&(surface->pixelsPa)) {
+		surfacesize = surface->pitch * surface->h;
+		stSrc.eColorFmt = GFX_ColorFmt(surface);
+		stSrc.u32Width = surface->w;
+		stSrc.u32Height = surface->h;
+		stSrc.u32Stride = surface->pitch;
+		if (surface->clip_rect.w|surface->clip_rect.h) {
+			// when clip_rect is specified
+			stSrcRect.s32Xpos = surface->clip_rect.x;
+			stSrcRect.s32Ypos = surface->clip_rect.y;
+			stSrcRect.u32Width = surface->clip_rect.w;
+			stSrcRect.u32Height = surface->clip_rect.h;
+		} else {// entire screen
+			stSrcRect.s32Xpos = 0;
+			stSrcRect.s32Ypos = 0;
+			stSrcRect.u32Width = stSrc.u32Width;
+			stSrcRect.u32Height = stSrc.u32Height;
+		}
+
+		if (sHWsurface) {
+			if (surface != sHWsurface) {
+				// blit to sHWsurface when direct draw mode
+				MI_U16 Fence;
+				stSrc.phyAddr = surface->pixelsPa;
+				FlushCacheNeeded(surface->pixels, surface->pitch, stSrcRect.s32Ypos, stSrcRect.u32Height);
+				MI_GFX_BitBlit(&stSrc, &stSrcRect, &sHW, &sHWRect, &sHWOpt, &Fence);
+			}
+			return;
+		}
+
+		if (flags & GFX_FLIPWAIT) {
+			// wait for recent flip is done
+			if (flipFence) MI_GFX_WaitAllDone(FALSE, flipFence);
+			// prepare intermediate buffer if needed
+			if (shadowsize < surfacesize) {
+				if (shadowPa) MI_SYS_MMA_Free(shadowPa);
+				if (MI_SYS_MMA_Alloc(NULL, ALIGN4K(surfacesize), &shadowPa)) {
+					shadowPa = shadowsize = 0; goto NOWAIT;
+				}
+				shadowsize = surfacesize;
+			}
+			// copy surface to intermediate buffer
+			uint32_t ofs = surface->pitch * stSrcRect.s32Ypos;
+			uint32_t size = surface->pitch * stSrcRect.u32Height;
+			MI_SYS_FlushInvCache((uint8_t*)surface->pixels + ofs, ALIGN4K(size));
+			MI_SYS_MemcpyPa(shadowPa + ofs, surface->pixelsPa + ofs, size);
+			// blit from intermediate buffer
+			stSrc.phyAddr = shadowPa;
+		} else {
+		NOWAIT:	FlushCacheNeeded(surface->pixels, surface->pitch, stSrcRect.s32Ypos, stSrcRect.u32Height);
+			stSrc.phyAddr = surface->pixelsPa;
+		}
+
+		pthread_mutex_lock(&flip_mx);
+		if (flags & GFX_BLOCKING) {
+			while (now_flipping == 2) pthread_cond_wait(&flip_start, &flip_mx);
+		}
+		target_offset = vinfo.yoffset + 480;
+		if ( target_offset == 1440 ) target_offset = 0;
+		stDst.phyAddr = finfo.smem_start + (640*target_offset*4);
+		MI_GFX_BitBlit(&stSrc, &stSrcRect, &stDst, &stDstRect, &stOpt, &flipFence);
+
+		// Request Flip
+		if (!now_flipping) {
+			now_flipping = 1;
+			pthread_cond_signal(&flip_req);
+			pthread_cond_wait(&flip_start, &flip_mx);
+		} else {
+			now_flipping = 2;
+		}
+		pthread_mutex_unlock(&flip_mx);
+	}
+}
+void	GFX_Flip(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags); }
+void	GFX_FlipNoWait(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags & ~GFX_FLIPWAIT); }
+void	GFX_FlipWait(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags | GFX_FLIPWAIT); }
+void	GFX_FlipForce(SDL_Surface *surface) { GFX_FlipExec(surface, flipFlags | GFX_BLOCKING); }
+
+//
+//	Get/Set Flipflags
+//		GFX_BLOCKING/GFX_FLIPWAIT flags used for GFX_Flip/UpdateRect
+//
+uint32_t	GFX_GetFlipFlags(void) { return flipFlags; }
+void		GFX_SetFlipFlags(uint32_t flags) { flipFlags = flags; }
+
+//
+//	Get/Set Flip callback, for use direct draw to framebuffer
+//		(Battery icon, RetroArch OSD text, etc)
+//		*Note* framebuffer is rotated 180 degrees
+//
+void*	GFX_GetFlipCallback(void) { return (void*)flip_callback; }
+void	GFX_SetFlipCallback(void (*callback)(void*), void *userdata) {
+	userdata_callback = userdata; flip_callback = callback;
+}
+
+#ifdef	FREEMMA
+//
+//	Free all allocated MMAs (except "daemon")
+//
+void	freemma(void) {
+	FILE		*fp;
+	const char	*heapinfoname = "/proc/mi_modules/mi_sys_mma/mma_heap_name0";
+	char		str[256];
+	uint32_t	offset, length, usedflag;
+	uint32_t	baseaddr = finfo.smem_start - 0x021000;	// default baseaddr (tmp)
+
+	// open heap information file
+	fp = fopen(heapinfoname, "r");
+	if (fp) {
+		// skip reading until chunk information
+		do { if (fscanf(fp, "%255s", str) == EOF) { fclose(fp); return; } } while (strcmp(str,"sys-logConfig"));
+		// get MMA each chunk information and release
+		while(fscanf(fp, "%x %x %x %255s", &offset, &length, &usedflag, str) != EOF) {
+			if (!usedflag) continue; // NA
+			if (!strcmp(str,"fb_device")) { // FB .. fix baseaddr
+				baseaddr = finfo.smem_start - offset; continue;
+			}
+			if (!strcmp(str,"ao-Dev0-tmp")) continue; // ao .. Audio buffer, skip
+			// For daemon program authors, MMA allocated as "daemon" will not be released
+			if (strncmp(str,"daemon",6)) { // others except "daemon" .. release
+				if (!MI_SYS_MMA_Free(baseaddr + offset)) {
+					fprintf(stderr, "MMA_Released %s offset : %08X length : %08X\n", str, offset, length);
+				}
+			}
+		}
+		fclose(fp);
+	}
+}
+#endif
+
+//
+//	Create GFX Surface / in place of SDL_CreateRGBSurface
+//		supports 16/32bpp only / flags has no meaning, fixed to SWSURFACE
+//		Additional return value : surface->unused1 = Physical address of surface
+//
+SDL_Surface*	GFX_CreateRGBSurface(uint32_t flags, int width, int height, int depth, uint32_t Rmask, uint32_t Gmask, uint32_t Bmask, uint32_t Amask) {
+	SDL_Surface*	surface;
+	MI_PHY		phyAddr;
+	void*		virAddr;
+	if (!width) width = 640;
+	if (!height) height = 480;
+	if (depth != 16) depth = 32;
+	int		pitch = width * (uint32_t)(depth/8);
+	uint32_t	size = pitch * height;
+
+	if (MI_SYS_MMA_Alloc(NULL, ALIGN4K(size), &phyAddr)) {
+		// No MMA left .. create normal SDL surface
+		return SDL_CreateRGBSurface(flags,width,height,depth,Rmask,Gmask,Bmask,Amask);
+	}
+#ifndef	FREEMMA
+	uint32_t i;
+	for (i=0; i<MMADBMAX; i++) {
+		if (!mma_db[i]) {
+			mma_db[i] = phyAddr; break;
+		}
+	} if (i==MMADBMAX) { MI_SYS_MMA_Free(phyAddr); return NULL; }
+#endif
+	MI_SYS_Mmap(phyAddr, ALIGN4K(size), &virAddr, TRUE);	// write cache ON needs Flush when r/w Pa directly
+
+	surface = SDL_CreateRGBSurfaceFrom(virAddr,width,height,depth,pitch,Rmask,Gmask,Bmask,Amask);
+	if (surface) {
+		surface->pixelsPa = phyAddr;
+		memset(surface->pixels, 0, size);
+	}
+	return surface;
+}
+
+//
+//	Free GFX Surface / in place of SDL_FreeSurface
+//
+void	GFX_FreeSurface(SDL_Surface *surface) {
+	if (surface) {
+		MI_PHY		phyAddr = surface->pixelsPa;
+		void*		virAddr = surface->pixels;
+		uint32_t	size = surface->pitch * surface->h;
+
+		// stop flip thread when sHWsurface is freed
+		if (surface == sHWsurface) {
+			pthread_cancel(flip_pt);
+			pthread_join(flip_pt, NULL);
+			sHWsurface = NULL;
+		}
+
+		SDL_FreeSurface(surface);
+		if (phyAddr) {
+			MI_SYS_Munmap(virAddr, ALIGN4K(size));
+			MI_SYS_MMA_Free(phyAddr);
+#ifndef	FREEMMA
+			for (uint32_t i=0; i<MMADBMAX; i++) {
+				if (mma_db[i] == phyAddr) {
+					mma_db[i] = 0; break;
+				}
+			}
+#endif
+		}
+	}
+}
+
+//
+//	Clear entire FrameBuffer
+//
+void	GFX_ClearFrameBuffer(void) { memset(fb_addr, 0, finfo.smem_len); }
+
+//
+//	GFX Init / Prepare for HW Blit to FB, call after SDL_Init
+//
+void	GFX_Init(void) {
+	if (!fd_fb) {
+		MI_SYS_Init();
+		MI_GFX_Open();
+		fd_fb = open("/dev/fb0", O_RDWR);
+
+		// 640 x 480 x 32bpp x 3screen init
+		SDL_SetVideoMode(640, 480, 32, SDL_SWSURFACE);
+		ioctl(fd_fb, FBIOGET_VSCREENINFO, &vinfo);
+		vinfo.yres_virtual = 1440; vinfo.yoffset = 0;
+		/* vinfo.xres = vinfo.xres_virtual = 640; vinfo.yres = 480;
+		vinfo.xoffset = vinfo.yoffset = vinfo.red.msb_right = vinfo.green.msb_right = 
+		vinfo.blue.msb_right = vinfo.transp.msb_right = vinfo.blue.offset = 0;
+		vinfo.red.length = vinfo.green.length = vinfo.blue.length = vinfo.transp.length = vinfo.green.offset = 8;
+		vinfo.red.offset = 16; vinfo.transp.offset = 24; vinfo.bits_per_pixel = 32; */
+		ioctl(fd_fb, FBIOPUT_VSCREENINFO, &vinfo);
+
+		// get physical address of FB
+		ioctl(fd_fb, FBIOGET_FSCREENINFO, &finfo);
+
+		// map fb memory
+		fb_addr = mmap(0, finfo.smem_len, PROT_READ | PROT_WRITE, MAP_SHARED, fd_fb, 0);
+
+		// clear entire FB
+		GFX_ClearFrameBuffer();
+#ifdef	FREEMMA
+		freemma();
+#else
+		memset(mma_db, 0, sizeof(mma_db));
+#endif
+		// prepare for Flip
+		stDst.phyAddr = finfo.smem_start;
+		stDst.eColorFmt = E_MI_GFX_FMT_ARGB8888;
+		stDst.u32Width = 640;
+		stDst.u32Height = 480;
+		stDst.u32Stride = 640*4;
+		stDstRect.s32Xpos = 0;
+		stDstRect.s32Ypos = 0;
+		stDstRect.u32Width = 640;
+		stDstRect.u32Height = 480;
+
+		memset(&stOpt, 0, sizeof(stOpt));
+		stOpt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
+		stOpt.eRotate = E_MI_GFX_ROTATE_180;
+
+		flip_mx = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
+		flip_req = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+		flip_start = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+		now_flipping = shadowPa = shadowsize = flipFence = 0;
+		sHWsurface = videosurface = NULL;
+		flipFlags = DEFAULTFLIPFLAGS;
+		pthread_create(&flip_pt, NULL, GFX_FlipThread, NULL);
+	}
+}
+
+//
+//	GFX Quit / call before SDL_Quit
+//
+void	GFX_Quit(void) {
+	if (fd_fb) {
+		pthread_cancel(flip_pt);
+		pthread_join(flip_pt, NULL);
+
+		MI_GFX_WaitAllDone(TRUE, 0);
+		if (sHWsurface) { SDL_Surface* sHWpush = sHWsurface; sHWsurface = NULL; GFX_FreeSurface(sHWpush); }
+		if (videosurface) { GFX_FreeSurface(videosurface); videosurface = NULL; }
+		if (shadowPa) { MI_SYS_MMA_Free(shadowPa); shadowPa = 0; }
+#ifdef	FREEMMA
+		freemma();
+#else
+		for (uint32_t i=0; i<MMADBMAX; i++) {
+			if (mma_db[i]) {
+				if (!MI_SYS_MMA_Free(mma_db[i])) {
+					fprintf(stderr, "MMA_Released offset : %08X\n", mma_db[i]);
+					mma_db[i] = 0;
+				}
+			}
+		}
+#endif
+		// clear entire FB
+		GFX_ClearFrameBuffer();
+
+		// reset yoffset
+		vinfo.yoffset = 0;
+		ioctl(fd_fb, FBIOPUT_VSCREENINFO, &vinfo);
+
+		// unmap fb memory
+		munmap(fb_addr, finfo.smem_len);
+
+		close(fd_fb);
+		fd_fb = 0;
+
+		MI_GFX_Close();
+		MI_SYS_Exit();
+	}
+}
+
+//
+//	SetVideomode / in place of SDL_SetVideoMode
+//		if flags == SDL_HWSURFACE & non SDL_DOUBLEBUF, change to direct draw mode
+//		 otherwise, same as GFX_CreateRGBSurface
+//
+SDL_Surface*	GFX_SetVideoMode(int width, int height, int bpp, uint32_t flags) {
+	if (!fd_fb) GFX_Init();
+	if (!width) width = 640;
+	if (!height) height = 480;
+	if (bpp != 16) bpp = 32;
+
+	// reinit Flip thread
+	pthread_cancel(flip_pt);
+	pthread_join(flip_pt, NULL);
+	MI_GFX_WaitAllDone(TRUE, 0);
+	if (sHWsurface) { SDL_Surface* sHWpush = sHWsurface; sHWsurface = NULL; GFX_FreeSurface(sHWpush); }
+	if (videosurface) { GFX_FreeSurface(videosurface); videosurface = NULL; }
+	if (shadowPa) { MI_SYS_MMA_Free(shadowPa); shadowPa = shadowsize = 0; }
+	flip_mx = (pthread_mutex_t)PTHREAD_MUTEX_INITIALIZER;
+	flip_req = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+	flip_start = (pthread_cond_t)PTHREAD_COND_INITIALIZER;
+	now_flipping = flipFence = vinfo.yoffset = 0;
+	GFX_ClearFrameBuffer();
+	ioctl(fd_fb, FBIOPAN_DISPLAY, &vinfo);
+
+	if ((flags&SDL_HWSURFACE)&&(!(flags&SDL_DOUBLEBUF))) {
+		// single HW surface, direct draw mode
+		sHWsurface = GFX_CreateRGBSurface(flags, width, height, bpp, 0,0,0,0);
+		if (sHWsurface) {
+			sHW.phyAddr = sHWsurface->pixelsPa;
+			sHW.u32Width = sHWsurface->w;
+			sHW.u32Height = sHWsurface->h;
+			sHW.u32Stride = sHWsurface->pitch;
+			sHW.eColorFmt = GFX_ColorFmt(sHWsurface);
+			sHWRect.s32Xpos = 0;
+			sHWRect.s32Ypos = 0;
+			sHWRect.u32Width = sHW.u32Width;
+			sHWRect.u32Height = sHW.u32Height;
+			memset(&sHWOpt, 0, sizeof(sHWOpt));
+			sHWOpt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
+			pthread_create(&flip_pt, NULL, GFX_FlipThreadSingleHW, NULL);
+		} else pthread_create(&flip_pt, NULL, GFX_FlipThread, NULL);
+		return sHWsurface;
+	} else {
+		// others
+		pthread_create(&flip_pt, NULL, GFX_FlipThread, NULL);
+		videosurface = GFX_CreateRGBSurface(flags, width, height, bpp, 0,0,0,0);
+		return videosurface;
+	}
+}
+
+//
+//	Clear GFX/SDL Surface (entire)
+//
+void	GFX_ClearSurface(SDL_Surface *surface) {
+	if (surface) {
+		uint32_t size = surface->pitch * surface->h;
+		memset(surface->pixels, 0, size);
+	}
+}
+
+//
+//	Copy GFX/SDL Surface (entire)
+//		src/dst surfaces must be the same size
+//
+void	GFX_CopySurface(SDL_Surface *src, SDL_Surface *dst) {
+	if ((src)&&(dst)) {
+		uint32_t size = src->pitch * src->h;
+		if (size == (uint32_t)(dst->pitch * dst->h)) {
+			if ((src->pixelsPa)&&(dst->pixelsPa)) {
+				MI_SYS_FlushInvCache(src->pixels, ALIGN4K(size));
+				MI_SYS_FlushInvCache(dst->pixels, ALIGN4K(size));
+				MI_SYS_MemcpyPa(dst->pixelsPa, src->pixelsPa, size);
+			} else {
+				memcpy(dst->pixels, src->pixels, size);
+			}
+		}
+	}
+}
+
+//
+//	Rotate 640x480x32bpp surface NEON / for duplicate FB
+//
+void	RotateSurfaceNEON(void* src) {
+	asm volatile (
+	"	add r1,%0,#(640*240*4)	;"
+	"	mov r2,r1		;"
+	"	mov r3,r1		;"
+	"1:	vldmia r1,{q0-q7}	;"
+	"	vrev64.32 d31,d0	;"
+	"	vrev64.32 d30,d1	;"
+	"	vrev64.32 d29,d2	;"
+	"	vrev64.32 d28,d3	;"
+	"	vrev64.32 d27,d4	;"
+	"	vrev64.32 d26,d5	;"
+	"	vrev64.32 d25,d6	;"
+	"	vrev64.32 d24,d7	;"
+	"	vrev64.32 d23,d8	;"
+	"	vrev64.32 d22,d9	;"
+	"	vrev64.32 d21,d10	;"
+	"	vrev64.32 d20,d11	;"
+	"	vrev64.32 d19,d12	;"
+	"	vrev64.32 d18,d13	;"
+	"	vrev64.32 d17,d14	;"
+	"	vrev64.32 d16,d15	;"
+	"	vldmdb r3!,{q0-q7}	;"
+	"	vstmdb r2!,{q8-q15}	;"
+	"	vrev64.32 d31,d0	;"
+	"	vrev64.32 d30,d1	;"
+	"	vrev64.32 d29,d2	;"
+	"	vrev64.32 d28,d3	;"
+	"	vrev64.32 d27,d4	;"
+	"	vrev64.32 d26,d5	;"
+	"	vrev64.32 d25,d6	;"
+	"	vrev64.32 d24,d7	;"
+	"	vrev64.32 d23,d8	;"
+	"	vrev64.32 d22,d9	;"
+	"	vrev64.32 d21,d10	;"
+	"	vrev64.32 d20,d11	;"
+	"	vrev64.32 d19,d12	;"
+	"	vrev64.32 d18,d13	;"
+	"	vrev64.32 d17,d14	;"
+	"	vrev64.32 d16,d15	;"
+	"	vstmia r1!,{q8-q15}	;"
+	"	cmp %0,r2		;"
+	"	bne 1b			"
+	:: "r"(src)
+	: "r1","r2","r3","q0","q1","q2","q3","q4","q5","q6","q7",
+	    "q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+//
+//	Duplicate GFX Surface from SDL_Surface or FB
+//		if src is NULL, duplicate from FB currently displayed
+//
+SDL_Surface*	GFX_DuplicateSurface(SDL_Surface *src) {
+	SDL_Surface	*dst;
+	if (src) {
+		dst = GFX_CreateRGBSurface(0, src->w, src->h, src->format->BitsPerPixel,
+			src->format->Rmask, src->format->Gmask, src->format->Bmask, src->format->Amask);
+		if (dst) GFX_CopySurface(src, dst);
+	} else {
+		dst = GFX_CreateRGBSurface(0, 640, 480, 32, 0,0,0,0);
+		if (dst) {
+			MI_GFX_WaitAllDone(TRUE, 0);
+			MI_SYS_MemcpyPa(dst->pixelsPa, finfo.smem_start + 640*vinfo.yoffset*4, 640*480*4);
+			RotateSurfaceNEON(dst->pixels);
+		}
+	}
+	return dst;
+}
+
+//
+//	GFX UpdateRect / in place of SDL_UpdateRect
+//		Flip after setting the update area
+//		*Note* blit from entire screen(or clip_rect if specified) to framebuffer(or sHWsurface) rect
+//
+void	GFX_UpdateRectExec(SDL_Surface *screen, int x, int y, int w, int h, uint32_t flags) {
+	if ((fd_fb)&&(screen)&&(screen->pixelsPa)) {
+		if (x|y|w|h) {
+			if (!sHWsurface) {
+				MI_GFX_Rect_t DstRectPush = stDstRect;
+				// for rotate180
+				stDstRect.s32Xpos = 640-(x+w);
+				stDstRect.s32Ypos = 480-(y+h);
+				// for RetroArch rotate function
+				stDstRect.u32Width = (stOpt.eRotate&1) ? h : w;
+				stDstRect.u32Height = (stOpt.eRotate&1) ? w : h;
+				GFX_FlipExec(screen, flags);
+				stDstRect = DstRectPush;
+			} else if (screen != sHWsurface) {
+				// direct draw mode, dest = sHWsurface
+				MI_GFX_Rect_t DstRectPush = sHWRect;
+				sHWRect.s32Xpos = x;
+				sHWRect.s32Ypos = y;
+				sHWRect.u32Width = w;
+				sHWRect.u32Height = h;
+				GFX_FlipExec(screen, flags);
+				sHWRect = DstRectPush;
+			}
+		} else {
+			GFX_FlipExec(screen, flags);
+		}
+	}
+}
+void	GFX_UpdateRect(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags); }
+void	GFX_UpdateRectNoWait(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags & ~GFX_FLIPWAIT); }
+void	GFX_UpdateRectWait(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags | GFX_FLIPWAIT); }
+void	GFX_UpdateRectForce(SDL_Surface *screen, int x, int y, int w, int h) {
+	GFX_UpdateRectExec(screen, x, y, w, h, flipFlags | GFX_BLOCKING); }
+
+//
+//	Check Rect Overflow for FillRect/BlitSurfaceSYS
+//
+SDL_Rect* CheckRect(SDL_Surface* dst, SDL_Rect* dstrect) {
+	if ((!dst)||(!dstrect)) return NULL;
+
+	int w = dstrect->w; int h = dstrect->h;
+	if (dst->clip_rect.w|dst->clip_rect.h) {
+		if (dst->clip_rect.x > dstrect->x) {
+			w -= (dst->clip_rect.x - dstrect->x); dstrect->x = dst->clip_rect.x;
+		}
+		if ((dst->clip_rect.x + dst->clip_rect.w) < (dstrect->x + w)) {
+			w = dst->clip_rect.w - (dstrect->x - dst->clip_rect.x);
+		}
+		if (dst->clip_rect.y > dstrect->y) {
+			h -= (dst->clip_rect.y - dstrect->y); dstrect->y = dst->clip_rect.y;
+		}
+		if ((dst->clip_rect.y + dst->clip_rect.h) < (dstrect->y + h)) {
+			h = dst->clip_rect.h - (dstrect->y - dst->clip_rect.y);
+		}
+	}
+	if (dstrect->x < 0) { w += dstrect->x; dstrect->x = 0; }
+	if (dstrect->y < 0) { h += dstrect->y; dstrect->y = 0; }
+	if ((dstrect->x + w) > dst->w) { w = dst->w - dstrect->x; }
+	if ((dstrect->y + h) > dst->h) { h = dst->h - dstrect->y; }
+	if ((w <= 0)||(h <= 0)||(dstrect->x >= dst->w)||(dstrect->y >= dst->h)) return NULL;
+	dstrect->w = w; dstrect->h = h;
+	return dstrect;
+}
+
+//
+//	GFX FillRect (MI_SYS ver) / in place of SDL_FillRect
+//		*Note* color : in case of RGB565 : 2 pixel color values used alternately
+//
+void	GFX_FillRectSYS(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color) {
+	if ((dst)&&(dst->pixelsPa)) {
+		SDL_Rect dstrect_tmp;
+		if (!dstrect) {
+			dstrect_tmp.x = 0;
+			dstrect_tmp.y = 0;
+			dstrect_tmp.w = dst->w;
+			dstrect_tmp.h = dst->h;
+		} else 	memcpy(&dstrect_tmp, dstrect, sizeof(dstrect_tmp));
+		if (!(CheckRect(dst, &dstrect_tmp))) return;
+
+		MI_SYS_FrameData_t Buf;
+		MI_SYS_WindowRect_t Rect;
+
+		Buf.phyAddr[0] = dst->pixelsPa;
+		Buf.u16Width = dst->w;
+		Buf.u16Height = dst->h;
+		Buf.u32Stride[0] = dst->pitch;
+		Buf.ePixelFormat = SYS_PixelFormat(dst);
+		Rect.u16X = dstrect_tmp.x;
+		Rect.u16Y = dstrect_tmp.y;
+		Rect.u16Width = dstrect_tmp.w;
+		Rect.u16Height = dstrect_tmp.h;
+
+		FlushCacheNeeded(dst->pixels, dst->pitch, Rect.u16Y, Rect.u16Height);
+		MI_SYS_BufFillPa(&Buf, color, &Rect);
+	} else 	SDL_FillRect(dst, dstrect, color);
+}
+
+//
+//	GFX FillRect (MI_GFX ver) / in place of SDL_FillRect
+//		*Note* color : in case of RGB565 : ARGB8888 color value
+//		nowait : 0 = wait until done / 1 = no wait
+//
+void	GFX_FillRectExec(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color, uint32_t nowait) {
+	if ((dst)&&(dst->pixelsPa)) {
+		SDL_Rect dstrect_tmp;
+		if (!dstrect) {
+			dstrect_tmp.x = 0;
+			dstrect_tmp.y = 0;
+			dstrect_tmp.w = dst->w;
+			dstrect_tmp.h = dst->h;
+		} else 	memcpy(&dstrect_tmp, dstrect, sizeof(dstrect_tmp));
+		if (!(CheckRect(dst, &dstrect_tmp))) return;
+
+		MI_GFX_Surface_t Dst;
+		MI_GFX_Rect_t DstRect;
+		MI_U16 Fence;
+
+		Dst.phyAddr = dst->pixelsPa;
+		Dst.eColorFmt = GFX_ColorFmt(dst);
+		Dst.u32Width = dst->w;
+		Dst.u32Height = dst->h;
+		Dst.u32Stride = dst->pitch;
+		DstRect.s32Xpos = dstrect_tmp.x;
+		DstRect.s32Ypos = dstrect_tmp.y;
+		DstRect.u32Width = dstrect_tmp.w;
+		DstRect.u32Height = dstrect_tmp.h;
+
+		FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.s32Ypos, DstRect.u32Height);
+		MI_GFX_QuickFill(&Dst, &DstRect, color, &Fence);
+		if (!nowait) MI_GFX_WaitAllDone(FALSE, Fence);
+	} else SDL_FillRect(dst, dstrect, color);
+}
+void	GFX_FillRect(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color) {
+	GFX_FillRectExec(dst, dstrect, color, 0);
+}
+void	GFX_FillRectNoWait(SDL_Surface* dst, SDL_Rect* dstrect, uint32_t color) {
+	GFX_FillRectExec(dst, dstrect, color, 1);
+}
+
+//
+//	GFX_WaitAllDone / wait all done for No Wait functions
+//
+void	GFX_WaitAllDone(void) {
+	MI_GFX_WaitAllDone(TRUE, 0);
+}
+
+//
+//	GFX BlitSurface (MI_SYS ver) / in place of SDL_BlitSurface
+//		*Note* Just a copy (no convert scale/bpp)
+//
+void GFX_BlitSurfaceSYS(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
+	if ((src)&&(dst)&&(src->pixelsPa)&&(dst->pixelsPa)) {
+		MI_SYS_FrameData_t SrcBuf;
+		MI_SYS_FrameData_t DstBuf;
+		MI_SYS_WindowRect_t SrcRect;
+		MI_SYS_WindowRect_t DstRect;
+
+		SDL_Rect srcrect_tmp, dstrect_tmp;
+		if (!srcrect) {
+			srcrect_tmp.x = 0; srcrect_tmp.y = 0;
+			srcrect_tmp.w = src->w; srcrect_tmp.h = src->h;
+		} else 	memcpy(&srcrect_tmp, srcrect, sizeof(srcrect_tmp));
+		if (!dstrect) {
+			dstrect_tmp.x = 0; dstrect_tmp.y = 0;
+			dstrect_tmp.w = dst->w; dstrect_tmp.h = dst->h;
+		} else {
+			if (dstrect->w|dstrect->h) memcpy(&dstrect_tmp, dstrect, sizeof(dstrect_tmp));
+			else {	dstrect_tmp.x = dstrect->x; dstrect_tmp.y = dstrect->y;
+				dstrect_tmp.w = src->w - dstrect->x; dstrect_tmp.h = src->h - dstrect->y;
+			}
+		}
+		// adjust rects from dst surface size and clip_rect
+		if (!(CheckRect(dst, &srcrect_tmp))) return;
+		if (!(CheckRect(dst, &dstrect_tmp))) return;
+
+		memset(&SrcBuf, 0, sizeof(SrcBuf));
+		SrcBuf.phyAddr[0] = src->pixelsPa;
+		SrcBuf.u16Width = src->w;
+		SrcBuf.u16Height = src->h;
+		SrcBuf.u32Stride[0] = src->pitch;
+		SrcBuf.ePixelFormat = SYS_PixelFormat(src);
+		SrcRect.u16X = srcrect_tmp.x;
+		SrcRect.u16Y = srcrect_tmp.y;
+		SrcRect.u16Width = srcrect_tmp.w;
+		SrcRect.u16Height = srcrect_tmp.h;
+
+		memset(&DstBuf, 0, sizeof(DstBuf));
+		DstBuf.phyAddr[0] = dst->pixelsPa;
+		DstBuf.u16Width = dst->w;
+		// **HACK** rect.h is not working properly for some reason, so adjust dst height
+		DstBuf.u16Height = dstrect_tmp.y + dstrect_tmp.h; // dst->h;
+		DstBuf.u32Stride[0] = dst->pitch;
+		DstBuf.ePixelFormat = SYS_PixelFormat(dst);
+		DstRect.u16X = dstrect_tmp.x;
+		DstRect.u16Y = dstrect_tmp.y;
+		DstRect.u16Width = dstrect_tmp.w;
+		DstRect.u16Height = dstrect_tmp.h;
+
+		FlushCacheNeeded(src->pixels, src->pitch, SrcRect.u16Y, SrcRect.u16Height);
+		FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.u16Y, DstRect.u16Height);
+		MI_SYS_BufBlitPa(&DstBuf, &DstRect, &SrcBuf, &SrcRect);
+	} else SDL_BlitSurface(src, srcrect, dst, dstrect);
+}
+
+//
+//	GFX BlitSurface (MI_GFX ver) / in place of SDL_BlitSurface
+//		with scale/bpp convert and rotate/mirror
+//		rotate : 1 = 90 / 2 = 180 / 3 = 270
+//		mirror : 1 = Horizontal / 2 = Vertical / 3 = Both
+//		nowait : 0 = wait until done / 1 = no wait
+//
+void GFX_BlitSurfaceExec(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect,
+			 uint32_t rotate, uint32_t mirror, uint32_t nowait) {
+	if ((src)&&(dst)&&(src->pixelsPa)&&(dst->pixelsPa)) {
+		MI_GFX_Surface_t Src;
+		MI_GFX_Surface_t Dst;
+		MI_GFX_Rect_t SrcRect;
+		MI_GFX_Rect_t DstRect;
+		MI_GFX_Opt_t Opt;
+		MI_U16 Fence;
+
+		memset(&Opt, 0, sizeof(Opt));
+		Opt.eSrcDfbBldOp = E_MI_GFX_DFB_BLD_ONE;
+		Opt.eRotate = (MI_GFX_Rotate_e)rotate;
+		Opt.eMirror = (MI_GFX_Mirror_e)mirror;
+		Opt.stClipRect.s32Xpos = dst->clip_rect.x;
+		Opt.stClipRect.s32Ypos = dst->clip_rect.y;
+		Opt.stClipRect.u32Width = dst->clip_rect.w;
+		Opt.stClipRect.u32Height = dst->clip_rect.h;
+
+		Src.phyAddr = src->pixelsPa;
+		Src.u32Width = src->w;
+		Src.u32Height = src->h;
+		Src.u32Stride = src->pitch;
+		Src.eColorFmt = GFX_ColorFmt(src);
+		if (srcrect) {
+			SrcRect.s32Xpos = srcrect->x;
+			SrcRect.s32Ypos = srcrect->y;
+			SrcRect.u32Width = srcrect->w;
+			SrcRect.u32Height = srcrect->h;
+		} else {
+			SrcRect.s32Xpos = 0;
+			SrcRect.s32Ypos = 0;
+			SrcRect.u32Width = Src.u32Width;
+			SrcRect.u32Height = Src.u32Height;
+		}
+
+		Dst.phyAddr = dst->pixelsPa;
+		Dst.u32Width = dst->w;
+		Dst.u32Height = dst->h;
+		Dst.u32Stride = dst->pitch;
+		Dst.eColorFmt = GFX_ColorFmt(dst);
+		if (dstrect) {
+			DstRect.s32Xpos = dstrect->x;
+			DstRect.s32Ypos = dstrect->y;
+			if (dstrect->w|dstrect->h) {
+				DstRect.u32Width = dstrect->w;
+				DstRect.u32Height = dstrect->h;
+			} else {
+				DstRect.u32Width = SrcRect.u32Width;
+				DstRect.u32Height = SrcRect.u32Height;
+			}
+		} else {
+			DstRect.s32Xpos = 0;
+			DstRect.s32Ypos = 0;
+			DstRect.u32Width = Dst.u32Width;
+			DstRect.u32Height = Dst.u32Height;
+		}
+
+		FlushCacheNeeded(src->pixels, src->pitch, SrcRect.s32Ypos, SrcRect.u32Height);
+		if (rotate & 1) FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.s32Ypos, DstRect.u32Width);
+		else FlushCacheNeeded(dst->pixels, dst->pitch, DstRect.s32Ypos, DstRect.u32Height);
+		MI_GFX_BitBlit(&Src, &SrcRect, &Dst, &DstRect, &Opt, &Fence);
+		if (!nowait) MI_GFX_WaitAllDone(FALSE, Fence);
+	} else SDL_BlitSurface(src, srcrect, dst, dstrect);
+}
+void GFX_BlitSurface(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, 0, 0);
+}
+void GFX_BlitSurfaceNoWait(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, 0, 1);
+}
+void GFX_BlitSurfaceRotate(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t rotate) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, rotate, 0, 0);
+}
+void GFX_BlitSurfaceRotateNoWait(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t rotate) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, rotate, 0, 1);
+}
+void GFX_BlitSurfaceMirror(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t mirror) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, mirror, 0);
+}
+void GFX_BlitSurfaceMirrorNoWait(SDL_Surface *src, SDL_Rect *srcrect, SDL_Surface *dst, SDL_Rect *dstrect, uint32_t mirror) {
+	GFX_BlitSurfaceExec(src, srcrect, dst, dstrect, 0, mirror, 1);
+}
+// TODO: add Alpha blend / Colorkey blit
diff --git a/gfx/drivers/miyoomini/scaler_neon.c b/gfx/drivers/miyoomini/scaler_neon.c
new file mode 100644
index 0000000000..ae11dd7567
--- /dev/null
+++ b/gfx/drivers/miyoomini/scaler_neon.c
@@ -0,0 +1,1041 @@
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include "scaler_neon.h"
+
+//
+//	arm NEON / C integer scalers for miyoomini
+//	args/	src :	src offset		address of top left corner
+//		dst :	dst offset		address	of top left corner
+//		sw  :	src width		pixels
+//		sh  :	src height		pixels
+//		sp  :	src pitch (stride)	bytes	if 0, (src width * [2|4]) is used
+//		dp  :	dst pitch (stride)	bytes	if 0, (src width * [2|4] * multiplier) is used
+//
+//	** NOTE **
+//	since 32bit aligned addresses need to be processed for NEON scalers,
+//	x-offset and stride pixels must be even# in the case of 16bpp,
+//	if odd#, then handled by the C scaler
+//
+
+//	memcpy_neon (dst/src must be aligned 4, size must be aligned 2)
+static inline void memcpy_neon(void* dst, void* src, uint32_t size) {
+	asm volatile (
+	"	bic r4, %[sz], #127	;"
+	"	add r3, %[s], %[sz]	;"	// r3 = endofs
+	"	add r4, %[s], r4	;"	// r4 = s128ofs
+	"	cmp %[s], r4		;"
+	"	beq 2f			;"
+	"1:	vldmia %[s]!, {q8-q15}	;"	// 128 bytes
+	"	vstmia %[d]!, {q8-q15}	;"
+	"	cmp %[s], r4		;"
+	"	bne 1b			;"
+	"2:	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"	tst %[sz], #64		;"
+	"	beq 3f			;"
+	"	vldmia %[s]!, {q8-q11}	;"	// 64 bytes
+	"	vstmia %[d]!, {q8-q11}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"3:	tst %[sz], #32		;"
+	"	beq 4f			;"
+	"	vldmia %[s]!, {q12-q13}	;"	// 32 bytes
+	"	vstmia %[d]!, {q12-q13}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"4:	tst %[sz], #16		;"
+	"	beq 5f			;"
+	"	vldmia %[s]!, {q14}	;"	// 16 bytes
+	"	vstmia %[d]!, {q14}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"5:	tst %[sz], #8		;"
+	"	beq 6f			;"
+	"	vldmia %[s]!, {d30}	;"	// 8 bytes
+	"	vstmia %[d]!, {d30}	;"
+	"	cmp %[s], r3		;"
+	"	beq 7f			;"
+	"6:	ldrh r4, [%[s]],#2	;"	// rest
+	"	strh r4, [%[d]],#2	;"
+	"	cmp %[s], r3		;"
+	"	bne 6b			;"
+	"7:				"
+	: [s]"+r"(src), [d]"+r"(dst)
+	: [sz]"r"(size)
+	: "r3","r4","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+//
+//	NEON scalers
+//
+
+void scale1x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x_c16(src,dst,sw,sh,sp,dp); return; }
+	if ((swl == sp)&&(sp == dp)) memcpy_neon(dst, src, sp*sh);
+	else for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp) memcpy_neon(dst, src, swl);
+}
+
+void scale1x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale1x_c32(src,dst,sw,sh,sp,dp); return; }
+	if ((swl == sp)&&(sp == dp)) memcpy_neon(dst, src, sp*sh);
+	else for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp) memcpy_neon(dst, src, swl);
+}
+
+void scale2x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t swrest = swl & 63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x64bytes offset
+	"	add r9, %0, %3		;"	// r9  = lineend offset
+	"	add r10, %1, %7		;"	// r10 = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 32 pixels 64 bytes
+	"	vdup.16 d0, d23[3]	;"
+	"	vdup.16 d1, d23[2]	;"
+	"	vext.16 d31, d1,d0,#2	;"
+	"	vdup.16 d0, d23[1]	;"
+	"	vdup.16 d1, d23[0]	;"
+	"	vext.16 d30, d1,d0,#2	;"
+	"	vdup.16 d0, d22[3]	;"
+	"	vdup.16 d1, d22[2]	;"
+	"	vext.16 d29, d1,d0,#2	;"
+	"	vdup.16 d0, d22[1]	;"
+	"	vdup.16 d1, d22[0]	;"
+	"	vext.16 d28, d1,d0,#2	;"
+	"	vdup.16 d0, d21[3]	;"
+	"	vdup.16 d1, d21[2]	;"
+	"	vext.16 d27, d1,d0,#2	;"
+	"	vdup.16 d0, d21[1]	;"
+	"	vdup.16 d1, d21[0]	;"
+	"	vext.16 d26, d1,d0,#2	;"
+	"	vdup.16 d0, d20[3]	;"
+	"	vdup.16 d1, d20[2]	;"
+	"	vext.16 d25, d1,d0,#2	;"
+	"	vdup.16 d0, d20[1]	;"
+	"	vdup.16 d1, d20[0]	;"
+	"	vext.16 d24, d1,d0,#2	;"
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r10!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r9		;"
+	"	beq 5f			;"
+	"	tst %8, #32		;"
+	"	beq 4f			;"
+	"	vldmia %0!,{q8-q9}	;"	// 16 pixels
+	"	vdup.16 d0, d19[3]	;"
+	"	vdup.16 d1, d19[2]	;"
+	"	vext.16 d23, d1,d0,#2	;"
+	"	vdup.16 d0, d19[1]	;"
+	"	vdup.16 d1, d19[0]	;"
+	"	vext.16 d22, d1,d0,#2	;"
+	"	vdup.16 d0, d18[3]	;"
+	"	vdup.16 d1, d18[2]	;"
+	"	vext.16 d21, d1,d0,#2	;"
+	"	vdup.16 d0, d18[1]	;"
+	"	vdup.16 d1, d18[0]	;"
+	"	vext.16 d20, d1,d0,#2	;"
+	"	vdup.16 d0, d17[3]	;"
+	"	vdup.16 d1, d17[2]	;"
+	"	vext.16 d19, d1,d0,#2	;"
+	"	vdup.16 d0, d17[1]	;"
+	"	vdup.16 d1, d17[0]	;"
+	"	vext.16 d18, d1,d0,#2	;"
+	"	vdup.16 d0, d16[3]	;"
+	"	vdup.16 d1, d16[2]	;"
+	"	vext.16 d17, d1,d0,#2	;"
+	"	vdup.16 d0, d16[1]	;"
+	"	vdup.16 d1, d16[0]	;"
+	"	vext.16 d16, d1,d0,#2	;"
+	"	cmp %0, r9		;"
+	"	vstmia %1!, {q8-q11}	;"
+	"	vstmia r10!, {q8-q11}	;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	orr lr, lr, lsl #16	;"
+	"	cmp %0, r9		;"
+	"	str lr, [%1],#4		;"
+	"	str lr, [r10],#4	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp), "r"(swrest)
+	: "r9","r10","lr","q0","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale2x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*2; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale2x_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl64 = swl & ~63;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*2 - swl*2;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x64bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q11}	;"	// 16 pixels 64 bytes
+	"	vdup.32 d31, d23[1]	;"
+	"	vdup.32 d30, d23[0]	;"
+	"	vdup.32 d29, d22[1]	;"
+	"	vdup.32 d28, d22[0]	;"
+	"	vdup.32 d27, d21[1]	;"
+	"	vdup.32 d26, d21[0]	;"
+	"	vdup.32 d25, d20[1]	;"
+	"	vdup.32 d24, d20[0]	;"
+	"	vdup.32 d23, d19[1]	;"
+	"	vdup.32 d22, d19[0]	;"
+	"	vdup.32 d21, d18[1]	;"
+	"	vdup.32 d20, d18[0]	;"
+	"	vdup.32 d19, d17[1]	;"
+	"	vdup.32 d18, d17[0]	;"
+	"	vdup.32 d17, d16[1]	;"
+	"	vdup.32 d16, d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	vstmia r9!, {q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl64), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale3x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*3; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale3x_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp - swl*3;
+	uint32_t dwl = swl*3;
+	uint32_t dwl128 = dwl & ~127;
+	uint32_t dwrest = dwl & 127;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	mov r11,%1		;"	// dst push
+	"	add lr, %0, %2		;"	// lr  = x32bytes offset
+	"	add r10, %0, %3		;"	// r10 = lineend offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!, {q8-q9}	;"	// 16 pixels 32 bytes
+	"	vdup.16 d31, d19[3]	;"	//  FFFF
+	"	vdup.16 d30, d19[2]	;"	//  EEEE
+	"	vdup.16 d29, d19[1]	;"	//  DDDD
+	"	vdup.16 d28, d19[0]	;"	//  CCCC
+	"	vext.16 d27, d30,d31,#3	;"	// EFFF
+	"	vext.16 d26, d29,d30,#2	;"	// DDEE
+	"	vext.16 d25, d28,d29,#1	;"	// CCCD
+	"	vdup.16 d31, d18[3]	;"	//  BBBB
+	"	vdup.16 d30, d18[2]	;"	//  AAAA
+	"	vdup.16 d29, d18[1]	;"	//  9999
+	"	vdup.16 d28, d18[0]	;"	//  8888
+	"	vext.16 d24, d30,d31,#3	;"	// ABBB
+	"	vext.16 d23, d29,d30,#2	;"	// 99AA
+	"	vext.16 d22, d28,d29,#1	;"	// 8889
+	"	vdup.16 d31, d17[3]	;"	//  7777
+	"	vdup.16 d30, d17[2]	;"	//  6666
+	"	vdup.16 d29, d17[1]	;"	//  5555
+	"	vdup.16 d28, d17[0]	;"	//  4444
+	"	vext.16 d21, d30,d31,#3	;"	// 6777
+	"	vext.16 d20, d29,d30,#2	;"	// 5566
+	"	vext.16 d19, d28,d29,#1	;"	// 4445
+	"	vdup.16 d31, d16[3]	;"	//  3333
+	"	vdup.16 d30, d16[2]	;"	//  2222
+	"	vdup.16 d29, d16[1]	;"	//  1111
+	"	vdup.16 d28, d16[0]	;"	//  0000
+	"	vext.16 d18, d30,d31,#3	;"	// 2333
+	"	vext.16 d17, d29,d30,#2	;"	// 1122
+	"	vext.16 d16, d28,d29,#1	;"	// 0001
+	"	cmp %0, lr		;"
+	"	vstmia %1!, {q8-q13}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r10		;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	orr lr, lr, lsl #16	;"
+	"	cmp %0, r10		;"
+	"	str lr, [%1],#4		;"
+	"	strh lr, [%1],#2	;"
+	"	bne 4b			;"
+	"5:	add %0, %4		;"
+	"	add %1, %5		;"
+	"	mov r12, %1		;"	// r12 = 2x line offset
+	"	add %1, %8		;"	//
+	"	add %1, %5		;"	// %1 = 3x line offset
+	"	add lr, r11, %7		;"	// lr = x128bytes offset
+	"	add r10, r11, %8	;"	// r10 = lineend offset
+	"	cmp r11, lr		;"
+	"	beq 7f			;"
+	"6:	vldmia r11!, {q8-q15}	;"	// 64 pixels 128 bytes
+	"	vstmia r12!, {q8-q15}	;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	cmp r11, lr		;"
+	"	bne 6b			;"
+	"7:	cmp r11, r10		;"
+	"	beq 10f			;"
+	"	tst %9, #64		;"
+	"	beq 8f			;"
+	"	vldmia r11!, {q8-q11}	;"	// 32 pixels
+	"	vstmia r12!, {q8-q11}	;"
+	"	vstmia %1!, {q8-q11}	;"
+	"	cmp r11, r10		;"
+	"	beq 10f			;"
+	"8:	tst %9, #32		;"
+	"	beq 9f			;"
+	"	vldmia r11!, {q8-q9}	;"	// 16 pixels
+	"	vstmia r12!, {q8-q9}	;"
+	"	vstmia %1!, {q8-q9}	;"
+	"	cmp r11, r10		;"
+	"	beq 10f			;"
+	"9:	ldrh lr, [r11],#2	;"	// rest
+	"	strh lr, [r12],#2	;"
+	"	strh lr, [%1],#2	;"
+	"	cmp r11, r10		;"
+	"	bne 9b			;"
+	"10:	add %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dwl128), "r"(dwl), "r"(dwrest)
+	: "r10","r11","r12","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale3x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*3; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale3x_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp - swl*3;
+	uint32_t dwl = swl*3;
+	uint32_t dwl128 = dwl & ~127;
+	uint32_t dwrest = dwl & 127;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	mov r11,%1		;"	// dst push
+	"	add lr, %0, %2		;"	// lr = x32bytes offset
+	"	add r10, %0, %3		;"	// r10 = lineend offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 8 pixels 32 bytes
+	"	vdup.32 q15, d19[1]	;"	//  7777
+	"	vdup.32 q14, d19[0]	;"	//  6666
+	"	vdup.32 q1, d18[1]	;"	//  5555
+	"	vdup.32 q0, d18[0]	;"	//  4444
+	"	vext.32 q13, q14,q15,#3	;"	// 6777
+	"	vext.32 q12, q1,q14,#2	;"	// 5566
+	"	vext.32 q11, q0,q1,#1	;"	// 4445
+	"	vdup.32 q15, d17[1]	;"	//  3333
+	"	vdup.32 q14, d17[0]	;"	//  2222
+	"	vdup.32 q1, d16[1]	;"	//  1111
+	"	vdup.32 q0, d16[0]	;"	//  0000
+	"	vext.32 q10, q14,q15,#3	;"	// 2333
+	"	vext.32 q9, q1,q14,#2	;"	// 1122
+	"	vext.32 q8, q0,q1,#1	;"	// 0001
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q13}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r10		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 d16, lr		;"
+	"	cmp %0, r10		;"
+	"	vstmia %1!, {d16}	;"
+	"	str lr, [%1],#4		;"
+	"	bne 4b			;"
+	"5:	add %0, %4		;"
+	"	add %1, %5		;"
+	"	mov r12, %1		;"	// r12 = 2x line offset
+	"	add %1, %8		;"	//
+	"	add %1, %5		;"	// %1 = 3x line offset
+	"	add lr, r11, %7		;"	// lr = x128bytes offset
+	"	add r10, r11, %8	;"	// r10 = lineend offset
+	"	cmp r11, lr		;"
+	"	beq 7f			;"
+	"6:	vldmia r11!, {q8-q15}	;"	// 32 pixels 128 bytes
+	"	vstmia r12!, {q8-q15}	;"
+	"	vstmia %1!, {q8-q15}	;"
+	"	cmp r11, lr		;"
+	"	bne 6b			;"
+	"7:	cmp r11, r10		;"
+	"	beq 10f			;"
+	"	tst %9, #64		;"
+	"	beq 8f			;"
+	"	vldmia r11!, {q8-q11}	;"	// 16 pixels
+	"	vstmia r12!, {q8-q11}	;"
+	"	vstmia %1!, {q8-q11}	;"
+	"	cmp r11, r10		;"
+	"	beq 10f			;"
+	"8:	tst %9, #32		;"
+	"	beq 9f			;"
+	"	vldmia r11!, {q8-q9}	;"	// 8 pixels
+	"	vstmia r12!, {q8-q9}	;"
+	"	vstmia %1!, {q8-q9}	;"
+	"	cmp r11, r10		;"
+	"	beq 10f			;"
+	"9:	ldr lr, [r11],#4	;"	// rest
+	"	str lr, [r12],#4	;"
+	"	str lr, [%1],#4		;"
+	"	cmp r11, r10		;"
+	"	bne 9b			;"
+	"10:	add %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dwl128), "r"(dwl), "r"(dwrest)
+	: "r10","r11","r12","lr","q0","q1","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x_c16(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr  = x32bytes offset
+	"	add r8, %0, %3		;"	// r8  = lineend offset
+	"	add r9, %1, %7		;"	// r9  = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 16 pixels 32 bytes
+	"	vdup.16 d31,d19[3]	;"
+	"	vdup.16 d30,d19[2]	;"
+	"	vdup.16 d29,d19[1]	;"
+	"	vdup.16 d28,d19[0]	;"
+	"	vdup.16 d27,d18[3]	;"
+	"	vdup.16 d26,d18[2]	;"
+	"	vdup.16 d25,d18[1]	;"
+	"	vdup.16 d24,d18[0]	;"
+	"	vdup.16 d23,d17[3]	;"
+	"	vdup.16 d22,d17[2]	;"
+	"	vdup.16 d21,d17[1]	;"
+	"	vdup.16 d20,d17[0]	;"
+	"	vdup.16 d19,d16[3]	;"
+	"	vdup.16 d18,d16[2]	;"
+	"	vdup.16 d17,d16[1]	;"
+	"	vdup.16 d16,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	vstmia r10!,{q8-q15}	;"
+	"	vstmia r11!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldrh lr, [%0],#2	;"	// rest
+	"	vdup.16 d16, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {d16}	;"
+	"	vstmia r9!, {d16}	;"
+	"	vstmia r10!, {d16}	;"
+	"	vstmia r11!, {d16}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+void scale4x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*4; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale4x_c32(src,dst,sw,sh,sp,dp); return; }
+	uint32_t swl32 = swl & ~31;
+	uint32_t sadd = sp - swl;
+	uint32_t dadd = dp*4 - swl*4;
+	uint8_t* finofs = (uint8_t*)src + (sp*sh);
+	asm volatile (
+	"1:	add lr, %0, %2		;"	// lr = x32bytes offset
+	"	add r8, %0, %3		;"	// r8 = lineend offset
+	"	add r9, %1, %7		;"	// r9 = 2x line offset
+	"	add r10, r9, %7		;"	// r10 = 3x line offset
+	"	add r11, r10, %7	;"	// r11 = 4x line offset
+	"	cmp %0, lr		;"
+	"	beq 3f			;"
+	"2:	vldmia %0!,{q8-q9}	;"	// 8 pixels 32 bytes
+	"	vdup.32 q15,d19[1]	;"
+	"	vdup.32 q14,d19[0]	;"
+	"	vdup.32 q13,d18[1]	;"
+	"	vdup.32 q12,d18[0]	;"
+	"	vdup.32 q11,d17[1]	;"
+	"	vdup.32 q10,d17[0]	;"
+	"	vdup.32 q9,d16[1]	;"
+	"	vdup.32 q8,d16[0]	;"
+	"	cmp %0, lr		;"
+	"	vstmia %1!,{q8-q15}	;"
+	"	vstmia r9!,{q8-q15}	;"
+	"	vstmia r10!,{q8-q15}	;"
+	"	vstmia r11!,{q8-q15}	;"
+	"	bne 2b			;"
+	"3:	cmp %0, r8		;"
+	"	beq 5f			;"
+	"4:	ldr lr, [%0],#4		;"	// rest
+	"	vdup.32 q8, lr		;"
+	"	cmp %0, r8		;"
+	"	vstmia %1!, {q8}	;"
+	"	vstmia r9!, {q8}	;"
+	"	vstmia r10!, {q8}	;"
+	"	vstmia r11!, {q8}	;"
+	"	bne 4b			;"
+	"5:	add %0, %0, %4		;"
+	"	add %1, %1, %5		;"
+	"	cmp %0, %6		;"
+	"	bne 1b			"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl32), "r"(swl), "r"(sadd), "r"(dadd), "r"(finofs), "r"(dp)
+	: "r8","r9","r10","r11","lr","q8","q9","q10","q11","q12","q13","q14","q15","memory","cc"
+	);
+}
+
+static inline void scale5x_n16line(void* src, void* dst, uint32_t swl) {
+	asm volatile (
+	"	bic r4, %2, #15		;"	// r4 = swl16
+	"	add r3, %0, %2		;"	// r3 = lineend offset
+	"	add r4, %0, r4		;"	// r4 = x16bytes offset
+	"	cmp %0, r4		;"
+	"	beq 2f			;"
+	"1:	vldmia %0!, {q8}	;"	// 8 pixels 16 bytes
+	"	vdup.16 d25, d17[3]	;"	//  7777
+	"	vdup.16 d27, d17[2]	;"	//  6666
+	"	vdup.16 d26, d17[1]	;"	//  5555
+	"	vdup.16 d21, d17[0]	;"	//  4444
+	"	vext.16 d24, d27,d25,#1	;"	// 6667
+	"	vext.16 d23, d26,d27,#2	;"	// 5566
+	"	vext.16 d22, d21,d26,#3	;"	// 4555
+	"	vdup.16 d20, d16[3]	;"	//  3333
+	"	vdup.16 d27, d16[2]	;"	//  2222
+	"	vdup.16 d26, d16[1]	;"	//  1111
+	"	vdup.16 d16, d16[0]	;"	//  0000
+	"	vext.16 d19, d27,d20,#1	;"	// 2223
+	"	vext.16 d18, d26,d27,#2	;"	// 1122
+	"	vext.16 d17, d16,d26,#3	;"	// 0111
+	"	cmp %0, r4		;"
+	"	vstmia %1!, {q8-q12}	;"
+	"	bne 1b			;"
+	"2:	cmp %0, r3		;"
+	"	beq 4f			;"
+	"3:	ldrh r4, [%0],#2	;"	// rest
+	"	orr r4, r4, lsl #16	;"
+	"	cmp %0, r3		;"
+	"	str r4, [%1],#4		;"
+	"	str r4, [%1],#4		;"
+	"	strh r4, [%1],#2	;"
+	"	bne 3b			;"
+	"4:				"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl)
+	: "r3","r4","q8","q9","q10","q11","q12","q13","memory","cc"
+	);
+}
+
+void scale5x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint16_t);
+	uint32_t dwl = swl*5;
+	if (!sp) { sp = swl; } if (!dp) { dp = dwl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale5x_c16(src,dst,sw,sh,sp,dp); return; }
+	void* __restrict dstsrc;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		scale5x_n16line(src, dst, swl);
+		dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=4; i>0; i--, dst=(uint8_t*)dst+dp) memcpy_neon(dst, dstsrc, dwl);
+	}
+}
+
+static inline void scale5x_n32line(void* src, void* dst, uint32_t swl) {
+	asm volatile (
+	"	bic r4, %2, #15		;"	// r4 = swl16
+	"	add r3, %0, %2		;"	// r3 = lineend offset
+	"	add r4, %0, r4		;"	// r4 = x16bytes offset
+	"	cmp %0, r4		;"
+	"	beq 2f			;"
+	"1:	vldmia %0!,{q8}		;"	// 4 pixels 16 bytes
+	"	vdup.32 q12, d17[1]	;"	// 3333
+	"	vdup.32 q14, d17[0]	;"	//  2222
+	"	vdup.32 q13, d16[1]	;"	//  1111
+	"	vdup.32 q8, d16[0]	;"	// 0000
+	"	vext.32 q11, q14,q12,#1	;"	// 2223
+	"	vext.32 q10, q13,q14,#2	;"	// 1122
+	"	vext.32 q9, q8,q13,#3	;"	// 0111
+	"	cmp %0, r4		;"
+	"	vstmia %1!,{q8-q12}	;"
+	"	bne 1b			;"
+	"2:	cmp %0, r3		;"
+	"	beq 4f			;"
+	"3:	ldr r4, [%0],#4		;"	// rest
+	"	vdup.32 q8, r4		;"
+	"	cmp %0, r3		;"
+	"	vstmia %1!, {q8}	;"
+	"	str r4, [%1],#4		;"
+	"	bne 3b			;"
+	"4:				"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl)
+	: "r3","r4","q8","q9","q10","q11","q12","q13","q14","memory","cc"
+	);
+}
+
+void scale5x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint32_t);
+	uint32_t dwl = swl*5;
+	if (!sp) { sp = swl; } if (!dp) { dp = dwl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale5x_c32(src,dst,sw,sh,sp,dp); return; }
+	void* __restrict dstsrc;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		scale5x_n32line(src, dst, swl);
+		dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=4; i>0; i--, dst=(uint8_t*)dst+dp) memcpy_neon(dst, dstsrc, dwl);
+	}
+}
+
+static inline void scale6x_n16line(void* src, void* dst, uint32_t swl) {
+	asm volatile (
+	"	bic r4, %2, #15		;"	// r4 = swl16
+	"	add r3, %0, %2		;"	// r3 = lineend offset
+	"	add r4, %0, r4		;"	// r4 = x16bytes offset
+	"	cmp %0, r4		;"
+	"	beq 2f			;"
+	"1:	vldmia %0!, {q8}	;"	// 8 pixels 16 bytes
+	"	vdup.16 d27, d17[3]	;"	//  7777
+	"	vdup.16 d25, d17[2]	;"	//  6666
+	"	vdup.16 d24, d17[1]	;"	//  5555
+	"	vdup.16 d22, d17[0]	;"	//  4444
+	"	vext.16 d26, d25,d27,#2	;"	// 6677
+	"	vext.16 d23, d22,d24,#2	;"	// 4455
+	"	vdup.16 d21, d16[3]	;"	//  3333
+	"	vdup.16 d19, d16[2]	;"	//  2222
+	"	vdup.16 d18, d16[1]	;"	//  1111
+	"	vdup.16 d16, d16[0]	;"	//  0000
+	"	vext.16 d20, d19,d21,#2	;"	// 2233
+	"	vext.16 d17, d16,d18,#2	;"	// 0011
+	"	cmp %0, r4		;"
+	"	vstmia %1!, {q8-q13}	;"
+	"	bne 1b			;"
+	"2:	cmp %0, r3		;"
+	"	beq 4f			;"
+	"3:	ldrh r4, [%0],#2	;"	// rest
+	"	orr r4, r4, lsl #16	;"
+	"	vdup.32 d16, r4		;"
+	"	cmp %0, r3		;"
+	"	vstmia %1!, {d16}	;"
+	"	str r4, [%1],#4		;"
+	"	bne 3b			;"
+	"4:				"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl)
+	: "r3","r4","q8","q9","q10","q11","q12","q13","memory","cc"
+	);
+}
+
+void scale6x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint16_t);
+	uint32_t dwl = swl*6;
+	if (!sp) { sp = swl; } if (!dp) { dp = dwl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale6x_c16(src,dst,sw,sh,sp,dp); return; }
+	void* __restrict dstsrc;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		scale6x_n16line(src, dst, swl);
+		dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=5; i>0; i--, dst=(uint8_t*)dst+dp) memcpy_neon(dst, dstsrc, dwl);
+	}
+}
+
+static inline void scale6x_n32line(void* src, void* dst, uint32_t swl) {
+	asm volatile (
+	"	bic r4, %2, #15		;"	// r4 = swl16
+	"	add r3, %0, %2		;"	// r3 = lineend offset
+	"	add r4, %0, r4		;"	// r4 = x16bytes offset
+	"	cmp %0, r4		;"
+	"	beq 2f			;"
+	"1:	vldmia %0!,{q8}		;"	// 4 pixels 16 bytes
+	"	vdup.32 q13, d17[1]	;"	// 3333
+	"	vdup.32 q11, d17[0]	;"	// 2222
+	"	vdup.32 q10, d16[1]	;"	// 1111
+	"	vdup.32 q8, d16[0]	;"	// 0000
+	"	vext.32 q12, q11,q13,#2	;"	// 2233
+	"	vext.32 q9, q8,q10,#2	;"	// 0011
+	"	cmp %0, r4		;"
+	"	vstmia %1!,{q8-q13}	;"
+	"	bne 1b			;"
+	"2:	cmp %0, r3		;"
+	"	beq 4f			;"
+	"3:	ldr r4, [%0],#4		;"	// rest
+	"	vdup.32 q8, r4		;"
+	"	vmov d18, d16		;"
+	"	cmp %0, r3		;"
+	"	vstmia %1!, {d16-d18}	;"
+	"	bne 3b			;"
+	"4:				"
+	: "+r"(src), "+r"(dst)
+	: "r"(swl)
+	: "r3","r4","q8","q9","q10","q11","q12","q13","memory","cc"
+	);
+}
+
+void scale6x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw * sizeof(uint32_t);
+	uint32_t dwl = swl*6;
+	if (!sp) { sp = swl; } if (!dp) { dp = dwl; }
+	if ( ((uintptr_t)src&3)||((uintptr_t)dst&3)||(sp&3)||(dp&3) ) { scale6x_c32(src,dst,sw,sh,sp,dp); return; }
+	void* __restrict dstsrc;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp) {
+		scale6x_n32line(src, dst, swl);
+		dstsrc = dst; dst = (uint8_t*)dst+dp;
+		for (uint32_t i=5; i>0; i--, dst=(uint8_t*)dst+dp) memcpy_neon(dst, dstsrc, dwl);
+	}
+}
+
+//
+//	C scalers
+//
+
+void scale1x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ((swl == sp)&&(sp == dp)) memcpy(dst, src, sp*sh);
+	else for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp) memcpy(dst, src, swl);
+}
+
+void scale1x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } if (!dp) { dp = swl*1; }
+	if ((swl == sp)&&(sp == dp)) memcpy(dst, src, sp*sh);
+	else for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp) memcpy(dst, src, swl);
+}
+
+void scale2x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=2) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			d[dx] = pix16|(pix16<<16);
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+	}
+}
+
+void scale2x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=2) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+	}
+}
+
+void scale3x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = pix; d[dx+2] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d16[(dx+1)*2] = pix16;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+void scale3x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+void scale4x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=4; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*4) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=4) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = dpix1; d[dx+2] = dpix2; d[dx+3] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d[dx+1] = dpix1;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+		memcpy((uint8_t*)dst+dp*3, dst, swl);
+	}
+}
+
+//	faster than 4x_c16 when -Ofast/-O3 and aligned width, however dp must be 4xN
+void scale4x_c16b(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; } if (!sp) { sp = sw*sizeof(uint16_t); } if (!dp) { dp = sw*sizeof(uint16_t)*4; }
+	uint32_t x, dx, pix, dpix1, dpix2, dp32 = dp / sizeof(uint32_t);
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*4) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=4) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = dpix1; d[dx+2] = dpix2; d[dx+3] = dpix2;
+			d[dp32+dx] = dpix1; d[dp32+dx+1]= dpix1; d[dp32+dx+2]= dpix2; d[dp32+dx+3]= dpix2;
+			d[dp32*2+dx] = dpix1; d[dp32*2+dx+1]= dpix1; d[dp32*2+dx+2]= dpix2; d[dp32*2+dx+3]= dpix2;
+			d[dp32*3+dx] = dpix1; d[dp32*3+dx+1]= dpix1; d[dp32*3+dx+2]= dpix2; d[dp32*3+dx+3]= dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d[dx+1] = dpix1;
+			d[dp32+dx] = dpix1; d[dp32+dx+1] = dpix1;
+			d[dp32*2+dx] = dpix1; d[dp32*2+dx+1] = dpix1;
+			d[dp32*3+dx] = dpix1; d[dp32*3+dx+1] = dpix1;
+		}
+	}
+}
+
+void scale4x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=4; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*4) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=4) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix; d[dx+3] = pix;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+		memcpy((uint8_t*)dst+dp*3, dst, swl);
+	}
+}
+
+//	faster than 4x_c32 when -Ofast/-O3 and aligned width
+void scale4x_c32b(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; } if (!sp) { sp = sw*sizeof(uint32_t); } if (!dp) { dp = sw*sizeof(uint32_t)*4; }
+	uint32_t x, dx, pix, dp32 = dp / sizeof(uint32_t);
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*4) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=4) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix; d[dx+3] = pix;
+			d[dp32+dx] = pix; d[dp32+dx+1]= pix; d[dp32+dx+2]= pix; d[dp32+dx+3]= pix;
+			d[dp32*2+dx] = pix; d[dp32*2+dx+1]= pix; d[dp32*2+dx+2]= pix; d[dp32*2+dx+3]= pix;
+			d[dp32*3+dx] = pix; d[dp32*3+dx+1]= pix; d[dp32*3+dx+2]= pix; d[dp32*3+dx+3]= pix;
+		}
+	}
+}
+
+void scale5x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=5; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*5) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=5) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = dpix1; d[dx+2] = pix; d[dx+3] = dpix2; d[dx+4] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d[dx+1] = dpix1; d16[(dx+2)*2] = pix16;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+		memcpy((uint8_t*)dst+dp*3, dst, swl);
+		memcpy((uint8_t*)dst+dp*4, dst, swl);
+	}
+}
+
+void scale5x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=5; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*5) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=5) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix; d[dx+3] = pix; d[dx+4] = pix;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+		memcpy((uint8_t*)dst+dp*3, dst, swl);
+		memcpy((uint8_t*)dst+dp*4, dst, swl);
+	}
+}
+
+void scale6x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=6; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*6) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=6) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = dpix1; d[dx+2] = dpix1; d[dx+3] = dpix2; d[dx+4] = dpix2; d[dx+5] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d[dx+1] = dpix1; d[dx+2] = dpix1;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+		memcpy((uint8_t*)dst+dp*3, dst, swl);
+		memcpy((uint8_t*)dst+dp*4, dst, swl);
+		memcpy((uint8_t*)dst+dp*5, dst, swl);
+	}
+}
+
+void scale6x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=6; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*6) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=6) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix; d[dx+3] = pix; d[dx+4] = pix; d[dx+5] = pix;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+		memcpy((uint8_t*)dst+dp*3, dst, swl);
+		memcpy((uint8_t*)dst+dp*4, dst, swl);
+		memcpy((uint8_t*)dst+dp*5, dst, swl);
+	}
+}
diff --git a/gfx/drivers/miyoomini/scaler_neon.h b/gfx/drivers/miyoomini/scaler_neon.h
new file mode 100644
index 0000000000..b0e7f14924
--- /dev/null
+++ b/gfx/drivers/miyoomini/scaler_neon.h
@@ -0,0 +1,51 @@
+#ifndef __SCALER_NEON_H__
+#define __SCALER_NEON_H__
+#include <stdint.h>
+
+//
+//	arm NEON / C integer scalers for miyoomini
+//	args/	src :	src offset		address of top left corner
+//		dst :	dst offset		address	of top left corner
+//		sw  :	src width		pixels
+//		sh  :	src height		pixels
+//		sp  :	src pitch (stride)	bytes	if 0, (src width * [2|4]) is used
+//		dp  :	dst pitch (stride)	bytes	if 0, (src width * [2|4] * multiplier) is used
+//
+//	** NOTE **
+//	since 32bit aligned addresses need to be processed for NEON scalers,
+//	x-offset and stride pixels must be even# in the case of 16bpp,
+//	if odd#, then handled by the C scaler
+//
+
+//	NEON scalers
+void scale1x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale3x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale3x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale5x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale5x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale6x_n16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale6x_n32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+
+//	C scalers
+void scale1x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale1x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale2x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale3x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale3x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+//	c16b/c32b: faster when -Ofast/-O3 and aligned width, however dp must be 4xN
+void scale4x_c16b(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale4x_c32b(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale5x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale5x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale6x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+void scale6x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+
+#endif
diff --git a/gfx/drivers/miyoomini/sdl_miyoomini_gfx.c b/gfx/drivers/miyoomini/sdl_miyoomini_gfx.c
new file mode 100644
index 0000000000..4e6be9d64a
--- /dev/null
+++ b/gfx/drivers/miyoomini/sdl_miyoomini_gfx.c
@@ -0,0 +1,985 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2017 - Daniel De Matteis
+ *  Copyright (C) 2011-2017 - Higor Euripedes
+ *  Copyright (C) 2019-2021 - James Leaver
+ *  Copyright (C)      2021 - John Parton
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <SDL/SDL.h>
+#include <SDL/SDL_video.h>
+
+#include <retro_assert.h>
+#include <gfx/video_frame.h>
+#include <retro_assert.h>
+#include <string/stdstring.h>
+#include <encodings/utf.h>
+#include <features/features_cpu.h>
+
+#include "gfx.c"
+#include "scaler_neon.c"
+#include <sys/mman.h>
+#include <sys/time.h>
+
+#ifdef HAVE_CONFIG_H
+#include "../../config.h"
+#endif
+
+#ifdef HAVE_MENU
+#include "../../menu/menu_driver.h"
+#endif
+
+#include "../../dingux/dingux_utils.h"
+
+#include "../../verbosity.h"
+#include "../../gfx/drivers_font_renderer/bitmap.h"
+#include "../../configuration.h"
+#include "../../retroarch.h"
+
+#define likely(x)   __builtin_expect(!!(x), 1)
+#define unlikely(x) __builtin_expect(!!(x), 0)
+
+#define SDL_MIYOOMINI_WIDTH  640
+#define SDL_MIYOOMINI_HEIGHT 480
+#define RGUI_MENU_WIDTH  320
+#define RGUI_MENU_HEIGHT 240
+#define SDL_NUM_FONT_GLYPHS 256
+#define OSD_TEXT_Y_MARGIN 4
+#define OSD_TEXT_LINES_MAX 3	/* 1 .. 7 */
+#define OSD_TEXT_LINE_LEN ((uint32_t)(RGUI_MENU_WIDTH / FONT_WIDTH_STRIDE)-1)
+#define OSD_TEXT_LEN_MAX (OSD_TEXT_LINE_LEN * OSD_TEXT_LINES_MAX)
+
+typedef struct sdl_miyoomini_video sdl_miyoomini_video_t;
+struct sdl_miyoomini_video
+{
+   SDL_Surface *screen;
+   void (*scale_func)(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp);
+   /* Scaling/padding/cropping parameters */
+   unsigned content_width;
+   unsigned content_height;
+   unsigned frame_width;
+   unsigned frame_height;
+   unsigned video_x;
+   unsigned video_y;
+   unsigned video_w;
+   unsigned video_h;
+   unsigned rotate;
+   bool rgb32;
+   bool menu_active;
+   bool was_in_menu;
+   retro_time_t last_frame_time;
+   retro_time_t ff_frame_time_min;
+   enum dingux_ipu_filter_type filter_type;
+   bool vsync;
+   bool keep_aspect;
+   bool scale_integer;
+   bool quitting;
+   bitmapfont_lut_t *osd_font;
+   uint32_t font_colour32;
+   SDL_Surface *menuscreen;
+   SDL_Surface *menuscreen_rgui;
+   unsigned msg_count;
+   char msg_tmp[OSD_TEXT_LEN_MAX];
+};
+
+/* Clear OSD text area, without video_rect, rotate180 */
+static void sdl_miyoomini_clear_msgarea(void* buf, unsigned x, unsigned y, unsigned w, unsigned h, unsigned lines) {
+   if ( ( x == 0 ) && ( w == SDL_MIYOOMINI_WIDTH  ) && ( y == 0 ) && ( h == SDL_MIYOOMINI_HEIGHT ) ) return;
+
+   uint32_t x0 = SDL_MIYOOMINI_WIDTH - (x + w); /* left margin , right margin = x */
+   uint32_t y0 = SDL_MIYOOMINI_HEIGHT - (y + h); /* top margin , bottom margin = y */
+   uint32_t sl = x0 * sizeof(uint32_t); /* left buffer size */
+   uint32_t sr = x * sizeof(uint32_t); /* right buffer size */
+   uint32_t sw = w * sizeof(uint32_t); /* pitch */
+   uint32_t ss = SDL_MIYOOMINI_WIDTH * sizeof(uint32_t); /* stride */
+   uint32_t vy = OSD_TEXT_Y_MARGIN + 2; /* clear start y offset */
+   uint32_t vh = FONT_HEIGHT_STRIDE * 2 * lines - 2; /* clear height */
+   uint32_t vh1 = (y0 < vy) ? 0 : (y0 - vy); if (vh1 > vh) vh1 = vh;
+   uint32_t vh2 = vh - vh1;
+   uint32_t ssl = ss * vh1 + sl;
+   uint32_t srl = sr + sl;
+   void* ofs = buf + vy * ss;
+
+   if (ssl) memset(ofs, 0, ssl);
+   ofs += ssl + sw;
+   for (; vh2>1; vh2--, ofs += ss) { if (srl) memset(ofs, 0, srl); }
+   if ((vh2) && (sr)) memset(ofs, 0, sr);
+}
+
+/* Print OSD text, flip callback, direct draw to framebuffer, 32bpp, 2x, rotate180 */
+static void sdl_miyoomini_print_msg(void* data) {
+   if (unlikely(!data)) return;
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+
+   void *screen_buf;
+   const char *str  = vid->msg_tmp;
+   uint32_t str_len = strlen_size(str, OSD_TEXT_LEN_MAX);
+   if (str_len) {
+      screen_buf              = fb_addr + (vinfo.yoffset * SDL_MIYOOMINI_WIDTH * sizeof(uint32_t));
+      bool **font_lut         = vid->osd_font->lut;
+      uint32_t str_lines      = (uint32_t)((str_len - 1) / OSD_TEXT_LINE_LEN) + 1;
+      uint32_t str_counter    = OSD_TEXT_LINE_LEN;
+      const int x_pos_def     = SDL_MIYOOMINI_WIDTH - (FONT_WIDTH_STRIDE * 2);
+      int x_pos               = x_pos_def;
+      int y_pos               = OSD_TEXT_Y_MARGIN - 4 + (FONT_HEIGHT_STRIDE * 2 * str_lines);
+
+      for (; str_len > 0; str_len--) {
+         /* Check for out of bounds x coordinates */
+         if (!str_counter--) {
+            x_pos = x_pos_def; y_pos -= (FONT_HEIGHT_STRIDE * 2); str_counter = OSD_TEXT_LINE_LEN;
+         }
+         /* Deal with spaces first, for efficiency */
+         if (*str == ' ') str++;
+         else {
+            uint32_t i, j;
+            bool *symbol_lut;
+            uint32_t symbol = utf8_walk(&str);
+
+            /* Stupid hack: 'oe' ligatures are not really
+             * standard extended ASCII, so we have to waste
+             * CPU cycles performing a conversion from the
+             * unicode values... */
+            if (symbol == 339) /* Latin small ligature oe */
+               symbol = 156;
+            if (symbol == 338) /* Latin capital ligature oe */
+               symbol = 140;
+
+            if (symbol >= SDL_NUM_FONT_GLYPHS) continue;
+
+            symbol_lut = font_lut[symbol];
+
+            for (j = 0; j < FONT_HEIGHT; j++) {
+               uint32_t buff_offset = ((y_pos - (j * 2) ) * SDL_MIYOOMINI_WIDTH) + x_pos;
+
+               for (i = 0; i < FONT_WIDTH; i++) {
+                  if (*(symbol_lut + i + (j * FONT_WIDTH))) {
+                     uint32_t *screen_buf_ptr = (uint32_t*)screen_buf + buff_offset - (i * 2);
+
+                     /* Bottom shadow (1) */
+                     screen_buf_ptr[+0] = 0;
+                     screen_buf_ptr[+1] = 0;
+                     screen_buf_ptr[+2] = 0;
+                     screen_buf_ptr[+3] = 0;
+
+                     /* Bottom shadow (2) */
+                     screen_buf_ptr[SDL_MIYOOMINI_WIDTH+0] = 0;
+                     screen_buf_ptr[SDL_MIYOOMINI_WIDTH+1] = 0;
+                     screen_buf_ptr[SDL_MIYOOMINI_WIDTH+2] = 0;
+                     screen_buf_ptr[SDL_MIYOOMINI_WIDTH+3] = 0;
+
+                     /* Text pixel + right shadow (1) */
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*2)+0] = 0;
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*2)+1] = 0;
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*2)+2] = vid->font_colour32;
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*2)+3] = vid->font_colour32;
+
+                     /* Text pixel + right shadow (2) */
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*3)+0] = 0;
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*3)+1] = 0;
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*3)+2] = vid->font_colour32;
+                     screen_buf_ptr[(SDL_MIYOOMINI_WIDTH*3)+3] = vid->font_colour32;
+                  }
+               }
+            }
+         }
+         x_pos -= FONT_WIDTH_STRIDE * 2;
+      }
+      vid->msg_count |= (str_lines << 6);
+   }
+   if (vid->msg_count & 7) {
+      /* clear recent OSD text */
+      screen_buf = fb_addr;
+      uint32_t target_offset = vinfo.yoffset + SDL_MIYOOMINI_HEIGHT;
+      if (target_offset != SDL_MIYOOMINI_HEIGHT * 3) screen_buf += target_offset * SDL_MIYOOMINI_WIDTH * sizeof(uint32_t);
+      sdl_miyoomini_clear_msgarea(screen_buf, vid->video_x, vid->video_y, vid->video_w, vid->video_h, vid->msg_count & 7);
+   }
+   vid->msg_count >>= 3;
+}
+
+/* Nearest neighbor scalers */
+#define NN_SHIFT 16
+void scalenn_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+   if (unlikely(!data||!sw||!sh)) return;
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   uint32_t dw = vid->video_w;
+   uint32_t dh = vid->video_h;
+
+   uint32_t x_step = (sw << NN_SHIFT) / dw + 1;
+   uint32_t y_step = (sh << NN_SHIFT) / dh + 1;
+
+   uint32_t in_stride  = sp >> 1;
+   uint32_t out_stride = dp >> 1;
+
+   uint16_t* in_ptr  = (uint16_t*)src;
+   uint16_t* out_ptr = (uint16_t*)dst;
+
+   uint32_t oy = 0;
+   uint32_t y  = 0;
+
+   /* Reading 16bits takes a little time,
+      so try not to read as much as possible in the case of 16bpp */
+   if (dh > sh) {
+      if (dw > sw) {
+         do {
+            uint32_t col = dw;
+            uint32_t ox  = 0;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            uint16_t pix = in_ptr[0];
+            do {
+               uint32_t tx = x >> NN_SHIFT;
+               if (tx != ox) {
+                  pix = in_ptr[tx];
+                  ox  = tx;
+               }
+               *(out_ptr++) = pix;
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            uint16_t* optrtmp2 = optrtmp1;
+            for(; ty == oy; y += y_step, ty = y >> NN_SHIFT) {
+               if (!--dh) return;
+               optrtmp2 += out_stride;
+               memcpy(optrtmp2, optrtmp1, dw << 1);
+            }
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp2 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      } else {
+         do {
+            uint32_t col = dw;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            do {
+               *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            uint16_t* optrtmp2 = optrtmp1;
+            for(; ty == oy; y += y_step, ty = y >> NN_SHIFT) {
+               if (!--dh) return;
+               optrtmp2 += out_stride;
+               memcpy(optrtmp2, optrtmp1, dw << 1);
+            }
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp2 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      }
+   } else {
+      if (dw > sw) {
+         do {
+            uint32_t col = dw;
+            uint32_t ox  = 0;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            uint16_t pix = in_ptr[0];
+            do {
+               uint32_t tx = x >> NN_SHIFT;
+               if (tx != ox) {
+                  pix = in_ptr[tx];
+                  ox  = tx;
+               }
+               *(out_ptr++) = pix;
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp1 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      } else {
+         do {
+            uint32_t col = dw;
+            uint32_t x   = 0;
+
+            uint16_t* optrtmp1 = out_ptr;
+
+            do {
+               *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+               x           += x_step;
+            } while (--col);
+
+            y += y_step;
+            uint32_t ty = y >> NN_SHIFT;
+            in_ptr += (ty - oy) * in_stride;
+            out_ptr = optrtmp1 + out_stride;
+            oy      = ty;
+         } while (--dh);
+      }
+   }
+}
+
+void scalenn_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+   if (unlikely(!data||!sw||!sh)) return;
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   uint32_t dw = vid->video_w;
+   uint32_t dh = vid->video_h;
+
+   uint32_t x_step = (sw << NN_SHIFT) / dw + 1;
+   uint32_t y_step = (sh << NN_SHIFT) / dh + 1;
+
+   uint32_t in_stride  = sp >> 2;
+   uint32_t out_stride = dp >> 2;
+
+   uint32_t* in_ptr  = (uint32_t*)src;
+   uint32_t* out_ptr = (uint32_t*)dst;
+
+   uint32_t oy = 0;
+   uint32_t y  = 0;
+
+   /* Reading 32bit is fast when cached,
+      so the x-axis is not considered in the case of 32bpp */
+   if (dh > sh) {
+      do {
+         uint32_t col = dw;
+         uint32_t x   = 0;
+
+         uint32_t* optrtmp1 = out_ptr;
+
+         do {
+            *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+            x           += x_step;
+         } while (--col);
+
+         y += y_step;
+         uint32_t ty = y >> NN_SHIFT;
+         uint32_t* optrtmp2 = optrtmp1;
+         for(; ty == oy; y += y_step, ty = y >> NN_SHIFT) {
+            if (!--dh) return;
+            optrtmp2 += out_stride;
+            memcpy(optrtmp2, optrtmp1, dw << 2);
+         }
+         in_ptr += (ty - oy) * in_stride;
+         out_ptr = optrtmp2 + out_stride;
+         oy      = ty;
+      } while (--dh);
+   } else {
+      do {
+         uint32_t col = dw;
+         uint32_t x   = 0;
+
+         uint32_t* optrtmp1 = out_ptr;
+
+         do {
+            *(out_ptr++) = in_ptr[x >> NN_SHIFT];
+            x           += x_step;
+         } while (--col);
+
+         y += y_step;
+         uint32_t ty = y >> NN_SHIFT;
+         in_ptr += (ty - oy) * in_stride;
+         out_ptr = optrtmp1 + out_stride;
+         oy      = ty;
+      } while (--dh);
+   }
+}
+
+/* Bridge to NEON scalers in scaler_neon.c */
+void scale1x_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x_n16(src, dst, sw, sh, sp, dp); }
+void scale1x_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale1x_n32(src, dst, sw, sh, sp, dp); }
+void scale2x_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x_n16(src, dst, sw, sh, sp, dp); }
+void scale2x_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale2x_n32(src, dst, sw, sh, sp, dp); }
+void scale4x_16(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x_n16(src, dst, sw, sh, sp, dp); }
+void scale4x_32(void* data, void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+     scale4x_n32(src, dst, sw, sh, sp, dp); }
+
+/* Clear border x3 screens for framebuffer (rotate180) */
+static void sdl_miyoomini_clear_border(void* buf, unsigned x, unsigned y, unsigned w, unsigned h) {
+   if ( (x == 0) && (y == 0) && (w == SDL_MIYOOMINI_WIDTH) && (h == SDL_MIYOOMINI_HEIGHT) ) return;
+   if ( (w == 0) || (h == 0) ) { memset(buf, 0, SDL_MIYOOMINI_WIDTH * SDL_MIYOOMINI_HEIGHT * sizeof(uint32_t) * 3); return; }
+
+   uint32_t x0 = SDL_MIYOOMINI_WIDTH - (x + w); /* left margin , right margin = x */
+   uint32_t y0 = SDL_MIYOOMINI_HEIGHT - (y + h); /* top margin , bottom margin = y */
+   uint32_t sl = x0 * sizeof(uint32_t); /* left buffer size */
+   uint32_t sr = x * sizeof(uint32_t); /* right buffer size */
+   uint32_t st = y0 * SDL_MIYOOMINI_WIDTH * sizeof(uint32_t); /* top buffer size */
+   uint32_t sb = y * SDL_MIYOOMINI_WIDTH * sizeof(uint32_t); /* bottom buffer size */
+   uint32_t srl = sr + sl;
+   uint32_t stl = st + sl;
+   uint32_t srb = sr + sb;
+   uint32_t srbtl = srl + sb + st;
+   uint32_t sw = w * sizeof(uint32_t); /* pitch */
+   uint32_t ss = SDL_MIYOOMINI_WIDTH * sizeof(uint32_t); /* stride */
+   uint32_t i;
+
+   if (stl) memset(buf, 0, stl); /* 1st top + 1st left */
+   buf += stl + sw;
+   for (i=h-1; i>0; i--, buf += ss) {
+      if (srl) memset(buf, 0, srl); /* right + left */
+   }
+   if (srbtl) memset(buf, 0, srbtl); /* last right + bottom + top + 1st left */
+   buf += srbtl + sw;
+   for (i=h-1; i>0; i--, buf += ss) {
+      if (srl) memset(buf, 0, srl); /* right + left */
+   }
+   if (srbtl) memset(buf, 0, srbtl); /* last right + bottom + top + 1st left */
+   buf += srbtl + sw;
+   for (i=h-1; i>0; i--, buf += ss) {
+      if (srl) memset(buf, 0, srl); /* right + left */
+   }
+   if (srb) memset(buf, 0, srb); /* last right + last bottom */
+}
+
+/* Set CPU governor */
+enum cpugov { PERFORMANCE = 0, POWERSAVE = 1, ONDEMAND = 2 };
+static void sdl_miyoomini_set_cpugovernor(enum cpugov gov) {
+   const char govstr[3][12] = { "performance", "powersave", "ondemand" };
+   int fd = open("/sys/devices/system/cpu/cpufreq/policy0/scaling_governor", O_WRONLY);
+   if (fd > 0) {
+      write(fd, govstr[gov], strlen(govstr[gov])); close(fd);
+   }
+}
+
+static void sdl_miyoomini_init_font_color(sdl_miyoomini_video_t *vid) {
+   settings_t *settings = config_get_ptr();
+   uint32_t red         = 0xFF;
+   uint32_t green       = 0xFF;
+   uint32_t blue        = 0xFF;
+
+   if (settings) {
+      red   = (uint32_t)((settings->floats.video_msg_color_r * 255.0f) + 0.5f) & 0xFF;
+      green = (uint32_t)((settings->floats.video_msg_color_g * 255.0f) + 0.5f) & 0xFF;
+      blue  = (uint32_t)((settings->floats.video_msg_color_b * 255.0f) + 0.5f) & 0xFF;
+   }
+
+   /* Convert to XRGB8888 */
+   vid->font_colour32 = (red << 16) | (green << 8) | blue;
+}
+
+static void sdl_miyoomini_gfx_free(void *data) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   if (GFX_GetFlipCallback()) {
+      GFX_SetFlipCallback(NULL, NULL); usleep(0x2000); /* wait for finish callback */
+   }
+   GFX_WaitAllDone();
+   if (vid->screen) GFX_FreeSurface(vid->screen);
+   if (vid->menuscreen) GFX_FreeSurface(vid->menuscreen);
+   if (vid->menuscreen_rgui) GFX_FreeSurface(vid->menuscreen_rgui);
+   GFX_Quit();
+
+   if (vid->osd_font) bitmapfont_free_lut(vid->osd_font);
+
+   free(vid);
+
+   sdl_miyoomini_set_cpugovernor(ONDEMAND);
+}
+
+static void sdl_miyoomini_input_driver_init(
+      const char *input_driver_name, const char *joypad_driver_name,
+      input_driver_t **input, void **input_data) {
+   /* Sanity check */
+   if (!input || !input_data) return;
+
+   *input      = NULL;
+   *input_data = NULL;
+
+   /* If input driver name is empty, cannot
+    * initialise anything... */
+   if (string_is_empty(input_driver_name)) return;
+
+   if (string_is_equal(input_driver_name, "sdl_dingux")) {
+      *input_data = input_driver_init_wrap(&input_sdl_dingux,
+            joypad_driver_name);
+      if (*input_data) *input = &input_sdl_dingux;
+      return;
+   }
+
+#if defined(HAVE_SDL) || defined(HAVE_SDL2)
+   if (string_is_equal(input_driver_name, "sdl")) {
+      *input_data = input_driver_init_wrap(&input_sdl,
+            joypad_driver_name);
+      if (*input_data) *input = &input_sdl;
+      return;
+   }
+#endif
+
+#if defined(HAVE_UDEV)
+   if (string_is_equal(input_driver_name, "udev")) {
+      *input_data = input_driver_init_wrap(&input_udev,
+            joypad_driver_name);
+      if (*input_data) *input = &input_udev;
+      return;
+   }
+#endif
+
+#if defined(__linux__)
+   if (string_is_equal(input_driver_name, "linuxraw")) {
+      *input_data = input_driver_init_wrap(&input_linuxraw,
+            joypad_driver_name);
+      if (*input_data) *input = &input_linuxraw;
+      return;
+   }
+#endif
+}
+
+static void sdl_miyoomini_set_output(
+      sdl_miyoomini_video_t* vid,
+      unsigned width, unsigned height, bool rgb32) {
+   vid->content_width  = width;
+   vid->content_height = height;
+   if (vid->rotate & 1) { width = vid->content_height; height = vid->content_width; }
+
+   /* Calculate scaling factor */
+   uint32_t xmul = (SDL_MIYOOMINI_WIDTH<<16) / width;
+   uint32_t ymul = (SDL_MIYOOMINI_HEIGHT<<16) / height;
+   uint32_t mul = xmul < ymul ? xmul : ymul;
+   uint32_t mul_int = (mul>>16);
+
+   /* Change to aspect/fullscreen scaler when integer & screen size is over (no crop) */
+   if (vid->scale_integer && mul_int) {
+      /* Integer Scaling */
+      vid->video_w = width * mul_int;
+      vid->video_h = height * mul_int;
+      if (!vid->keep_aspect) {
+         /* Integer + Fullscreen , keep 4:3 for CRT console emulators */
+         uint32_t Wx3 = vid->video_w * 3;
+         uint32_t Hx4 = vid->video_h * 4;
+         if (Wx3 != Hx4) {
+            if (Wx3 > Hx4) vid->video_h = Wx3 / 4;
+            else           vid->video_w = Hx4 / 3;
+         }
+      }
+      vid->video_x = (SDL_MIYOOMINI_WIDTH - vid->video_w) >> 1;
+      vid->video_y = (SDL_MIYOOMINI_HEIGHT - vid->video_h) >> 1;
+   } else if (vid->keep_aspect) {
+      /* Aspect Scaling */
+      if (xmul > ymul) {
+         vid->video_w  = (width * SDL_MIYOOMINI_HEIGHT) / height;
+         vid->video_h = SDL_MIYOOMINI_HEIGHT;
+         vid->video_x = (SDL_MIYOOMINI_WIDTH - vid->video_w) >> 1;
+         vid->video_y = 0;
+      } else {
+         vid->video_w  = SDL_MIYOOMINI_WIDTH;
+         vid->video_h = (height * SDL_MIYOOMINI_WIDTH) / width;
+         vid->video_x = 0;
+         vid->video_y = (SDL_MIYOOMINI_HEIGHT - vid->video_h) >> 1;
+      }
+   } else {
+      /* Fullscreen */
+      vid->video_w = SDL_MIYOOMINI_WIDTH;
+      vid->video_h = SDL_MIYOOMINI_HEIGHT;
+      vid->video_x = 0;
+      vid->video_y = 0;
+   }
+   /* align to x4 bytes */
+   if (!rgb32) { vid->video_x &= ~1; vid->video_w &= ~1; }
+
+   /* Select scaler to use */
+   uint32_t scale_mul = 0;
+   if ( (vid->filter_type != DINGUX_IPU_FILTER_NEAREST) || (vid->scale_integer && mul_int && vid->keep_aspect) ) {
+      scale_mul = 1;
+      if ( (vid->scale_integer) || (vid->filter_type == DINGUX_IPU_FILTER_BICUBIC) ) {
+         if      ((xmul > ymul ? xmul : ymul) >= (640<<16)/256) scale_mul = 4; /* w <= 256 or h <= 192 */
+         else if ((xmul > ymul ? xmul : ymul) >= (640<<16)/512) scale_mul = 2; /* w <= 512 or h <= 384 */
+      }
+   }
+   vid->frame_width  = scale_mul ? vid->content_width  * scale_mul : vid->video_w;
+   vid->frame_height = scale_mul ? vid->content_height * scale_mul : vid->video_h;
+
+   switch (scale_mul) {
+      case 0:
+         vid->scale_func = rgb32 ? scalenn_32 : scalenn_16;
+         break;
+      case 2:
+         vid->scale_func = rgb32 ? scale2x_32 : scale2x_16;
+         break;
+      case 4:
+         vid->scale_func = rgb32 ? scale4x_32 : scale4x_16;
+         break;
+      default:
+         vid->scale_func = rgb32 ? scale1x_32 : scale1x_16;
+         break;
+   }
+
+/* for DEBUG
+   fprintf(stderr,"cw:%d ch:%d fw:%d fh:%d x:%d y:%d w:%d h:%d mul:%f scale_mul:%d\n",vid->content_width,vid->content_height,
+         vid->frame_width,vid->frame_height,vid->video_x,vid->video_y,vid->video_w,vid->video_h,(float)mul/(1<<16),scale_mul);
+*/
+
+   /* Attempt to change video mode */
+   GFX_WaitAllDone();
+   if (vid->screen) GFX_FreeSurface(vid->screen);
+   vid->screen = GFX_CreateRGBSurface(
+         0, vid->frame_width, vid->frame_height, rgb32 ? 32 : 16, 0, 0, 0, 0);
+
+   /* Check whether selected display mode is valid */
+   if (unlikely(!vid->screen)) RARCH_ERR("[MI_GFX]: Failed to init GFX surface\n");
+   /* Clear border */
+   else if (!vid->menu_active) sdl_miyoomini_clear_border(fb_addr, vid->video_x, vid->video_y, vid->video_w, vid->video_h);
+}
+
+static void *sdl_miyoomini_gfx_init(const video_info_t *video,
+      input_driver_t **input, void **input_data) {
+   sdl_miyoomini_video_t *vid                    = NULL;
+   uint32_t sdl_subsystem_flags                  = SDL_WasInit(0);
+   settings_t *settings                          = config_get_ptr();
+   const char *input_driver_name                 = settings->arrays.input_driver;
+   const char *joypad_driver_name                = settings->arrays.input_joypad_driver;
+
+   sdl_miyoomini_set_cpugovernor(PERFORMANCE);
+
+   /* Initialise graphics subsystem, if required */
+   if (sdl_subsystem_flags == 0) {
+      if (SDL_Init(SDL_INIT_VIDEO) < 0) return NULL;
+   } else if ((sdl_subsystem_flags & SDL_INIT_VIDEO) == 0) {
+      if (SDL_InitSubSystem(SDL_INIT_VIDEO) < 0) return NULL;
+   }
+
+   vid = (sdl_miyoomini_video_t*)calloc(1, sizeof(*vid));
+   if (!vid) return NULL;
+
+   GFX_Init();
+
+   vid->menuscreen = GFX_CreateRGBSurface(
+         0, SDL_MIYOOMINI_WIDTH, SDL_MIYOOMINI_HEIGHT, 16, 0, 0, 0, 0);
+   vid->menuscreen_rgui = GFX_CreateRGBSurface(
+         0, RGUI_MENU_WIDTH, RGUI_MENU_HEIGHT, 16, 0, 0, 0, 0);
+
+   if (!vid->menuscreen||!vid->menuscreen_rgui) {
+      RARCH_ERR("[MI_GFX]: Failed to init GFX surface\n");
+      goto error;
+   }
+
+   vid->content_width     = SDL_MIYOOMINI_WIDTH;
+   vid->content_height    = SDL_MIYOOMINI_HEIGHT;
+   vid->rgb32             = video->rgb32;
+   vid->vsync             = video->vsync;
+   vid->keep_aspect       = settings->bools.video_dingux_ipu_keep_aspect;
+   vid->scale_integer     = settings->bools.video_scale_integer;
+   vid->filter_type       = (enum dingux_ipu_filter_type)settings->uints.video_dingux_ipu_filter_type;
+   vid->menu_active       = false;
+   vid->was_in_menu       = false;
+   vid->quitting          = false;
+   vid->ff_frame_time_min = 16667;
+
+   sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+
+   GFX_SetFlipFlags(vid->vsync ? GFX_BLOCKING|GFX_FLIPWAIT : 0);
+
+   sdl_miyoomini_input_driver_init(input_driver_name,
+         joypad_driver_name, input, input_data);
+
+   /* Initialise OSD font */
+   sdl_miyoomini_init_font_color(vid);
+
+   vid->osd_font = bitmapfont_get_lut();
+
+   if (!vid->osd_font ||
+       vid->osd_font->glyph_max <
+            (SDL_NUM_FONT_GLYPHS - 1)) {
+      RARCH_ERR("[SDL1]: Failed to init OSD font\n");
+      goto error;
+   }
+
+   return vid;
+
+error:
+   sdl_miyoomini_gfx_free(vid);
+   return NULL;
+}
+
+static bool sdl_miyoomini_gfx_frame(void *data, const void *frame,
+      unsigned width, unsigned height, uint64_t frame_count,
+      unsigned pitch, const char *msg, video_frame_info_t *video_info) {
+   sdl_miyoomini_video_t* vid = (sdl_miyoomini_video_t*)data;
+
+   /* Return early if:
+    * - Input sdl_miyoomini_video_t struct is NULL
+    *   (cannot realistically happen)
+    * - Menu is inactive and input 'content' frame
+    *   data is NULL (may happen when e.g. a running
+    *   core skips a frame) */
+   if (unlikely(!vid || (!frame && !vid->menu_active))) return true;
+
+   /* If fast forward is currently active, we may
+    * push frames at an 'unlimited' rate. Since the
+    * display has a fixed refresh rate of 60 Hz, this
+    * represents wasted effort. We therefore drop any
+    * 'excess' frames in this case.
+    * (Note that we *only* do this when fast forwarding.
+    * Attempting this trick while running content normally
+    * will cause bad frame pacing) */
+   if (unlikely(video_info->input_driver_nonblock_state)) {
+      retro_time_t current_time = cpu_features_get_time_usec();
+
+      if ((current_time - vid->last_frame_time) < vid->ff_frame_time_min)
+         return true;
+
+      vid->last_frame_time = current_time;
+   }
+
+#ifdef HAVE_MENU
+   menu_driver_frame(video_info->menu_is_alive, video_info);
+#endif
+
+   /* Render OSD text at flip */
+   if (msg) {
+      memcpy(vid->msg_tmp, msg, sizeof(vid->msg_tmp));
+      GFX_SetFlipCallback(sdl_miyoomini_print_msg, vid);
+   } else if (vid->msg_count) {
+      vid->msg_tmp[0] = 0;
+      GFX_SetFlipCallback(sdl_miyoomini_print_msg, vid);
+   } else {
+      GFX_SetFlipCallback(NULL, NULL);
+   }
+
+   if (likely(!vid->menu_active)) {
+      /* Clear border if we were in the menu on the previous frame */
+      if (unlikely(vid->was_in_menu)) {
+         sdl_miyoomini_clear_border(fb_addr, vid->video_x, vid->video_y, vid->video_w, vid->video_h);
+         vid->was_in_menu = false;
+      }
+      /* Update video mode if width/height have changed */
+      if (unlikely( (vid->content_width  != width ) ||
+                    (vid->content_height != height) )) {
+         sdl_miyoomini_set_output(vid, width, height, vid->rgb32);
+      }
+      /* WaitAllDone when frametime is too fast ( < 8.192ms ) */
+      static long recent_usec;
+      struct timeval tod;
+      gettimeofday(&tod, NULL);
+      if (tod.tv_usec < recent_usec) recent_usec -= 1000000;
+      if (tod.tv_usec - recent_usec < 8192) MI_GFX_WaitAllDone(FALSE, flipFence);
+      recent_usec = tod.tv_usec;
+      /* Blit frame to GFX surface */
+      vid->scale_func(vid, (void*)frame, vid->screen->pixels, width, height, pitch, vid->screen->pitch);
+      GFX_UpdateRect(vid->screen, vid->video_x, vid->video_y, vid->video_w, vid->video_h);
+   } else {
+      scale2x_n16(vid->menuscreen_rgui->pixels, vid->menuscreen->pixels, RGUI_MENU_WIDTH, RGUI_MENU_HEIGHT, 0,0);
+      stOpt.eRotate = E_MI_GFX_ROTATE_180;
+      GFX_Flip(vid->menuscreen);
+      stOpt.eRotate = vid->rotate;
+   }
+   return true;
+}
+
+static void sdl_miyoomini_set_texture_enable(void *data, bool state, bool full_screen) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   if (state == vid->menu_active) return;
+   vid->menu_active = state;
+
+   if (state) {
+      sdl_miyoomini_set_cpugovernor(POWERSAVE);
+      vid->was_in_menu = true;
+   } else sdl_miyoomini_set_cpugovernor(PERFORMANCE);
+}
+
+static void sdl_miyoomini_set_texture_frame(void *data, const void *frame, bool rgb32,
+      unsigned width, unsigned height, float alpha) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+
+   if (unlikely( !vid || rgb32 || (width != RGUI_MENU_WIDTH) || (height != RGUI_MENU_HEIGHT))) return;
+
+   memcpy_neon(vid->menuscreen_rgui->pixels, (void*)frame,
+      RGUI_MENU_WIDTH * RGUI_MENU_HEIGHT * sizeof(uint16_t));
+}
+
+static void sdl_miyoomini_gfx_set_nonblock_state(void *data, bool toggle,
+      bool adaptive_vsync_enabled, unsigned swap_interval) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   bool vsync            = !toggle;
+
+   /* Check whether vsync status has changed */
+   if (vid->vsync != vsync)
+   {
+      vid->vsync              = vsync;
+      GFX_SetFlipFlags(vsync ? GFX_BLOCKING|GFX_FLIPWAIT : 0);
+   }
+}
+
+static void sdl_miyoomini_gfx_check_window(sdl_miyoomini_video_t *vid) {
+   SDL_Event event;
+
+   SDL_PumpEvents();
+   while (SDL_PeepEvents(&event, 1, SDL_GETEVENT, SDL_QUITMASK))
+   {
+      if (event.type != SDL_QUIT)
+         continue;
+
+      vid->quitting = true;
+      break;
+   }
+}
+
+static bool sdl_miyoomini_gfx_alive(void *data) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return false;
+
+   sdl_miyoomini_gfx_check_window(vid);
+   return !vid->quitting;
+}
+
+static bool sdl_miyoomini_gfx_focus(void *data) { return true; }
+static bool sdl_miyoomini_gfx_suppress_screensaver(void *data, bool enable) { return false; }
+static bool sdl_miyoomini_gfx_has_windowed(void *data) { return false; }
+
+static void sdl_miyoomini_gfx_set_rotation(void *data, unsigned rotation) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+   switch (rotation) {
+      case 1:
+         stOpt.eRotate = E_MI_GFX_ROTATE_90; break;
+      case 2:
+         stOpt.eRotate = E_MI_GFX_ROTATE_0; break;
+      case 3:
+         stOpt.eRotate = E_MI_GFX_ROTATE_270; break;
+      default:
+         stOpt.eRotate = E_MI_GFX_ROTATE_180; break;
+   }
+   if (vid->rotate != stOpt.eRotate) {
+      vid->rotate = stOpt.eRotate;
+      sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+   }
+}
+
+static void sdl_miyoomini_gfx_viewport_info(void *data, struct video_viewport *vp) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   if (unlikely(!vid)) return;
+
+   vp->x           = vid->video_x;
+   vp->y           = vid->video_y;
+   vp->width       = vid->video_w;
+   vp->height      = vid->video_h;
+   vp->full_width  = SDL_MIYOOMINI_WIDTH;
+   vp->full_height = SDL_MIYOOMINI_HEIGHT;
+}
+
+static float sdl_miyoomini_get_refresh_rate(void *data) { return 60.0f; }
+
+static void sdl_miyoomini_set_filtering(void *data, unsigned index, bool smooth, bool ctx_scaling) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   settings_t *settings       = config_get_ptr();
+   if (unlikely(!vid || !settings)) return;
+
+   enum dingux_ipu_filter_type ipu_filter_type = (settings) ?
+         (enum dingux_ipu_filter_type)settings->uints.video_dingux_ipu_filter_type :
+         DINGUX_IPU_FILTER_BICUBIC;
+
+   /* Update software filter setting, if required */
+   if (vid->filter_type != ipu_filter_type) {
+      vid->filter_type = ipu_filter_type;
+      sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+   }
+}
+
+static void sdl_miyoomini_apply_state_changes(void *data) {
+   sdl_miyoomini_video_t *vid = (sdl_miyoomini_video_t*)data;
+   settings_t *settings       = config_get_ptr();
+   if (unlikely(!vid || !settings)) return;
+
+   bool keep_aspect       = (settings) ? settings->bools.video_dingux_ipu_keep_aspect : true;
+   bool integer_scaling   = (settings) ? settings->bools.video_scale_integer : false;
+
+   if ((vid->keep_aspect != keep_aspect) ||
+       (vid->scale_integer != integer_scaling)) {
+      vid->keep_aspect   = keep_aspect;
+      vid->scale_integer = integer_scaling;
+
+      /* Aspect/scaling changes require all frame
+       * dimension/padding/cropping parameters to
+       * be recalculated. Easiest method is to just
+       * (re-)set the current output video mode */
+      sdl_miyoomini_set_output(vid, vid->content_width, vid->content_height, vid->rgb32);
+   }
+}
+
+static uint32_t sdl_miyoomini_get_flags(void *data) { return 0; }
+
+static const video_poke_interface_t sdl_miyoomini_poke_interface = {
+   sdl_miyoomini_get_flags,
+   NULL, /* load_texture */
+   NULL, /* unload_texture */
+   NULL, /* set_video_mode */
+   sdl_miyoomini_get_refresh_rate,
+   sdl_miyoomini_set_filtering,
+   NULL, /* get_video_output_size */
+   NULL, /* get_video_output_prev */
+   NULL, /* get_video_output_next */
+   NULL, /* get_current_framebuffer */
+   NULL, /* get_proc_address */
+   NULL, /* set_aspect_ratio */
+   sdl_miyoomini_apply_state_changes,
+   sdl_miyoomini_set_texture_frame,
+   sdl_miyoomini_set_texture_enable,
+   NULL, /* set_osd_msg */
+   NULL, /* sdl_show_mouse */
+   NULL, /* sdl_grab_mouse_toggle */
+   NULL, /* get_current_shader */
+   NULL, /* get_current_software_framebuffer */
+   NULL, /* get_hw_render_interface */
+   NULL, /* set_hdr_max_nits */
+   NULL, /* set_hdr_paper_white_nits */
+   NULL, /* set_hdr_contrast */
+   NULL  /* set_hdr_expand_gamut */
+};
+
+static void sdl_miyoomini_get_poke_interface(void *data, const video_poke_interface_t **iface) {
+   *iface = &sdl_miyoomini_poke_interface;
+}
+
+static bool sdl_miyoomini_gfx_set_shader(void *data,
+      enum rarch_shader_type type, const char *path) { return false; }
+
+video_driver_t video_sdl_dingux = {
+   sdl_miyoomini_gfx_init,
+   sdl_miyoomini_gfx_frame,
+   sdl_miyoomini_gfx_set_nonblock_state,
+   sdl_miyoomini_gfx_alive,
+   sdl_miyoomini_gfx_focus,
+   sdl_miyoomini_gfx_suppress_screensaver,
+   sdl_miyoomini_gfx_has_windowed,
+   sdl_miyoomini_gfx_set_shader,
+   sdl_miyoomini_gfx_free,
+   "sdl_dingux",
+   NULL, /* set_viewport */
+   sdl_miyoomini_gfx_set_rotation,
+   sdl_miyoomini_gfx_viewport_info,
+   NULL, /* read_viewport  */
+   NULL, /* read_frame_raw */
+#ifdef HAVE_OVERLAY
+   NULL, /* get_overlay_interface */
+#endif
+#ifdef HAVE_VIDEO_LAYOUT
+   NULL, /* get_video_layout_render_interface */
+#endif
+   sdl_miyoomini_get_poke_interface
+};
diff --git a/gfx/drivers/sdl_dingux_gfx.c b/gfx/drivers/sdl_dingux_gfx.c
index 5b710e887d..bf0fff79df 100644
--- a/gfx/drivers/sdl_dingux_gfx.c
+++ b/gfx/drivers/sdl_dingux_gfx.c
@@ -15,6 +15,9 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "miyoomini/sdl_miyoomini_gfx.c"
+#else
 
 #include <stdlib.h>
 #include <string.h>
@@ -1143,3 +1146,4 @@ video_driver_t video_sdl_dingux = {
 #endif
    sdl_dingux_get_poke_interface
 };
+#endif
diff --git a/gfx/video_filter.c b/gfx/video_filter.c
index 092a5d2a81..c0734b7f9b 100644
--- a/gfx/video_filter.c
+++ b/gfx/video_filter.c
@@ -294,7 +294,6 @@ extern const struct softfilter_implementation *upscale_1_5x_get_implementation(s
 extern const struct softfilter_implementation *upscale_256x_320x240_get_implementation(softfilter_simd_mask_t simd);
 extern const struct softfilter_implementation *picoscale_256x_320x240_get_implementation(softfilter_simd_mask_t simd);
 extern const struct softfilter_implementation *upscale_240x160_320x240_get_implementation(softfilter_simd_mask_t simd);
-extern const struct softfilter_implementation *upscale_mix_240x160_320x240_get_implementation(softfilter_simd_mask_t simd);
 
 static const softfilter_get_implementation_t soft_plugs_builtin[] = {
    blargg_ntsc_snes_get_implementation,
@@ -322,7 +321,6 @@ static const softfilter_get_implementation_t soft_plugs_builtin[] = {
    upscale_256x_320x240_get_implementation,
    picoscale_256x_320x240_get_implementation,
    upscale_240x160_320x240_get_implementation,
-   upscale_mix_240x160_320x240_get_implementation,
 };
 
 static bool append_softfilter_plugs(rarch_softfilter_t *filt,
@@ -347,16 +345,19 @@ static bool append_softfilter_plugs(rarch_softfilter_t *filt,
       if (!filt->plugs[i].impl)
          return false;
    }
-
+ #if !defined(HAVE_DYLIB)
    return true;
 }
-#elif defined(HAVE_DYLIB)
+ #endif
+#endif
+#if defined(HAVE_DYLIB)
+ #if !defined(HAVE_FILTERS_BUILTIN)
 static bool append_softfilter_plugs(rarch_softfilter_t *filt,
       struct string_list *list)
 {
    unsigned i;
    softfilter_simd_mask_t mask = (softfilter_simd_mask_t)cpu_features_get();
-
+ #endif
    for (i = 0; i < list->size; i++)
    {
       softfilter_get_implementation_t cb;
@@ -409,7 +410,7 @@ static bool append_softfilter_plugs(rarch_softfilter_t *filt,
 
    return true;
 }
-#else
+#elif !defined(HAVE_FILTERS_BUILTIN)
 static bool append_softfilter_plugs(rarch_softfilter_t *filt,
       struct string_list *list)
 {
@@ -509,6 +510,8 @@ void rarch_softfilter_free(rarch_softfilter_t *filt)
    {
       for (i = 0; i < filt->threads; i++)
       {
+         if (!&filt->thread_data[i])
+            continue;
          if (!filt->thread_data[i].thread)
             continue;
          slock_lock(filt->thread_data[i].lock);
diff --git a/gfx/video_filters/LCD2x_dark.filt b/gfx/video_filters/LCD2x_dark.filt
new file mode 100644
index 0000000000..2d5f621330
--- /dev/null
+++ b/gfx/video_filters/LCD2x_dark.filt
@@ -0,0 +1 @@
+filter = lcd2x_dark
diff --git a/gfx/video_filters/LCD2x_light.filt b/gfx/video_filters/LCD2x_light.filt
new file mode 100644
index 0000000000..919461de9a
--- /dev/null
+++ b/gfx/video_filters/LCD2x_light.filt
@@ -0,0 +1 @@
+filter = lcd2x_light
diff --git a/gfx/video_filters/LCD3x_dark.filt b/gfx/video_filters/LCD3x_dark.filt
new file mode 100644
index 0000000000..a80e9c8c75
--- /dev/null
+++ b/gfx/video_filters/LCD3x_dark.filt
@@ -0,0 +1 @@
+filter = lcd3x_dark
diff --git a/gfx/video_filters/LCD3x_light.filt b/gfx/video_filters/LCD3x_light.filt
new file mode 100644
index 0000000000..8a8192ac55
--- /dev/null
+++ b/gfx/video_filters/LCD3x_light.filt
@@ -0,0 +1 @@
+filter = lcd3x_light
diff --git a/gfx/video_filters/LCD3x_mosaic.filt b/gfx/video_filters/LCD3x_mosaic.filt
new file mode 100644
index 0000000000..05cbf47ed3
--- /dev/null
+++ b/gfx/video_filters/LCD3x_mosaic.filt
@@ -0,0 +1 @@
+filter = lcd3x_mosaic
diff --git a/gfx/video_filters/LCD3x_stripe.filt b/gfx/video_filters/LCD3x_stripe.filt
new file mode 100644
index 0000000000..e739ec88c3
--- /dev/null
+++ b/gfx/video_filters/LCD3x_stripe.filt
@@ -0,0 +1 @@
+filter = lcd3x_stripe
diff --git a/gfx/video_filters/Normal3x.filt b/gfx/video_filters/Normal3x.filt
new file mode 100644
index 0000000000..9aef22a18b
--- /dev/null
+++ b/gfx/video_filters/Normal3x.filt
@@ -0,0 +1 @@
+filter = normal3x
diff --git a/gfx/video_filters/lcd2x_dark.c b/gfx/video_filters/lcd2x_dark.c
new file mode 100644
index 0000000000..0ba15f3136
--- /dev/null
+++ b/gfx/video_filters/lcd2x_dark.c
@@ -0,0 +1,219 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd2x_dark.so -shared lcd2x_dark.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd2x_dark_get_implementation
+#define softfilter_thread_data lcd2x_dark_softfilter_thread_data
+#define filter_data lcd2x_dark_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd2x_dark_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd2x_dark_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd2x_dark_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd2x_dark_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd2x_dark_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width<<1;
+   *out_height = height<<1;
+}
+
+static void lcd2x_dark_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd2x_dark_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, dpix4, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=2) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x001F)<<16);		// RB
+			dpix2=(pix & 0x07E0);					// G-
+			dpix3=((pix>>16) & 0xF800) | (pix & 0x001F0000);	// rb
+			dpix4=((pix>>16) & 0x07E0);				// g-
+			d[dx] = dpix1; d[dx+1] = dpix3;
+			d[dx+dp32] = dpix2; d[dx+dp32+1] = dpix4;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x001F)<<16);	// RB
+			dpix2=(pix16 & 0x07E0);					// G-
+			d[dx] = dpix1;
+			d[dx+dp32] = dpix2;
+		}
+	}
+}
+
+static void lcd2x_dark_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=2) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x000000FF;
+			d[dx+dp32] = pix & 0x0000FF00; d[dx+dp32+1] = 0;
+		}
+	}
+}
+
+static void lcd2x_dark_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_dark_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_dark_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_dark_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_dark_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd2x_dark_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd2x_dark_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd2x_dark_generic = {
+   lcd2x_dark_generic_input_fmts,
+   lcd2x_dark_generic_output_fmts,
+
+   lcd2x_dark_generic_create,
+   lcd2x_dark_generic_destroy,
+
+   lcd2x_dark_generic_threads,
+   lcd2x_dark_generic_output,
+   lcd2x_dark_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD2x_dark",
+   "lcd2x_dark",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd2x_dark_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd2x_light.c b/gfx/video_filters/lcd2x_light.c
new file mode 100644
index 0000000000..da46f9471c
--- /dev/null
+++ b/gfx/video_filters/lcd2x_light.c
@@ -0,0 +1,219 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd2x_light.so -shared lcd2x_light.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd2x_light_get_implementation
+#define softfilter_thread_data lcd2x_light_softfilter_thread_data
+#define filter_data lcd2x_light_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd2x_light_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd2x_light_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd2x_light_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd2x_light_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd2x_light_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width<<1;
+   *out_height = height<<1;
+}
+
+static void lcd2x_light_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd2x_light_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, dpix4, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=2) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x001F)<<16);		// RB
+			dpix2=(pix & 0x07E0) | (pix<<16);			// GP
+			dpix3=((pix>>16) & 0xF800) | (pix & 0x001F0000);	// rb
+			dpix4=((pix>>16) & 0x07E0) | (pix & 0xFFFF0000);	// gp
+			d[dx] = dpix1; d[dx+1] = dpix3;
+			d[dx+dp32] = dpix2; d[dx+dp32+1] = dpix4;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x001F)<<16);	// RB
+			dpix2=(pix16 & 0x07E0) | (pix16<<16);			// GP
+			d[dx] = dpix1;
+			d[dx+dp32] = dpix2;
+		}
+	}
+}
+
+static void lcd2x_light_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=2) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x000000FF;
+			d[dx+dp32] = pix & 0x0000FF00; d[dx+dp32+1] = pix;
+		}
+	}
+}
+
+static void lcd2x_light_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_light_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_light_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_light_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_light_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd2x_light_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd2x_light_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd2x_light_generic = {
+   lcd2x_light_generic_input_fmts,
+   lcd2x_light_generic_output_fmts,
+
+   lcd2x_light_generic_create,
+   lcd2x_light_generic_destroy,
+
+   lcd2x_light_generic_threads,
+   lcd2x_light_generic_output,
+   lcd2x_light_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD2x_light",
+   "lcd2x_light",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd2x_light_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_dark.c b/gfx/video_filters/lcd3x_dark.c
new file mode 100644
index 0000000000..2930b80df0
--- /dev/null
+++ b/gfx/video_filters/lcd3x_dark.c
@@ -0,0 +1,229 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_dark.so -shared lcd3x_dark.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_dark_get_implementation
+#define softfilter_thread_data lcd3x_dark_softfilter_thread_data
+#define filter_data lcd3x_dark_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_dark_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_dark_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_dark_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_dark_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_dark_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_dark_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_dark_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF8000000);				// -r
+			dpix3=((pix>>16) & 0x07E0);				// g-
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx+dp32] = dpix1; d[dx+dp32+1] = dpix2; d[dx+dp32+2] = dpix3;
+			dpix1=0;						// --
+			dpix2=(pix & 0x001F);					// B-
+			dpix3=(pix & 0x001F0000);				// -b
+			d[dx+dp32*2] = dpix1; d[dx+dp32*2+1] = dpix2; d[dx+dp32*2+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = 0;			// -
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx+dp32] = dpix1; d16[(dx+dp32+1)*2] = (pix16 & 0x001F);// B
+			dpix1=0;						// --
+			d[dx+dp32*2] = dpix1; d16[(dx+dp32*2+1)*2] = (pix16 & 0x001F);// B
+		}
+	}
+}
+
+static void lcd3x_dark_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = 0;
+			d[dx+dp32] = pix & 0x00FF0000; d[dx+dp32+1] = pix & 0x0000FF00; d[dx+dp32+2] = pix & 0x000000FF;
+			d[dx+dp32*2] = 0; d[dx+dp32*2+1] = 0; d[dx+dp32*2+2] = pix & 0x000000FF;
+		}
+	}
+}
+
+static void lcd3x_dark_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_dark_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_dark_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_dark_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_dark_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_dark_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_dark_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_dark_generic = {
+   lcd3x_dark_generic_input_fmts,
+   lcd3x_dark_generic_output_fmts,
+
+   lcd3x_dark_generic_create,
+   lcd3x_dark_generic_destroy,
+
+   lcd3x_dark_generic_threads,
+   lcd3x_dark_generic_output,
+   lcd3x_dark_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_dark",
+   "lcd3x_dark",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_dark_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_light.c b/gfx/video_filters/lcd3x_light.c
new file mode 100644
index 0000000000..7981b0d96b
--- /dev/null
+++ b/gfx/video_filters/lcd3x_light.c
@@ -0,0 +1,229 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_light.so -shared lcd3x_light.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_light_get_implementation
+#define softfilter_thread_data lcd3x_light_softfilter_thread_data
+#define filter_data lcd3x_light_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_light_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_light_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_light_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_light_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_light_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_light_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_light_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800FFFF);				// Pr
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0xFFFF0000);	// gp
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx+dp32] = dpix1; d[dx+dp32+1] = dpix2; d[dx+dp32+2] = dpix3;
+			dpix1=(pix & 0xFFFF) | (pix<<16);			// PP
+			dpix2=(pix & 0xFFFF001F);				// Bp
+			dpix3=(pix>>16) | (pix & 0x001F0000);			// pb
+			d[dx+dp32*2] = dpix1; d[dx+dp32*2+1] = dpix2; d[dx+dp32*2+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = pix16;			// P
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx+dp32] = dpix1; d16[(dx+dp32+1)*2] = (pix16 & 0x001F);// B
+			dpix1=(pix16 | (pix16 <<16));				// PP
+			d[dx+dp32*2] = dpix1; d16[(dx+dp32*2+1)*2] = (pix16 & 0x001F);// B
+		}
+	}
+}
+
+static void lcd3x_light_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = pix;
+			d[dx+dp32] = pix & 0x00FF0000; d[dx+dp32+1] = pix & 0x0000FF00; d[dx+dp32+2] = pix & 0x000000FF;
+			d[dx+dp32*2] = pix; d[dx+dp32*2+1] = pix; d[dx+dp32*2+2] = pix & 0x000000FF;
+		}
+	}
+}
+
+static void lcd3x_light_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_light_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_light_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_light_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_light_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_light_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_light_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_light_generic = {
+   lcd3x_light_generic_input_fmts,
+   lcd3x_light_generic_output_fmts,
+
+   lcd3x_light_generic_create,
+   lcd3x_light_generic_destroy,
+
+   lcd3x_light_generic_threads,
+   lcd3x_light_generic_output,
+   lcd3x_light_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_light",
+   "lcd3x_light",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_light_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_mosaic.c b/gfx/video_filters/lcd3x_mosaic.c
new file mode 100644
index 0000000000..dcec93dfb0
--- /dev/null
+++ b/gfx/video_filters/lcd3x_mosaic.c
@@ -0,0 +1,229 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_mosaic.so -shared lcd3x_mosaic.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_mosaic_get_implementation
+#define softfilter_thread_data lcd3x_mosaic_softfilter_thread_data
+#define filter_data lcd3x_mosaic_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_mosaic_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_mosaic_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_mosaic_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_mosaic_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_mosaic_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_mosaic_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_mosaic_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+			dpix1=(pix & 0x07E0) | ((pix & 0x001F)<<16);		// GB
+			dpix2=(pix & 0x07E0F800);				// Rg
+			dpix3=((pix>>16) & 0x001F) | (pix & 0xF8000000);	// br
+			d[dx+dp32] = dpix1; d[dx+dp32+1] = dpix2; d[dx+dp32+2] = dpix3;
+			dpix1=(pix & 0x001F) | ((pix & 0xF800)<<16);		// BR
+			dpix2=(pix & 0x001F07E0);				// Gb
+			dpix3=((pix>>16) & 0xF800) | (pix & 0x07E00000);	// rg
+			d[dx+dp32*2] = dpix1; d[dx+dp32*2+1] = dpix2; d[dx+dp32*2+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = (pix16 & 0x001F);	// B
+			dpix1=(pix16 & 0x07E0) | ((pix16 & 0x001F)<<16);	// GB
+			d[dx+dp32] = dpix1; d16[(dx+dp32+1)*2] = (pix16 & 0xF800);// R
+			dpix1=(pix16 & 0x001F) | ((pix16 & 0xF800)<<16);	// BR
+			d[dx+dp32*2] = dpix1; d16[(dx+dp32*2+1)*2] = (pix16 & 0x07E0);// G
+		}
+	}
+}
+
+static void lcd3x_mosaic_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = pix & 0x000000FF;
+			d[dx+dp32] = pix & 0x0000FF00; d[dx+dp32+1] = pix & 0x000000FF; d[dx+dp32+2] = pix & 0x00FF0000;
+			d[dx+dp32*2] = pix & 0x000000FF; d[dx+dp32*2+1] = pix & 0x00FF0000; d[dx+dp32*2+2] = pix & 0x0000FF00;
+		}
+	}
+}
+
+static void lcd3x_mosaic_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_mosaic_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_mosaic_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_mosaic_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_mosaic_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_mosaic_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_mosaic_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_mosaic_generic = {
+   lcd3x_mosaic_generic_input_fmts,
+   lcd3x_mosaic_generic_output_fmts,
+
+   lcd3x_mosaic_generic_create,
+   lcd3x_mosaic_generic_destroy,
+
+   lcd3x_mosaic_generic_threads,
+   lcd3x_mosaic_generic_output,
+   lcd3x_mosaic_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_mosaic",
+   "lcd3x_mosaic",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_mosaic_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_stripe.c b/gfx/video_filters/lcd3x_stripe.c
new file mode 100644
index 0000000000..dd18e0b744
--- /dev/null
+++ b/gfx/video_filters/lcd3x_stripe.c
@@ -0,0 +1,217 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_stripe.so -shared lcd3x_stripe.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_stripe_get_implementation
+#define softfilter_thread_data lcd3x_stripe_softfilter_thread_data
+#define filter_data lcd3x_stripe_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_stripe_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_stripe_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_stripe_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_stripe_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_stripe_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_stripe_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_stripe_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = (pix16 & 0x001F);	// B
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void lcd3x_stripe_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = pix & 0x000000FF;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void lcd3x_stripe_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_stripe_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_stripe_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_stripe_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_stripe_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_stripe_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_stripe_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_stripe_generic = {
+   lcd3x_stripe_generic_input_fmts,
+   lcd3x_stripe_generic_output_fmts,
+
+   lcd3x_stripe_generic_create,
+   lcd3x_stripe_generic_destroy,
+
+   lcd3x_stripe_generic_threads,
+   lcd3x_stripe_generic_output,
+   lcd3x_stripe_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_stripe",
+   "lcd3x_stripe",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_stripe_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/make b/gfx/video_filters/make
new file mode 100644
index 0000000000..76b7bfec47
--- /dev/null
+++ b/gfx/video_filters/make
@@ -0,0 +1,10 @@
+#!/bin/sh
+CROSS_COMPILE="/opt/miyoomini83/bin/arm-linux-gnueabihf-"
+CFLAGS="-Ofast -marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard -march=armv7ve+simd"
+${CROSS_COMPILE}gcc -o normal3x.so normal3x.c ${CFLAGS} -std=c99 -shared -fPIC -Wall -s
+${CROSS_COMPILE}gcc -o lcd2x_dark.so lcd2x_dark.c ${CFLAGS} -std=c99 -shared -fPIC -Wall -s
+${CROSS_COMPILE}gcc -o lcd2x_light.so lcd2x_light.c ${CFLAGS} -std=c99 -shared -fPIC -Wall -s
+${CROSS_COMPILE}gcc -o lcd3x_stripe.so lcd3x_stripe.c ${CFLAGS} -std=c99 -shared -fPIC -Wall -s
+${CROSS_COMPILE}gcc -o lcd3x_mosaic.so lcd3x_mosaic.c ${CFLAGS} -std=c99 -shared -fPIC -Wall -s
+${CROSS_COMPILE}gcc -o lcd3x_dark.so lcd3x_dark.c ${CFLAGS} -std=c99 -shared -fPIC -Wall -s
+${CROSS_COMPILE}gcc -o lcd3x_light.so lcd3x_light.c ${CFLAGS} -std=c99 -shared -fPIC -Wall -s
diff --git a/gfx/video_filters/normal2x.c b/gfx/video_filters/normal2x.c
index 9f7bf447aa..de3dd157d0 100644
--- a/gfx/video_filters/normal2x.c
+++ b/gfx/video_filters/normal2x.c
@@ -16,6 +16,10 @@
 
 /* Compile: gcc -o normal2x.so -shared normal2x.c -std=c99 -O3 -Wall -pedantic -fPIC */
 
+#ifdef MIYOOMINI
+#include "../drivers/miyoomini/scaler_neon.h"
+#endif
+
 #include "softfilter.h"
 #include <stdlib.h>
 #include <string.h>
@@ -102,6 +106,9 @@ static void normal2x_generic_destroy(void *data)
 static void normal2x_work_cb_xrgb8888(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale2x_n32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint32_t *input              = (const uint32_t*)thr->in_data;
    uint32_t *output                   = (uint32_t*)thr->out_data;
    uint32_t in_stride                 = (uint32_t)(thr->in_pitch >> 2);
@@ -133,11 +140,15 @@ static void normal2x_work_cb_xrgb8888(void *data, void *thread_data)
       input  += in_stride;
       output += out_stride << 1;
    }
+#endif
 }
 
 static void normal2x_work_cb_rgb565(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale2x_n16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint16_t *input              = (const uint16_t*)thr->in_data;
    uint16_t *output                   = (uint16_t*)thr->out_data;
    uint16_t in_stride                 = (uint16_t)(thr->in_pitch >> 1);
@@ -169,6 +180,7 @@ static void normal2x_work_cb_rgb565(void *data, void *thread_data)
       input                    += in_stride;
       output                   += out_stride << 1;
    }
+#endif
 }
 
 static void normal2x_generic_packets(void *data,
diff --git a/gfx/video_filters/normal3x.c b/gfx/video_filters/normal3x.c
new file mode 100644
index 0000000000..afc1f1bb8c
--- /dev/null
+++ b/gfx/video_filters/normal3x.c
@@ -0,0 +1,216 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o normal3x.so -shared normal3x.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation normal3x_get_implementation
+#define softfilter_thread_data normal3x_softfilter_thread_data
+#define filter_data normal3x_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned normal3x_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned normal3x_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned normal3x_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *normal3x_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void normal3x_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void normal3x_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void scale3x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = pix; d[dx+2] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d16[(dx+1)*2] = pix16;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void scale3x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void normal3x_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   scale3x_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void normal3x_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   scale3x_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void normal3x_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = normal3x_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = normal3x_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation normal3x_generic = {
+   normal3x_generic_input_fmts,
+   normal3x_generic_output_fmts,
+
+   normal3x_generic_create,
+   normal3x_generic_destroy,
+
+   normal3x_generic_threads,
+   normal3x_generic_output,
+   normal3x_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "Normal3x",
+   "normal3x",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &normal3x_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/normal4x.c b/gfx/video_filters/normal4x.c
index c0af01478e..aafd997b2c 100644
--- a/gfx/video_filters/normal4x.c
+++ b/gfx/video_filters/normal4x.c
@@ -16,6 +16,10 @@
 
 /* Compile: gcc -o normal4x.so -shared normal4x.c -std=c99 -O3 -Wall -pedantic -fPIC */
 
+#ifdef MIYOOMINI
+#include "../drivers/miyoomini/scaler_neon.h"
+#endif
+
 #include "softfilter.h"
 #include <stdlib.h>
 #include <string.h>
@@ -102,6 +106,9 @@ static void normal4x_generic_destroy(void *data)
 static void normal4x_work_cb_xrgb8888(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale4x_n32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint32_t *input              = (const uint32_t*)thr->in_data;
    uint32_t *output                   = (uint32_t*)thr->out_data;
    uint32_t in_stride                 = (uint32_t)(thr->in_pitch >> 2);
@@ -143,11 +150,15 @@ static void normal4x_work_cb_xrgb8888(void *data, void *thread_data)
       input  += in_stride;
       output += out_stride << 2;
    }
+#endif
 }
 
 static void normal4x_work_cb_rgb565(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale4x_n16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint16_t *input              = (const uint16_t*)thr->in_data;
    uint16_t *output                   = (uint16_t*)thr->out_data;
    uint16_t in_stride                 = (uint16_t)(thr->in_pitch >> 1);
@@ -189,6 +200,7 @@ static void normal4x_work_cb_rgb565(void *data, void *thread_data)
       input  += in_stride;
       output += out_stride << 2;
    }
+#endif
 }
 
 static void normal4x_generic_packets(void *data,
diff --git a/input/drivers_joypad/sdl_dingux_joypad.c b/input/drivers_joypad/sdl_dingux_joypad.c
index 543fe5b630..58a45af909 100644
--- a/input/drivers_joypad/sdl_dingux_joypad.c
+++ b/input/drivers_joypad/sdl_dingux_joypad.c
@@ -13,6 +13,9 @@
  *  You should have received a copy of the GNU General Public License along with RetroArch.
  *  If not, see <http://www.gnu.org/licenses/>.
  */
+#if defined(MIYOOMINI)
+#include "sdl_miyoomini_joypad.c"
+#else
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -32,12 +35,9 @@
 #include "../../config.def.h"
 #endif
 
-/* RS-90 devices:
+/* RS-90 and RetroFW devices:
  * - Analog input: No
  * - Menu button:  No
-* RetroFW devices:
- * - Analog input: No
- * - Menu button:  Yes
  * Miyoo devices:
  * - Analog input: No
  * - Menu button:  Yes
@@ -45,8 +45,8 @@
  * - Analog input: Yes
  * - Menu button:  Yes
  */
-#if !defined(RS90)
-#if !(defined(MIYOO) || defined(RETROFW))
+#if !(defined(RS90) || defined(RETROFW))
+#if !defined(MIYOO)
 #define SDL_DINGUX_HAS_ANALOG      1
 #endif
 #define SDL_DINGUX_HAS_MENU_TOGGLE 1
@@ -115,9 +115,7 @@
 #define SDL_DINGUX_SDLK_RIGHT  SDLK_RIGHT
 #define SDL_DINGUX_SDLK_DOWN   SDLK_DOWN
 #define SDL_DINGUX_SDLK_LEFT   SDLK_LEFT
-#if defined(RETROFW)
-#define SDL_DINGUX_SDLK_MENU   SDLK_END
-#elif defined(MIYOO)
+#if defined(MIYOO)
 #define SDL_DINGUX_SDLK_MENU   SDLK_RCTRL
 #else
 #define SDL_DINGUX_SDLK_MENU   SDLK_HOME
@@ -811,3 +809,4 @@ input_device_driver_t sdl_dingux_joypad = {
    sdl_dingux_joypad_name,
    "sdl_dingux",
 };
+#endif
diff --git a/input/drivers_joypad/sdl_miyoomini_joypad.c b/input/drivers_joypad/sdl_miyoomini_joypad.c
new file mode 100644
index 0000000000..0528946333
--- /dev/null
+++ b/input/drivers_joypad/sdl_miyoomini_joypad.c
@@ -0,0 +1,412 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2011-2020 - Daniel De Matteis
+ *  Copyright (C) 2019-2020 - James Leaver
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdint.h>
+#include <stdlib.h>
+
+#include <SDL/SDL.h>
+
+#include <libretro.h>
+
+#include "../input_driver.h"
+#include "../../config.def.h"
+#include "../../tasks/tasks_internal.h"
+#include "../../verbosity.h"
+
+#include <unistd.h>
+#include <fcntl.h>
+
+/* Simple joypad driver designed to rationalise
+ * the bizarre keyboard/gamepad hybrid setup
+ * of OpenDingux devices, exclusive for miyoomini */
+
+#define SDL_MIYOOMINI_JOYPAD_NAME "Dingux Gamepad"
+
+/* Vibration time at 100% vibration strength */
+#define SDL_MIYOOMINI_RUMBLE_MS   200
+
+/* Uncomment if you want the MENU button to be used exclusively for MENU
+#define SDL_MIYOOMINI_HAS_MENU_TOGGLE
+*/
+/* Miyoomini input map to keyboard keys */
+#define SDL_MIYOOMINI_SDLK_X      SDLK_LSHIFT
+#define SDL_MIYOOMINI_SDLK_A      SDLK_SPACE
+#define SDL_MIYOOMINI_SDLK_B      SDLK_LCTRL
+#define SDL_MIYOOMINI_SDLK_Y      SDLK_LALT
+#define SDL_MIYOOMINI_SDLK_L      SDLK_e
+#define SDL_MIYOOMINI_SDLK_R      SDLK_t
+#define SDL_MIYOOMINI_SDLK_L2     SDLK_TAB
+#define SDL_MIYOOMINI_SDLK_R2     SDLK_BACKSPACE
+#define SDL_MIYOOMINI_SDLK_SELECT SDLK_RCTRL
+#define SDL_MIYOOMINI_SDLK_START  SDLK_RETURN
+#if (!defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE))
+#define SDL_MIYOOMINI_SDLK_L3     SDLK_ESCAPE    /* MENU */
+#define SDL_MIYOOMINI_SDLK_R3     SDLK_POWER     /* POWER */
+#else
+#define SDL_MIYOOMINI_SDLK_L3     SDLK_KP_DIVIDE /* no use */
+#define SDL_MIYOOMINI_SDLK_R3     SDLK_KP_PERIOD /* no use */
+#define SDL_MIYOOMINI_SDLK_MENU   SDLK_ESCAPE    /* MENU */
+#endif
+#define SDL_MIYOOMINI_SDLK_UP     SDLK_UP
+#define SDL_MIYOOMINI_SDLK_RIGHT  SDLK_RIGHT
+#define SDL_MIYOOMINI_SDLK_DOWN   SDLK_DOWN
+#define SDL_MIYOOMINI_SDLK_LEFT   SDLK_LEFT
+
+typedef struct {
+   uint16_t pad_state;
+   bool connected;
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   bool menu_toggle;
+#endif
+   uint32_t rumble_time;
+} miyoomini_joypad_t;
+
+static miyoomini_joypad_t miyoomini_joypad;
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+/* TODO/FIXME - global referenced outside */
+extern uint64_t lifecycle_state;
+#endif
+
+void miyoomini_rumble(uint16_t strength) {
+   static char lastvalue = 0;
+   const char str_export[2] = "48";
+   const char str_direction[3] = "out";
+   char value[1];
+   int fd;
+
+   value[0] = (strength == 0 ? 0x31 : 0x30);
+   if (lastvalue != value[0]) {
+      fd = open("/sys/class/gpio/export", O_WRONLY);
+      if (fd > 0) { write(fd, str_export, 2); close(fd); }
+      fd = open("/sys/class/gpio/gpio48/direction", O_WRONLY);
+      if (fd > 0) { write(fd, str_direction, 3); close(fd); }
+      fd = open("/sys/class/gpio/gpio48/value", O_WRONLY);
+      if (fd > 0) { write(fd, value, 1); close(fd); }
+      lastvalue = value[0];
+   }
+}
+
+uint32_t miyoomini_rumble_finish(uint32_t interval) {
+   miyoomini_rumble(0);
+   return 0;
+}
+
+static bool sdl_miyoomini_joypad_set_rumble(unsigned pad,
+      enum retro_rumble_effect effect, uint16_t strength) {
+   if (pad) return false;
+
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   if ( (joypad->rumble_time)&&(strength) ) {
+      miyoomini_rumble(strength);
+      SDL_SetTimer(joypad->rumble_time, miyoomini_rumble_finish);
+   }
+   return true;
+}
+
+static bool sdl_miyoomini_joypad_set_rumble_gain(unsigned pad, unsigned gain) {
+   if (pad != 0) return false;
+   if (gain > 100) gain = 100;
+
+   /* Set gain (actually rumble_time for miyoomini) */
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   joypad->rumble_time = SDL_MIYOOMINI_RUMBLE_MS * gain / 100;
+
+   return true;
+}
+
+static const char *sdl_miyoomini_joypad_name(unsigned port) {
+   if (port != 0) return NULL;
+   return SDL_MIYOOMINI_JOYPAD_NAME;
+}
+
+static void sdl_miyoomini_joypad_connect(void) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   /* 'Register' joypad connection via autoconfig task */
+   input_autoconfigure_connect(
+         sdl_miyoomini_joypad_name(0), /* name */
+         NULL,                         /* display_name */
+         sdl_dingux_joypad.ident,      /* driver */
+         0,                            /* port */
+         0,                            /* vid */
+         0);                           /* pid */
+
+   joypad->connected = true;
+}
+
+static void sdl_miyoomini_joypad_disconnect(void) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   if (joypad->connected)
+      input_autoconfigure_disconnect(0, sdl_dingux_joypad.ident);
+
+   memset(joypad, 0, sizeof(miyoomini_joypad_t));
+}
+
+static void sdl_miyoomini_joypad_destroy(void) {
+   SDL_Event event;
+
+   /* Disconnect joypad */
+   sdl_miyoomini_joypad_disconnect();
+
+   /* Stop rumble */
+   SDL_SetTimer(0, NULL);
+   miyoomini_rumble(0);
+
+   /* Flush out all pending events */
+   while (SDL_PollEvent(&event));
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   BIT64_CLEAR(lifecycle_state, RARCH_MENU_TOGGLE);
+#endif
+}
+
+static void *sdl_miyoomini_joypad_init(void *data) {
+   miyoomini_joypad_t *joypad      = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   memset(joypad, 0, sizeof(miyoomini_joypad_t));
+
+   /* Init for rumble */
+   if (!SDL_WasInit(SDL_INIT_TIMER)) SDL_InitSubSystem(SDL_INIT_TIMER);
+   settings_t *settings = config_get_ptr();
+   unsigned rumble_gain = settings ? settings->uints.input_rumble_gain
+                                   : DEFAULT_RUMBLE_GAIN;
+   sdl_miyoomini_joypad_set_rumble_gain(0, rumble_gain);
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   BIT64_CLEAR(lifecycle_state, RARCH_MENU_TOGGLE);
+#endif
+   /* Connect joypad */
+   sdl_miyoomini_joypad_connect();
+
+   return (void*)-1;
+}
+
+static bool sdl_miyoomini_joypad_query_pad(unsigned port) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   return (port == 0) && joypad->connected;
+}
+
+static int32_t sdl_miyoomini_joypad_button(unsigned port, uint16_t joykey) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   if (port != 0) return 0;
+   return (joypad->pad_state & (1 << joykey));
+}
+
+static void sdl_miyoomini_joypad_get_buttons(unsigned port, input_bits_t *state) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+
+   /* Macros require braces here... */
+   if (port == 0) {
+      BITS_COPY16_PTR(state, joypad->pad_state);
+   } else {
+      BIT256_CLEAR_ALL_PTR(state);
+   }
+}
+
+static int16_t sdl_miyoomini_joypad_axis_state(unsigned port, uint32_t joyaxis) { return 0; }
+
+static int16_t sdl_miyoomini_joypad_axis(unsigned port, uint32_t joyaxis) {
+   if (port != 0) return 0;
+   return sdl_miyoomini_joypad_axis_state(port, joyaxis);
+}
+
+static int16_t sdl_miyoomini_joypad_state(
+      rarch_joypad_info_t *joypad_info,
+      const struct retro_keybind *binds,
+      unsigned port) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   uint16_t port_idx       = joypad_info->joy_idx;
+   int16_t ret             = 0;
+   size_t i;
+
+   if (port_idx != 0) return 0;
+
+   for (i = 0; i < RARCH_FIRST_CUSTOM_BIND; i++) {
+      /* Auto-binds are per joypad, not per user. */
+      const uint64_t joykey  = (binds[i].joykey != NO_BTN)
+         ? binds[i].joykey  : joypad_info->auto_binds[i].joykey;
+
+      if ((uint16_t)joykey != NO_BTN &&
+            (joypad->pad_state & (1 << (uint16_t)joykey)))
+         ret |= (1 << i);
+   }
+
+   return ret;
+}
+
+static void sdl_miyoomini_joypad_poll(void) {
+   miyoomini_joypad_t *joypad = (miyoomini_joypad_t*)&miyoomini_joypad;
+   SDL_Event event;
+
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+   /* Note: The menu toggle key is an awkward special
+    * case - the press/release events happen almost
+    * instantaneously, and since we only sample once
+    * per frame the input is often 'missed'.
+    * If the toggle key gets pressed, we therefore have
+    * to wait until the *next* frame to release it */
+   if (joypad->menu_toggle) {
+      BIT64_CLEAR(lifecycle_state, RARCH_MENU_TOGGLE);
+      joypad->menu_toggle = false;
+   }
+#endif
+
+   /* All digital inputs map to keyboard keys */
+   while (SDL_PollEvent(&event))
+   {
+      switch (event.type)
+      {
+         case SDL_KEYDOWN:
+            switch (event.key.keysym.sym)
+            {
+               case SDL_MIYOOMINI_SDLK_X:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_X);
+                  break;
+               case SDL_MIYOOMINI_SDLK_A:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_A);
+                  break;
+               case SDL_MIYOOMINI_SDLK_B:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_B);
+                  break;
+               case SDL_MIYOOMINI_SDLK_Y:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_Y);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L2:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R2:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_SELECT:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_SELECT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_START:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_START);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L3:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R3:
+               case SDLK_UNKNOWN:	// for stockSDL POWER button
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_UP:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_UP);
+                  break;
+               case SDL_MIYOOMINI_SDLK_RIGHT:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_RIGHT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_DOWN:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_DOWN);
+                  break;
+               case SDL_MIYOOMINI_SDLK_LEFT:
+                  BIT16_SET(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_LEFT);
+                  break;
+#if defined(SDL_MIYOOMINI_HAS_MENU_TOGGLE)
+               case SDL_MIYOOMINI_SDLK_MENU:
+                  BIT64_SET(lifecycle_state, RARCH_MENU_TOGGLE);
+                  joypad->menu_toggle = true;
+                  break;
+#endif
+               default:
+                  break;
+            }
+            break;
+         case SDL_KEYUP:
+            switch (event.key.keysym.sym)
+            {
+               case SDL_MIYOOMINI_SDLK_X:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_X);
+                  break;
+               case SDL_MIYOOMINI_SDLK_A:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_A);
+                  break;
+               case SDL_MIYOOMINI_SDLK_B:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_B);
+                  break;
+               case SDL_MIYOOMINI_SDLK_Y:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_Y);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L2:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R2:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R2);
+                  break;
+               case SDL_MIYOOMINI_SDLK_SELECT:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_SELECT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_START:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_START);
+                  break;
+               case SDL_MIYOOMINI_SDLK_L3:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_L3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_R3:
+               case SDLK_UNKNOWN:	// for stockSDL POWER button
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_R3);
+                  break;
+               case SDL_MIYOOMINI_SDLK_UP:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_UP);
+                  break;
+               case SDL_MIYOOMINI_SDLK_RIGHT:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_RIGHT);
+                  break;
+               case SDL_MIYOOMINI_SDLK_DOWN:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_DOWN);
+                  break;
+               case SDL_MIYOOMINI_SDLK_LEFT:
+                  BIT16_CLEAR(joypad->pad_state, RETRO_DEVICE_ID_JOYPAD_LEFT);
+                  break;
+               default:
+                  break;
+            }
+            break;
+         default:
+            break;
+      }
+   }
+
+}
+
+input_device_driver_t sdl_dingux_joypad = {
+   sdl_miyoomini_joypad_init,
+   sdl_miyoomini_joypad_query_pad,
+   sdl_miyoomini_joypad_destroy,
+   sdl_miyoomini_joypad_button,
+   sdl_miyoomini_joypad_state,
+   sdl_miyoomini_joypad_get_buttons,
+   sdl_miyoomini_joypad_axis,
+   sdl_miyoomini_joypad_poll,
+   sdl_miyoomini_joypad_set_rumble,
+   sdl_miyoomini_joypad_set_rumble_gain,
+   sdl_miyoomini_joypad_name,
+   "sdl_dingux",
+};
diff --git a/libretro-common/audio/conversion/float_to_s16.c b/libretro-common/audio/conversion/float_to_s16.c
index 770981d9c1..cbbd0908f7 100644
--- a/libretro-common/audio/conversion/float_to_s16.c
+++ b/libretro-common/audio/conversion/float_to_s16.c
@@ -32,12 +32,11 @@
 #include <audio/conversion/float_to_s16.h>
 
 #if (defined(__ARM_NEON__) || defined(HAVE_NEON))
+#include <arm_neon.h>
 static bool float_to_s16_neon_enabled = false;
 #ifdef HAVE_ARM_NEON_ASM_OPTIMIZATIONS
 void convert_float_s16_asm(int16_t *out,
       const float *in, size_t samples);
-#else
-#include <arm_neon.h>
 #endif
 
 void convert_float_to_s16(int16_t *out,
diff --git a/readme_retroarch_src.txt b/readme_retroarch_src.txt
new file mode 100644
index 0000000000..3baba63981
--- /dev/null
+++ b/readme_retroarch_src.txt
@@ -0,0 +1,4 @@
+This source is the diff from this version: https://github.com/libretro/RetroArch/releases/tag/v1.10.3
+Makefile is based on Makefile.miyoo/dingux
+MI libraries and headres are in SYSROOT/usr/lib , SYSROOT/usr/include/sdkdir
+dingux_utils.c is taken from https://github.com/TechDevangelist/RetroArch
