diff --git a/gfx/video_filters/LCD2x_dark.filt b/gfx/video_filters/LCD2x_dark.filt
new file mode 100644
index 0000000000..2d5f621330
--- /dev/null
+++ b/gfx/video_filters/LCD2x_dark.filt
@@ -0,0 +1 @@
+filter = lcd2x_dark
diff --git a/gfx/video_filters/LCD2x_light.filt b/gfx/video_filters/LCD2x_light.filt
new file mode 100644
index 0000000000..919461de9a
--- /dev/null
+++ b/gfx/video_filters/LCD2x_light.filt
@@ -0,0 +1 @@
+filter = lcd2x_light
diff --git a/gfx/video_filters/LCD3x_dark.filt b/gfx/video_filters/LCD3x_dark.filt
new file mode 100644
index 0000000000..a80e9c8c75
--- /dev/null
+++ b/gfx/video_filters/LCD3x_dark.filt
@@ -0,0 +1 @@
+filter = lcd3x_dark
diff --git a/gfx/video_filters/LCD3x_light.filt b/gfx/video_filters/LCD3x_light.filt
new file mode 100644
index 0000000000..8a8192ac55
--- /dev/null
+++ b/gfx/video_filters/LCD3x_light.filt
@@ -0,0 +1 @@
+filter = lcd3x_light
diff --git a/gfx/video_filters/LCD3x_mosaic.filt b/gfx/video_filters/LCD3x_mosaic.filt
new file mode 100644
index 0000000000..05cbf47ed3
--- /dev/null
+++ b/gfx/video_filters/LCD3x_mosaic.filt
@@ -0,0 +1 @@
+filter = lcd3x_mosaic
diff --git a/gfx/video_filters/LCD3x_stripe.filt b/gfx/video_filters/LCD3x_stripe.filt
new file mode 100644
index 0000000000..e739ec88c3
--- /dev/null
+++ b/gfx/video_filters/LCD3x_stripe.filt
@@ -0,0 +1 @@
+filter = lcd3x_stripe
diff --git a/gfx/video_filters/Normal3x.filt b/gfx/video_filters/Normal3x.filt
new file mode 100644
index 0000000000..9aef22a18b
--- /dev/null
+++ b/gfx/video_filters/Normal3x.filt
@@ -0,0 +1 @@
+filter = normal3x
diff --git a/gfx/video_filters/Vertical3x4.filt b/gfx/video_filters/Vertical3x4.filt
new file mode 100644
index 0000000000..63d07a5c3f
--- /dev/null
+++ b/gfx/video_filters/Vertical3x4.filt
@@ -0,0 +1 @@
+filter = vertical3x4
diff --git a/gfx/video_filters/lcd2x_dark.c b/gfx/video_filters/lcd2x_dark.c
new file mode 100644
index 0000000000..0ba15f3136
--- /dev/null
+++ b/gfx/video_filters/lcd2x_dark.c
@@ -0,0 +1,219 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd2x_dark.so -shared lcd2x_dark.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd2x_dark_get_implementation
+#define softfilter_thread_data lcd2x_dark_softfilter_thread_data
+#define filter_data lcd2x_dark_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd2x_dark_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd2x_dark_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd2x_dark_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd2x_dark_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd2x_dark_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width<<1;
+   *out_height = height<<1;
+}
+
+static void lcd2x_dark_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd2x_dark_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, dpix4, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=2) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x001F)<<16);		// RB
+			dpix2=(pix & 0x07E0);					// G-
+			dpix3=((pix>>16) & 0xF800) | (pix & 0x001F0000);	// rb
+			dpix4=((pix>>16) & 0x07E0);				// g-
+			d[dx] = dpix1; d[dx+1] = dpix3;
+			d[dx+dp32] = dpix2; d[dx+dp32+1] = dpix4;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x001F)<<16);	// RB
+			dpix2=(pix16 & 0x07E0);					// G-
+			d[dx] = dpix1;
+			d[dx+dp32] = dpix2;
+		}
+	}
+}
+
+static void lcd2x_dark_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=2) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x000000FF;
+			d[dx+dp32] = pix & 0x0000FF00; d[dx+dp32+1] = 0;
+		}
+	}
+}
+
+static void lcd2x_dark_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_dark_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_dark_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_dark_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_dark_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd2x_dark_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd2x_dark_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd2x_dark_generic = {
+   lcd2x_dark_generic_input_fmts,
+   lcd2x_dark_generic_output_fmts,
+
+   lcd2x_dark_generic_create,
+   lcd2x_dark_generic_destroy,
+
+   lcd2x_dark_generic_threads,
+   lcd2x_dark_generic_output,
+   lcd2x_dark_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD2x_dark",
+   "lcd2x_dark",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd2x_dark_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd2x_light.c b/gfx/video_filters/lcd2x_light.c
new file mode 100644
index 0000000000..da46f9471c
--- /dev/null
+++ b/gfx/video_filters/lcd2x_light.c
@@ -0,0 +1,219 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd2x_light.so -shared lcd2x_light.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd2x_light_get_implementation
+#define softfilter_thread_data lcd2x_light_softfilter_thread_data
+#define filter_data lcd2x_light_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd2x_light_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd2x_light_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd2x_light_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd2x_light_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd2x_light_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width<<1;
+   *out_height = height<<1;
+}
+
+static void lcd2x_light_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd2x_light_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, dpix4, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=2) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x001F)<<16);		// RB
+			dpix2=(pix & 0x07E0) | (pix<<16);			// GP
+			dpix3=((pix>>16) & 0xF800) | (pix & 0x001F0000);	// rb
+			dpix4=((pix>>16) & 0x07E0) | (pix & 0xFFFF0000);	// gp
+			d[dx] = dpix1; d[dx+1] = dpix3;
+			d[dx+dp32] = dpix2; d[dx+dp32+1] = dpix4;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x001F)<<16);	// RB
+			dpix2=(pix16 & 0x07E0) | (pix16<<16);			// GP
+			d[dx] = dpix1;
+			d[dx+dp32] = dpix2;
+		}
+	}
+}
+
+static void lcd2x_light_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=2; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*2) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=2) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x000000FF;
+			d[dx+dp32] = pix & 0x0000FF00; d[dx+dp32+1] = pix;
+		}
+	}
+}
+
+static void lcd2x_light_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_light_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_light_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd2x_light_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd2x_light_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd2x_light_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd2x_light_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd2x_light_generic = {
+   lcd2x_light_generic_input_fmts,
+   lcd2x_light_generic_output_fmts,
+
+   lcd2x_light_generic_create,
+   lcd2x_light_generic_destroy,
+
+   lcd2x_light_generic_threads,
+   lcd2x_light_generic_output,
+   lcd2x_light_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD2x_light",
+   "lcd2x_light",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd2x_light_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_dark.c b/gfx/video_filters/lcd3x_dark.c
new file mode 100644
index 0000000000..2930b80df0
--- /dev/null
+++ b/gfx/video_filters/lcd3x_dark.c
@@ -0,0 +1,229 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_dark.so -shared lcd3x_dark.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_dark_get_implementation
+#define softfilter_thread_data lcd3x_dark_softfilter_thread_data
+#define filter_data lcd3x_dark_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_dark_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_dark_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_dark_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_dark_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_dark_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_dark_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_dark_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF8000000);				// -r
+			dpix3=((pix>>16) & 0x07E0);				// g-
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx+dp32] = dpix1; d[dx+dp32+1] = dpix2; d[dx+dp32+2] = dpix3;
+			dpix1=0;						// --
+			dpix2=(pix & 0x001F);					// B-
+			dpix3=(pix & 0x001F0000);				// -b
+			d[dx+dp32*2] = dpix1; d[dx+dp32*2+1] = dpix2; d[dx+dp32*2+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = 0;			// -
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx+dp32] = dpix1; d16[(dx+dp32+1)*2] = (pix16 & 0x001F);// B
+			dpix1=0;						// --
+			d[dx+dp32*2] = dpix1; d16[(dx+dp32*2+1)*2] = (pix16 & 0x001F);// B
+		}
+	}
+}
+
+static void lcd3x_dark_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = 0;
+			d[dx+dp32] = pix & 0x00FF0000; d[dx+dp32+1] = pix & 0x0000FF00; d[dx+dp32+2] = pix & 0x000000FF;
+			d[dx+dp32*2] = 0; d[dx+dp32*2+1] = 0; d[dx+dp32*2+2] = pix & 0x000000FF;
+		}
+	}
+}
+
+static void lcd3x_dark_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_dark_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_dark_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_dark_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_dark_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_dark_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_dark_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_dark_generic = {
+   lcd3x_dark_generic_input_fmts,
+   lcd3x_dark_generic_output_fmts,
+
+   lcd3x_dark_generic_create,
+   lcd3x_dark_generic_destroy,
+
+   lcd3x_dark_generic_threads,
+   lcd3x_dark_generic_output,
+   lcd3x_dark_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_dark",
+   "lcd3x_dark",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_dark_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_light.c b/gfx/video_filters/lcd3x_light.c
new file mode 100644
index 0000000000..7981b0d96b
--- /dev/null
+++ b/gfx/video_filters/lcd3x_light.c
@@ -0,0 +1,229 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_light.so -shared lcd3x_light.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_light_get_implementation
+#define softfilter_thread_data lcd3x_light_softfilter_thread_data
+#define filter_data lcd3x_light_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_light_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_light_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_light_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_light_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_light_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_light_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_light_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800FFFF);				// Pr
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0xFFFF0000);	// gp
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx+dp32] = dpix1; d[dx+dp32+1] = dpix2; d[dx+dp32+2] = dpix3;
+			dpix1=(pix & 0xFFFF) | (pix<<16);			// PP
+			dpix2=(pix & 0xFFFF001F);				// Bp
+			dpix3=(pix>>16) | (pix & 0x001F0000);			// pb
+			d[dx+dp32*2] = dpix1; d[dx+dp32*2+1] = dpix2; d[dx+dp32*2+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = pix16;			// P
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx+dp32] = dpix1; d16[(dx+dp32+1)*2] = (pix16 & 0x001F);// B
+			dpix1=(pix16 | (pix16 <<16));				// PP
+			d[dx+dp32*2] = dpix1; d16[(dx+dp32*2+1)*2] = (pix16 & 0x001F);// B
+		}
+	}
+}
+
+static void lcd3x_light_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = pix;
+			d[dx+dp32] = pix & 0x00FF0000; d[dx+dp32+1] = pix & 0x0000FF00; d[dx+dp32+2] = pix & 0x000000FF;
+			d[dx+dp32*2] = pix; d[dx+dp32*2+1] = pix; d[dx+dp32*2+2] = pix & 0x000000FF;
+		}
+	}
+}
+
+static void lcd3x_light_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_light_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_light_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_light_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_light_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_light_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_light_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_light_generic = {
+   lcd3x_light_generic_input_fmts,
+   lcd3x_light_generic_output_fmts,
+
+   lcd3x_light_generic_create,
+   lcd3x_light_generic_destroy,
+
+   lcd3x_light_generic_threads,
+   lcd3x_light_generic_output,
+   lcd3x_light_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_light",
+   "lcd3x_light",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_light_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_mosaic.c b/gfx/video_filters/lcd3x_mosaic.c
new file mode 100644
index 0000000000..dcec93dfb0
--- /dev/null
+++ b/gfx/video_filters/lcd3x_mosaic.c
@@ -0,0 +1,229 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_mosaic.so -shared lcd3x_mosaic.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_mosaic_get_implementation
+#define softfilter_thread_data lcd3x_mosaic_softfilter_thread_data
+#define filter_data lcd3x_mosaic_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_mosaic_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_mosaic_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_mosaic_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_mosaic_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_mosaic_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_mosaic_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_mosaic_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+			dpix1=(pix & 0x07E0) | ((pix & 0x001F)<<16);		// GB
+			dpix2=(pix & 0x07E0F800);				// Rg
+			dpix3=((pix>>16) & 0x001F) | (pix & 0xF8000000);	// br
+			d[dx+dp32] = dpix1; d[dx+dp32+1] = dpix2; d[dx+dp32+2] = dpix3;
+			dpix1=(pix & 0x001F) | ((pix & 0xF800)<<16);		// BR
+			dpix2=(pix & 0x001F07E0);				// Gb
+			dpix3=((pix>>16) & 0xF800) | (pix & 0x07E00000);	// rg
+			d[dx+dp32*2] = dpix1; d[dx+dp32*2+1] = dpix2; d[dx+dp32*2+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = (pix16 & 0x001F);	// B
+			dpix1=(pix16 & 0x07E0) | ((pix16 & 0x001F)<<16);	// GB
+			d[dx+dp32] = dpix1; d16[(dx+dp32+1)*2] = (pix16 & 0xF800);// R
+			dpix1=(pix16 & 0x001F) | ((pix16 & 0xF800)<<16);	// BR
+			d[dx+dp32*2] = dpix1; d16[(dx+dp32*2+1)*2] = (pix16 & 0x07E0);// G
+		}
+	}
+}
+
+static void lcd3x_mosaic_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	uint32_t dp32 = dp >> 2;
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = pix & 0x000000FF;
+			d[dx+dp32] = pix & 0x0000FF00; d[dx+dp32+1] = pix & 0x000000FF; d[dx+dp32+2] = pix & 0x00FF0000;
+			d[dx+dp32*2] = pix & 0x000000FF; d[dx+dp32*2+1] = pix & 0x00FF0000; d[dx+dp32*2+2] = pix & 0x0000FF00;
+		}
+	}
+}
+
+static void lcd3x_mosaic_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_mosaic_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_mosaic_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_mosaic_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_mosaic_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_mosaic_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_mosaic_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_mosaic_generic = {
+   lcd3x_mosaic_generic_input_fmts,
+   lcd3x_mosaic_generic_output_fmts,
+
+   lcd3x_mosaic_generic_create,
+   lcd3x_mosaic_generic_destroy,
+
+   lcd3x_mosaic_generic_threads,
+   lcd3x_mosaic_generic_output,
+   lcd3x_mosaic_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_mosaic",
+   "lcd3x_mosaic",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_mosaic_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/lcd3x_stripe.c b/gfx/video_filters/lcd3x_stripe.c
new file mode 100644
index 0000000000..dd18e0b744
--- /dev/null
+++ b/gfx/video_filters/lcd3x_stripe.c
@@ -0,0 +1,217 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o lcd3x_stripe.so -shared lcd3x_stripe.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation lcd3x_stripe_get_implementation
+#define softfilter_thread_data lcd3x_stripe_softfilter_thread_data
+#define filter_data lcd3x_stripe_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned lcd3x_stripe_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned lcd3x_stripe_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned lcd3x_stripe_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *lcd3x_stripe_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void lcd3x_stripe_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void lcd3x_stripe_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void lcd3x_stripe_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, dpix3, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0xF800) | ((pix & 0x07E0)<<16);		// RG
+			dpix2=(pix & 0xF800001F);				// Br
+			dpix3=((pix>>16) & 0x07E0) | (pix & 0x001F0000);	// gb
+			d[dx] = dpix1; d[dx+1] = dpix2; d[dx+2] = dpix3;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1=(pix16 & 0xF800) | ((pix16 & 0x07E0)<<16);	// RG
+			d[dx] = dpix1; d16[(dx+1)*2] = (pix16 & 0x001F);	// B
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void lcd3x_stripe_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix & 0x00FF0000; d[dx+1] = pix & 0x0000FF00; d[dx+2] = pix & 0x000000FF;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void lcd3x_stripe_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_stripe_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_stripe_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   lcd3x_stripe_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void lcd3x_stripe_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = lcd3x_stripe_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = lcd3x_stripe_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation lcd3x_stripe_generic = {
+   lcd3x_stripe_generic_input_fmts,
+   lcd3x_stripe_generic_output_fmts,
+
+   lcd3x_stripe_generic_create,
+   lcd3x_stripe_generic_destroy,
+
+   lcd3x_stripe_generic_threads,
+   lcd3x_stripe_generic_output,
+   lcd3x_stripe_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "LCD3x_stripe",
+   "lcd3x_stripe",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &lcd3x_stripe_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/make b/gfx/video_filters/make
new file mode 100644
index 0000000000..505a6558c6
--- /dev/null
+++ b/gfx/video_filters/make
@@ -0,0 +1,11 @@
+#!/bin/sh
+CROSS_COMPILE="/opt/miyoomini-toolchain/bin/arm-linux-gnueabihf-"
+CFLAGS="-Ofast -marm -mtune=cortex-a7 -mfpu=neon-vfpv4 -mfloat-abi=hard -march=armv7ve+simd -std=c99 -shared -fPIC -Wall -s"
+${CROSS_COMPILE}gcc -o normal3x.so normal3x.c ${CFLAGS}
+${CROSS_COMPILE}gcc -o lcd2x_dark.so lcd2x_dark.c ${CFLAGS}
+${CROSS_COMPILE}gcc -o lcd2x_light.so lcd2x_light.c ${CFLAGS}
+${CROSS_COMPILE}gcc -o lcd3x_stripe.so lcd3x_stripe.c ${CFLAGS}
+${CROSS_COMPILE}gcc -o lcd3x_mosaic.so lcd3x_mosaic.c ${CFLAGS}
+${CROSS_COMPILE}gcc -o lcd3x_dark.so lcd3x_dark.c ${CFLAGS}
+${CROSS_COMPILE}gcc -o lcd3x_light.so lcd3x_light.c ${CFLAGS}
+${CROSS_COMPILE}gcc -o vertical3x4.so vertical3x4.c ${CFLAGS}
diff --git a/gfx/video_filters/normal2x.c b/gfx/video_filters/normal2x.c
index 9f7bf447aa..ed591ec7e7 100644
--- a/gfx/video_filters/normal2x.c
+++ b/gfx/video_filters/normal2x.c
@@ -16,6 +16,10 @@
 
 /* Compile: gcc -o normal2x.so -shared normal2x.c -std=c99 -O3 -Wall -pedantic -fPIC */
 
+#ifdef MIYOOMINI
+#include "../drivers/miyoomini/scaler_neon.h"
+#endif
+
 #include "softfilter.h"
 #include <stdlib.h>
 #include <string.h>
@@ -68,17 +72,22 @@ static void *normal2x_generic_create(const struct softfilter_config *config,
       unsigned threads, softfilter_simd_mask_t simd, void *userdata)
 {
    struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
-   if (!filt)
-      return NULL;
-   if (!(filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data))))
-   {
-      free(filt);
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
       return NULL;
    }
    /* Apparently the code is not thread-safe,
     * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
    filt->threads = 1;
    filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
    return filt;
 }
 
@@ -86,15 +95,16 @@ static void normal2x_generic_output(void *data,
       unsigned *out_width, unsigned *out_height,
       unsigned width, unsigned height)
 {
-   *out_width  = width << 1;
+   *out_width = width << 1;
    *out_height = height << 1;
 }
 
 static void normal2x_generic_destroy(void *data)
 {
    struct filter_data *filt = (struct filter_data*)data;
-   if (!filt)
+   if (!filt) {
       return;
+   }
    free(filt->workers);
    free(filt);
 }
@@ -102,6 +112,9 @@ static void normal2x_generic_destroy(void *data)
 static void normal2x_work_cb_xrgb8888(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale2x2_n32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint32_t *input              = (const uint32_t*)thr->in_data;
    uint32_t *output                   = (uint32_t*)thr->out_data;
    uint32_t in_stride                 = (uint32_t)(thr->in_pitch >> 2);
@@ -113,16 +126,16 @@ static void normal2x_work_cb_xrgb8888(void *data, void *thread_data)
       uint32_t *out_ptr = output;
       for (x = 0; x < thr->width; ++x)
       {
-         uint32_t row_color[2];
          uint32_t *out_line_ptr = out_ptr;
          uint32_t color         = *(input + x);
+         uint32_t row_color[2];
 
-         row_color[0]           = color;
-         row_color[1]           = color;
+         row_color[0] = color;
+         row_color[1] = color;
 
          /* Row 1 */
          memcpy(out_line_ptr, row_color, sizeof(row_color));
-         out_line_ptr          += out_stride;
+         out_line_ptr += out_stride;
 
          /* Row 2 */
          memcpy(out_line_ptr, row_color, sizeof(row_color));
@@ -133,11 +146,15 @@ static void normal2x_work_cb_xrgb8888(void *data, void *thread_data)
       input  += in_stride;
       output += out_stride << 1;
    }
+#endif
 }
 
 static void normal2x_work_cb_rgb565(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale2x2_n16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint16_t *input              = (const uint16_t*)thr->in_data;
    uint16_t *output                   = (uint16_t*)thr->out_data;
    uint16_t in_stride                 = (uint16_t)(thr->in_pitch >> 1);
@@ -149,26 +166,27 @@ static void normal2x_work_cb_rgb565(void *data, void *thread_data)
       uint16_t *out_ptr = output;
       for (x = 0; x < thr->width; ++x)
       {
-         uint16_t row_color[2];
          uint16_t *out_line_ptr = out_ptr;
          uint16_t color         = *(input + x);
+         uint16_t row_color[2];
 
-         row_color[0]           = color;
-         row_color[1]           = color;
+         row_color[0] = color;
+         row_color[1] = color;
 
          /* Row 1 */
          memcpy(out_line_ptr, row_color, sizeof(row_color));
-         out_line_ptr          += out_stride;
+         out_line_ptr += out_stride;
 
          /* Row 2 */
          memcpy(out_line_ptr, row_color, sizeof(row_color));
 
-         out_ptr               += 2;
+         out_ptr += 2;
       }
 
-      input                    += in_stride;
-      output                   += out_stride << 1;
+      input  += in_stride;
+      output += out_stride << 1;
    }
+#endif
 }
 
 static void normal2x_generic_packets(void *data,
@@ -181,21 +199,22 @@ static void normal2x_generic_packets(void *data,
     * over threads and can cull some code. This only
     * makes the tiniest performance difference, but
     * every little helps when running on an o3DS... */
-   struct filter_data *filt           = (struct filter_data*)data;
+   struct filter_data *filt = (struct filter_data*)data;
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
 
-   thr->out_data                      = (uint8_t*)output;
-   thr->in_data                       = (const uint8_t*)input;
-   thr->out_pitch                     = output_stride;
-   thr->in_pitch                      = input_stride;
-   thr->width                         = width;
-   thr->height                        = height;
-
-   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888)
-      packets[0].work                 = normal2x_work_cb_xrgb8888;
-   else if (filt->in_fmt == SOFTFILTER_FMT_RGB565)
-      packets[0].work                 = normal2x_work_cb_rgb565;
-   packets[0].thread_data             = thr;
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = normal2x_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = normal2x_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
 }
 
 static const struct softfilter_implementation normal2x_generic = {
@@ -217,6 +236,7 @@ static const struct softfilter_implementation normal2x_generic = {
 const struct softfilter_implementation *softfilter_get_implementation(
       softfilter_simd_mask_t simd)
 {
+   (void)simd;
    return &normal2x_generic;
 }
 
diff --git a/gfx/video_filters/normal3x.c b/gfx/video_filters/normal3x.c
new file mode 100644
index 0000000000..afc1f1bb8c
--- /dev/null
+++ b/gfx/video_filters/normal3x.c
@@ -0,0 +1,216 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o normal3x.so -shared normal3x.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation normal3x_get_implementation
+#define softfilter_thread_data normal3x_softfilter_thread_data
+#define filter_data normal3x_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned normal3x_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned normal3x_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned normal3x_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *normal3x_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void normal3x_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width * 3;
+   *out_height = height * 3;
+}
+
+static void normal3x_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void scale3x_c16(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, dpix1, dpix2, swl = sw*sizeof(uint16_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<(sw/2); x++, dx+=3) {
+			pix = s[x];
+			dpix1=(pix & 0x0000FFFF)|(pix<<16);
+			dpix2=(pix & 0xFFFF0000)|(pix>>16);
+			d[dx] = dpix1; d[dx+1] = pix; d[dx+2] = dpix2;
+		}
+		if (sw&1) {
+			uint16_t *s16 = (uint16_t*)s;
+			uint16_t *d16 = (uint16_t*)d;
+			uint16_t pix16 = s16[x*2];
+			dpix1 = pix16|(pix16<<16);
+			d[dx] = dpix1; d16[(dx+1)*2] = pix16;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void scale3x_c32(void* __restrict src, void* __restrict dst, uint32_t sw, uint32_t sh, uint32_t sp, uint32_t dp) {
+	if (!sw||!sh) { return; }
+	uint32_t x, dx, pix, swl = sw*sizeof(uint32_t);
+	if (!sp) { sp = swl; } swl*=3; if (!dp) { dp = swl; }
+	for (; sh>0; sh--, src=(uint8_t*)src+sp, dst=(uint8_t*)dst+dp*3) {
+		uint32_t *s = (uint32_t* __restrict)src;
+		uint32_t *d = (uint32_t* __restrict)dst;
+		for (x=dx=0; x<sw; x++, dx+=3) {
+			pix = s[x];
+			d[dx] = pix; d[dx+1] = pix; d[dx+2] = pix;
+		}
+		memcpy((uint8_t*)dst+dp*1, dst, swl);
+		memcpy((uint8_t*)dst+dp*2, dst, swl);
+	}
+}
+
+static void normal3x_work_cb_xrgb8888(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   scale3x_c32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void normal3x_work_cb_rgb565(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   scale3x_c16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+}
+
+static void normal3x_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = normal3x_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = normal3x_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation normal3x_generic = {
+   normal3x_generic_input_fmts,
+   normal3x_generic_output_fmts,
+
+   normal3x_generic_create,
+   normal3x_generic_destroy,
+
+   normal3x_generic_threads,
+   normal3x_generic_output,
+   normal3x_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "Normal3x",
+   "normal3x",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &normal3x_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
diff --git a/gfx/video_filters/normal4x.c b/gfx/video_filters/normal4x.c
index c0af01478e..1137d3e9a4 100644
--- a/gfx/video_filters/normal4x.c
+++ b/gfx/video_filters/normal4x.c
@@ -16,6 +16,10 @@
 
 /* Compile: gcc -o normal4x.so -shared normal4x.c -std=c99 -O3 -Wall -pedantic -fPIC */
 
+#ifdef MIYOOMINI
+#include "../drivers/miyoomini/scaler_neon.h"
+#endif
+
 #include "softfilter.h"
 #include <stdlib.h>
 #include <string.h>
@@ -68,17 +72,22 @@ static void *normal4x_generic_create(const struct softfilter_config *config,
       unsigned threads, softfilter_simd_mask_t simd, void *userdata)
 {
    struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
-   if (!filt)
-      return NULL;
-   if (!(filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data))))
-   {
-      free(filt);
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
       return NULL;
    }
    /* Apparently the code is not thread-safe,
     * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
    filt->threads = 1;
    filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
    return filt;
 }
 
@@ -86,15 +95,16 @@ static void normal4x_generic_output(void *data,
       unsigned *out_width, unsigned *out_height,
       unsigned width, unsigned height)
 {
-   *out_width  = width << 2;
+   *out_width = width << 2;
    *out_height = height << 2;
 }
 
 static void normal4x_generic_destroy(void *data)
 {
    struct filter_data *filt = (struct filter_data*)data;
-   if (!filt)
+   if (!filt) {
       return;
+   }
    free(filt->workers);
    free(filt);
 }
@@ -102,6 +112,9 @@ static void normal4x_generic_destroy(void *data)
 static void normal4x_work_cb_xrgb8888(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale4x4_n32((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint32_t *input              = (const uint32_t*)thr->in_data;
    uint32_t *output                   = (uint32_t*)thr->out_data;
    uint32_t in_stride                 = (uint32_t)(thr->in_pitch >> 2);
@@ -143,11 +156,15 @@ static void normal4x_work_cb_xrgb8888(void *data, void *thread_data)
       input  += in_stride;
       output += out_stride << 2;
    }
+#endif
 }
 
 static void normal4x_work_cb_rgb565(void *data, void *thread_data)
 {
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+#ifdef MIYOOMINI
+   scale4x4_n16((void*)thr->in_data, thr->out_data, thr->width, thr->height, thr->in_pitch, thr->out_pitch);
+#else
    const uint16_t *input              = (const uint16_t*)thr->in_data;
    uint16_t *output                   = (uint16_t*)thr->out_data;
    uint16_t in_stride                 = (uint16_t)(thr->in_pitch >> 1);
@@ -159,9 +176,9 @@ static void normal4x_work_cb_rgb565(void *data, void *thread_data)
       uint16_t *out_ptr = output;
       for (x = 0; x < thr->width; ++x)
       {
-         uint16_t row_color[4];
          uint16_t *out_line_ptr = out_ptr;
          uint16_t color         = *(input + x);
+         uint16_t row_color[4];
 
          row_color[0] = color;
          row_color[1] = color;
@@ -189,6 +206,7 @@ static void normal4x_work_cb_rgb565(void *data, void *thread_data)
       input  += in_stride;
       output += out_stride << 2;
    }
+#endif
 }
 
 static void normal4x_generic_packets(void *data,
@@ -201,21 +219,22 @@ static void normal4x_generic_packets(void *data,
     * over threads and can cull some code. This only
     * makes the tiniest performance difference, but
     * every little helps when running on an o3DS... */
-   struct filter_data *filt           = (struct filter_data*)data;
+   struct filter_data *filt = (struct filter_data*)data;
    struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
 
-   thr->out_data                      = (uint8_t*)output;
-   thr->in_data                       = (const uint8_t*)input;
-   thr->out_pitch                     = output_stride;
-   thr->in_pitch                      = input_stride;
-   thr->width                         = width;
-   thr->height                        = height;
-
-   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888)
-      packets[0].work                 = normal4x_work_cb_xrgb8888;
-   else if (filt->in_fmt == SOFTFILTER_FMT_RGB565)
-      packets[0].work                 = normal4x_work_cb_rgb565;
-   packets[0].thread_data             = thr;
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   if (filt->in_fmt == SOFTFILTER_FMT_XRGB8888) {
+      packets[0].work = normal4x_work_cb_xrgb8888;
+   } else if (filt->in_fmt == SOFTFILTER_FMT_RGB565) {
+      packets[0].work = normal4x_work_cb_rgb565;
+   }
+   packets[0].thread_data = thr;
 }
 
 static const struct softfilter_implementation normal4x_generic = {
@@ -237,6 +256,7 @@ static const struct softfilter_implementation normal4x_generic = {
 const struct softfilter_implementation *softfilter_get_implementation(
       softfilter_simd_mask_t simd)
 {
+   (void)simd;
    return &normal4x_generic;
 }
 
diff --git a/gfx/video_filters/vertical3x4.c b/gfx/video_filters/vertical3x4.c
new file mode 100644
index 0000000000..384b3ae6d0
--- /dev/null
+++ b/gfx/video_filters/vertical3x4.c
@@ -0,0 +1,192 @@
+/*  RetroArch - A frontend for libretro.
+ *  Copyright (C) 2010-2014 - Hans-Kristian Arntzen
+ *  Copyright (C) 2011-2018 - Daniel De Matteis
+ *
+ *  RetroArch is free software: you can redistribute it and/or modify it under the terms
+ *  of the GNU General Public License as published by the Free Software Found-
+ *  ation, either version 3 of the License, or (at your option) any later version.
+ *
+ *  RetroArch is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
+ *  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ *  PURPOSE.  See the GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along with RetroArch.
+ *  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/* Compile: gcc -o vertical3x4.so -shared vertical3x4.c -std=c99 -O3 -Wall -pedantic -fPIC */
+
+#include "softfilter.h"
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef RARCH_INTERNAL
+#define softfilter_get_implementation vertical3x4_get_implementation
+#define softfilter_thread_data vertical3x4_softfilter_thread_data
+#define filter_data vertical3x4_filter_data
+#endif
+
+struct softfilter_thread_data
+{
+   void *out_data;
+   const void *in_data;
+   size_t out_pitch;
+   size_t in_pitch;
+   unsigned colfmt;
+   unsigned width;
+   unsigned height;
+   int first;
+   int last;
+};
+
+struct filter_data
+{
+   unsigned threads;
+   struct softfilter_thread_data *workers;
+   unsigned in_fmt;
+};
+
+static unsigned vertical3x4_generic_input_fmts(void)
+{
+   return SOFTFILTER_FMT_XRGB8888 | SOFTFILTER_FMT_RGB565;
+}
+
+static unsigned vertical3x4_generic_output_fmts(unsigned input_fmts)
+{
+   return input_fmts;
+}
+
+static unsigned vertical3x4_generic_threads(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   return filt->threads;
+}
+
+static void *vertical3x4_generic_create(const struct softfilter_config *config,
+      unsigned in_fmt, unsigned out_fmt,
+      unsigned max_width, unsigned max_height,
+      unsigned threads, softfilter_simd_mask_t simd, void *userdata)
+{
+   struct filter_data *filt = (struct filter_data*)calloc(1, sizeof(*filt));
+   (void)simd;
+   (void)config;
+   (void)userdata;
+
+   if (!filt) {
+      return NULL;
+   }
+   /* Apparently the code is not thread-safe,
+    * so force single threaded operation... */
+   filt->workers = (struct softfilter_thread_data*)calloc(1, sizeof(struct softfilter_thread_data));
+   filt->threads = 1;
+   filt->in_fmt  = in_fmt;
+   if (!filt->workers) {
+      free(filt);
+      return NULL;
+   }
+   return filt;
+}
+
+static void vertical3x4_generic_output(void *data,
+      unsigned *out_width, unsigned *out_height,
+      unsigned width, unsigned height)
+{
+   *out_width = width;
+   *out_height = height + ((((height << 4) / 9) - height) & ~1);
+}
+
+static void vertical3x4_generic_destroy(void *data)
+{
+   struct filter_data *filt = (struct filter_data*)data;
+   if (!filt) {
+      return;
+   }
+   free(filt->workers);
+   free(filt);
+}
+
+static void vertical3x4_work_cb(void *data, void *thread_data)
+{
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)thread_data;
+   const void* src = thr->in_data;
+   void* dst = thr->out_data;
+   unsigned ip = thr->in_pitch;
+   unsigned op = thr->out_pitch;
+   unsigned ch = thr->height;
+   unsigned bh = (((ch << 4) / 9) - ch) >> 1;
+
+   if (ip == op) {
+      unsigned cs = op * ch;
+      if (bh) {
+         unsigned bs = op * bh;
+         memset(dst, 0, bs); dst += bs;
+         memcpy(dst, src, cs); dst += cs;
+         memset(dst, 0, bs);
+      } else {
+         memcpy(dst, src, cs);
+      }
+   } else {
+      unsigned i;
+      if (bh) {
+         unsigned bs = op * bh;
+         memset(dst, 0, bs); dst += bs;
+         for (i=ch; i>0; i--, src += ip, dst += op) memcpy(dst, src, ip);
+         memset(dst, 0, bs);
+      } else {
+         for (i=ch; i>0; i--, src += ip, dst += op) memcpy(dst, src, ip);
+      }
+   }
+}
+
+static void vertical3x4_generic_packets(void *data,
+      struct softfilter_work_packet *packets,
+      void *output, size_t output_stride,
+      const void *input, unsigned width, unsigned height, size_t input_stride)
+{
+   /* We are guaranteed single threaded operation
+    * (filt->threads = 1) so we don't need to loop
+    * over threads and can cull some code. This only
+    * makes the tiniest performance difference, but
+    * every little helps when running on an o3DS... */
+   struct filter_data *filt = (struct filter_data*)data;
+   struct softfilter_thread_data *thr = (struct softfilter_thread_data*)&filt->workers[0];
+
+   thr->out_data = (uint8_t*)output;
+   thr->in_data = (const uint8_t*)input;
+   thr->out_pitch = output_stride;
+   thr->in_pitch = input_stride;
+   thr->width = width;
+   thr->height = height;
+
+   packets[0].work = vertical3x4_work_cb;
+   packets[0].thread_data = thr;
+}
+
+static const struct softfilter_implementation vertical3x4_generic = {
+   vertical3x4_generic_input_fmts,
+   vertical3x4_generic_output_fmts,
+
+   vertical3x4_generic_create,
+   vertical3x4_generic_destroy,
+
+   vertical3x4_generic_threads,
+   vertical3x4_generic_output,
+   vertical3x4_generic_packets,
+
+   SOFTFILTER_API_VERSION,
+   "Vertical3x4",
+   "vertical3x4",
+};
+
+const struct softfilter_implementation *softfilter_get_implementation(
+      softfilter_simd_mask_t simd)
+{
+   (void)simd;
+   return &vertical3x4_generic;
+}
+
+#ifdef RARCH_INTERNAL
+#undef softfilter_get_implementation
+#undef softfilter_thread_data
+#undef filter_data
+#endif
